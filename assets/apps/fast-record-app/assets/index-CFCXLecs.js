function t_(s,t){for(var e=0;e<t.length;e++){const n=t[e];if(typeof n!="string"&&!Array.isArray(n)){for(const r in n)if(r!=="default"&&!(r in s)){const i=Object.getOwnPropertyDescriptor(n,r);i&&Object.defineProperty(s,r,i.get?i:{enumerable:!0,get:()=>n[r]})}}}return Object.freeze(Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();function z(s,t,e){return(t=(function(n){var r=(function(i,o){if(typeof i!="object"||!i)return i;var a=i[Symbol.toPrimitive];if(a!==void 0){var l=a.call(i,o);if(typeof l!="object")return l;throw new TypeError("@@toPrimitive must return a primitive value.")}return(o==="string"?String:Number)(i)})(n,"string");return typeof r=="symbol"?r:r+""})(t))in s?Object.defineProperty(s,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):s[t]=e,s}function Wx(s,t){var e=Object.keys(s);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(s);t&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(s,r).enumerable}))),e.push.apply(e,n)}return e}function V(s){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?Wx(Object(e),!0).forEach((function(n){z(s,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(s,Object.getOwnPropertyDescriptors(e)):Wx(Object(e)).forEach((function(n){Object.defineProperty(s,n,Object.getOwnPropertyDescriptor(e,n))}))}return s}function se(s,t){if(s==null)return{};var e,n,r=(function(o,a){if(o==null)return{};var l={};for(var c in o)if({}.hasOwnProperty.call(o,c)){if(a.indexOf(c)>=0)continue;l[c]=o[c]}return l})(s,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(s);for(n=0;n<i.length;n++)e=i[n],t.indexOf(e)>=0||{}.propertyIsEnumerable.call(s,e)&&(r[e]=s[e])}return r}function or(s,t){return t||(t=s.slice(0)),Object.freeze(Object.defineProperties(s,{raw:{value:Object.freeze(t)}}))}class Ux{constructor(){z(this,"browserShadowBlurConstant",1),z(this,"DPI",96),z(this,"devicePixelRatio",typeof window<"u"?window.devicePixelRatio:1),z(this,"perfLimitSizeTotal",2097152),z(this,"maxCacheSideLimit",4096),z(this,"minCacheSideLimit",256),z(this,"disableStyleCopyPaste",!1),z(this,"enableGLFiltering",!0),z(this,"textureSize",4096),z(this,"forceGLPutImageData",!1),z(this,"cachesBoundsOfCurve",!1),z(this,"fontPaths",{}),z(this,"NUM_FRACTION_DIGITS",4)}}const Mt=new class extends Ux{constructor(s){super(),this.configure(s)}configure(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};Object.assign(this,s)}addFonts(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.fontPaths=V(V({},this.fontPaths),s)}removeFonts(){(arguments.length>0&&arguments[0]!==void 0?arguments[0]:[]).forEach((s=>{delete this.fontPaths[s]}))}clearFonts(){this.fontPaths={}}restoreDefaults(s){const t=new Ux,e=s?.reduce(((n,r)=>(n[r]=t[r],n)),{})||t;this.configure(e)}},ri=function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return console[s]("fabric",...e)};class Us extends Error{constructor(t,e){super("fabric: ".concat(t),e)}}class e_ extends Us{constructor(t){super("".concat(t," 'options.signal' is in 'aborted' state"))}}class n_{}class s_ extends n_{testPrecision(t,e){const n="precision ".concat(e,` float;
void main(){}`),r=t.createShader(t.FRAGMENT_SHADER);return!!r&&(t.shaderSource(r,n),t.compileShader(r),!!t.getShaderParameter(r,t.COMPILE_STATUS))}queryWebGL(t){const e=t.getContext("webgl");e&&(this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.GLPrecision=["highp","mediump","lowp"].find((n=>this.testPrecision(e,n))),e.getExtension("WEBGL_lose_context").loseContext(),ri("log","WebGL: max texture size ".concat(this.maxTextureSize)))}isSupported(t){return!!this.maxTextureSize&&this.maxTextureSize>=t}}const r_={};let Gx;const Qs=()=>Gx||(Gx={document,window,isTouchSupported:"ontouchstart"in window||"ontouchstart"in document||window&&window.navigator&&window.navigator.maxTouchPoints>0,WebGLProbe:new s_,dispose(){},copyPasteData:r_}),da=()=>Qs().document,up=()=>Qs().window,A1=()=>{var s;return Math.max((s=Mt.devicePixelRatio)!==null&&s!==void 0?s:up().devicePixelRatio,1)},Hl=new class{constructor(){z(this,"boundsOfCurveCache",{}),this.charWidthsCache=new Map}getFontCache(s){let{fontFamily:t,fontStyle:e,fontWeight:n}=s;t=t.toLowerCase();const r=this.charWidthsCache;r.has(t)||r.set(t,new Map);const i=r.get(t),o="".concat(e.toLowerCase(),"_").concat((n+"").toLowerCase());return i.has(o)||i.set(o,new Map),i.get(o)}clearFontCache(s){s?this.charWidthsCache.delete((s||"").toLowerCase()):this.charWidthsCache=new Map}limitDimsByArea(s){const{perfLimitSizeTotal:t}=Mt,e=Math.sqrt(t*s);return[Math.floor(e),Math.floor(t/e)]}},Tg="6.9.0";function ad(){}const Cc=Math.PI/2,Cd=2*Math.PI,Oy=Math.PI/180,yn=Object.freeze([1,0,0,1,0,0]),Ry=16,Kr=.4477152502,Et="center",Vt="left",An="top",kg="bottom",xe="right",On="none",Fy=/\r?\n/,O1="moving",hp="scaling",R1="rotating",Py="rotate",F1="skewing",Zl="resizing",i_="modifyPoly",o_="modifyPath",Td="changed",dp="scale",Fn="scaleX",us="scaleY",pa="skewX",fa="skewY",Fe="fill",Rn="stroke",kd="modified",Ao="json",Vm="svg",ut=new class{constructor(){this[Ao]=new Map,this[Vm]=new Map}has(s){return this[Ao].has(s)}getClass(s){const t=this[Ao].get(s);if(!t)throw new Us("No class registered for ".concat(s));return t}setClass(s,t){t?this[Ao].set(t,s):(this[Ao].set(s.type,s),this[Ao].set(s.type.toLowerCase(),s))}getSVGClass(s){return this[Vm].get(s)}setSVGClass(s,t){this[Vm].set(t??s.type.toLowerCase(),s)}},Id=new class extends Array{remove(s){const t=this.indexOf(s);t>-1&&this.splice(t,1)}cancelAll(){const s=this.splice(0);return s.forEach((t=>t.abort())),s}cancelByCanvas(s){if(!s)return[];const t=this.filter((e=>{var n;return e.target===s||typeof e.target=="object"&&((n=e.target)===null||n===void 0?void 0:n.canvas)===s}));return t.forEach((e=>e.abort())),t}cancelByTarget(s){if(!s)return[];const t=this.filter((e=>e.target===s));return t.forEach((e=>e.abort())),t}};class a_{constructor(){z(this,"__eventListeners",{})}on(t,e){if(this.__eventListeners||(this.__eventListeners={}),typeof t=="object")return Object.entries(t).forEach((n=>{let[r,i]=n;this.on(r,i)})),()=>this.off(t);if(e){const n=t;return this.__eventListeners[n]||(this.__eventListeners[n]=[]),this.__eventListeners[n].push(e),()=>this.off(n,e)}return()=>!1}once(t,e){if(typeof t=="object"){const n=[];return Object.entries(t).forEach((r=>{let[i,o]=r;n.push(this.once(i,o))})),()=>n.forEach((r=>r()))}if(e){const n=this.on(t,(function(){for(var r=arguments.length,i=new Array(r),o=0;o<r;o++)i[o]=arguments[o];e.call(this,...i),n()}));return n}return()=>!1}_removeEventListener(t,e){if(this.__eventListeners[t])if(e){const n=this.__eventListeners[t],r=n.indexOf(e);r>-1&&n.splice(r,1)}else this.__eventListeners[t]=[]}off(t,e){if(this.__eventListeners)if(t===void 0)for(const n in this.__eventListeners)this._removeEventListener(n);else typeof t=="object"?Object.entries(t).forEach((n=>{let[r,i]=n;this._removeEventListener(r,i)})):this._removeEventListener(t,e)}fire(t,e){var n;if(!this.__eventListeners)return;const r=(n=this.__eventListeners[t])===null||n===void 0?void 0:n.concat();if(r)for(let i=0;i<r.length;i++)r[i].call(this,e||{})}}const Mo=(s,t)=>{const e=s.indexOf(t);return e!==-1&&s.splice(e,1),s},Tr=s=>{if(s===0)return 1;switch(Math.abs(s)/Cc){case 1:case 3:return 0;case 2:return-1}return Math.cos(s)},kr=s=>{if(s===0)return 0;const t=s/Cc,e=Math.sign(s);switch(t){case 1:return e;case 2:return 0;case 3:return-e}return Math.sin(s)};class q{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;typeof t=="object"?(this.x=t.x,this.y=t.y):(this.x=t,this.y=e)}add(t){return new q(this.x+t.x,this.y+t.y)}addEquals(t){return this.x+=t.x,this.y+=t.y,this}scalarAdd(t){return new q(this.x+t,this.y+t)}scalarAddEquals(t){return this.x+=t,this.y+=t,this}subtract(t){return new q(this.x-t.x,this.y-t.y)}subtractEquals(t){return this.x-=t.x,this.y-=t.y,this}scalarSubtract(t){return new q(this.x-t,this.y-t)}scalarSubtractEquals(t){return this.x-=t,this.y-=t,this}multiply(t){return new q(this.x*t.x,this.y*t.y)}scalarMultiply(t){return new q(this.x*t,this.y*t)}scalarMultiplyEquals(t){return this.x*=t,this.y*=t,this}divide(t){return new q(this.x/t.x,this.y/t.y)}scalarDivide(t){return new q(this.x/t,this.y/t)}scalarDivideEquals(t){return this.x/=t,this.y/=t,this}eq(t){return this.x===t.x&&this.y===t.y}lt(t){return this.x<t.x&&this.y<t.y}lte(t){return this.x<=t.x&&this.y<=t.y}gt(t){return this.x>t.x&&this.y>t.y}gte(t){return this.x>=t.x&&this.y>=t.y}lerp(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:.5;return e=Math.max(Math.min(1,e),0),new q(this.x+(t.x-this.x)*e,this.y+(t.y-this.y)*e)}distanceFrom(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}midPointFrom(t){return this.lerp(t)}min(t){return new q(Math.min(this.x,t.x),Math.min(this.y,t.y))}max(t){return new q(Math.max(this.x,t.x),Math.max(this.y,t.y))}toString(){return"".concat(this.x,",").concat(this.y)}setXY(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setFromPoint(t){return this.x=t.x,this.y=t.y,this}swap(t){const e=this.x,n=this.y;this.x=t.x,this.y=t.y,t.x=e,t.y=n}clone(){return new q(this.x,this.y)}rotate(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Ly;const n=kr(t),r=Tr(t),i=this.subtract(e);return new q(i.x*r-i.y*n,i.x*n+i.y*r).add(e)}transform(t){let e=arguments.length>1&&arguments[1]!==void 0&&arguments[1];return new q(t[0]*this.x+t[2]*this.y+(e?0:t[4]),t[1]*this.x+t[3]*this.y+(e?0:t[5]))}}const Ly=new q(0,0),ld=s=>!!s&&Array.isArray(s._objects);function P1(s){class t extends s{constructor(){super(...arguments),z(this,"_objects",[])}_onObjectAdded(n){}_onObjectRemoved(n){}_onStackOrderChanged(n){}add(){for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];const o=this._objects.push(...r);return r.forEach((a=>this._onObjectAdded(a))),o}insertAt(n){for(var r=arguments.length,i=new Array(r>1?r-1:0),o=1;o<r;o++)i[o-1]=arguments[o];return this._objects.splice(n,0,...i),i.forEach((a=>this._onObjectAdded(a))),this._objects.length}remove(){const n=this._objects,r=[];for(var i=arguments.length,o=new Array(i),a=0;a<i;a++)o[a]=arguments[a];return o.forEach((l=>{const c=n.indexOf(l);c!==-1&&(n.splice(c,1),r.push(l),this._onObjectRemoved(l))})),r}forEachObject(n){this.getObjects().forEach(((r,i,o)=>n(r,i,o)))}getObjects(){for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return r.length===0?[...this._objects]:this._objects.filter((o=>o.isType(...r)))}item(n){return this._objects[n]}isEmpty(){return this._objects.length===0}size(){return this._objects.length}contains(n,r){return!!this._objects.includes(n)||!!r&&this._objects.some((i=>i instanceof t&&i.contains(n,!0)))}complexity(){return this._objects.reduce(((n,r)=>n+=r.complexity?r.complexity():0),0)}sendObjectToBack(n){return!(!n||n===this._objects[0])&&(Mo(this._objects,n),this._objects.unshift(n),this._onStackOrderChanged(n),!0)}bringObjectToFront(n){return!(!n||n===this._objects[this._objects.length-1])&&(Mo(this._objects,n),this._objects.push(n),this._onStackOrderChanged(n),!0)}sendObjectBackwards(n,r){if(!n)return!1;const i=this._objects.indexOf(n);if(i!==0){const o=this.findNewLowerIndex(n,i,r);return Mo(this._objects,n),this._objects.splice(o,0,n),this._onStackOrderChanged(n),!0}return!1}bringObjectForward(n,r){if(!n)return!1;const i=this._objects.indexOf(n);if(i!==this._objects.length-1){const o=this.findNewUpperIndex(n,i,r);return Mo(this._objects,n),this._objects.splice(o,0,n),this._onStackOrderChanged(n),!0}return!1}moveObjectTo(n,r){return n!==this._objects[r]&&(Mo(this._objects,n),this._objects.splice(r,0,n),this._onStackOrderChanged(n),!0)}findNewLowerIndex(n,r,i){let o;if(i){o=r;for(let a=r-1;a>=0;--a)if(n.isOverlapping(this._objects[a])){o=a;break}}else o=r-1;return o}findNewUpperIndex(n,r,i){let o;if(i){o=r;for(let a=r+1;a<this._objects.length;++a)if(n.isOverlapping(this._objects[a])){o=a;break}}else o=r+1;return o}collectObjects(n){let{left:r,top:i,width:o,height:a}=n,{includeIntersecting:l=!0}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const c=[],u=new q(r,i),h=u.add(new q(o,a));for(let d=this._objects.length-1;d>=0;d--){const p=this._objects[d];p.selectable&&p.visible&&(l&&p.intersectsWithRect(u,h)||p.isContainedWithinRect(u,h)||l&&p.containsPoint(u)||l&&p.containsPoint(h))&&c.push(p)}return c}}return t}class L1 extends a_{_setOptions(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};for(const e in t)this.set(e,t[e])}_setObject(t){for(const e in t)this._set(e,t[e])}set(t,e){return typeof t=="object"?this._setObject(t):this._set(t,e),this}_set(t,e){this[t]=e}toggle(t){const e=this.get(t);return typeof e=="boolean"&&this.set(t,!e),this}get(t){return this[t]}}function cd(s){return up().requestAnimationFrame(s)}function l_(s){return up().cancelAnimationFrame(s)}let c_=0;const ii=()=>c_++,Ir=()=>{const s=da().createElement("canvas");if(!s||s.getContext===void 0)throw new Us("Failed to create `canvas` element");return s},u_=()=>da().createElement("img"),hs=s=>{const t=Ir();return t.width=s.width,t.height=s.height,t},M1=(s,t,e)=>s.toDataURL("image/".concat(t),e),B1=(s,t,e)=>new Promise(((n,r)=>{s.toBlob(n,"image/".concat(t),e)})),Se=s=>s*Oy,Nr=s=>s/Oy,h_=s=>s.every(((t,e)=>t===yn[e])),Nn=(s,t,e)=>new q(s).transform(t,e),ks=s=>{const t=1/(s[0]*s[3]-s[1]*s[2]),e=[t*s[3],-t*s[1],-t*s[2],t*s[0],0,0],{x:n,y:r}=new q(s[4],s[5]).transform(e,!0);return e[4]=-n,e[5]=-r,e},Ze=(s,t,e)=>[s[0]*t[0]+s[2]*t[1],s[1]*t[0]+s[3]*t[1],s[0]*t[2]+s[2]*t[3],s[1]*t[2]+s[3]*t[3],e?0:s[0]*t[4]+s[2]*t[5]+s[4],e?0:s[1]*t[4]+s[3]*t[5]+s[5]],My=(s,t)=>s.reduceRight(((e,n)=>n&&e?Ze(n,e,t):n||e),void 0)||yn.concat(),z1=s=>{let[t,e]=s;return Math.atan2(e,t)},Nd=s=>{const t=z1(s),e=Math.pow(s[0],2)+Math.pow(s[1],2),n=Math.sqrt(e),r=(s[0]*s[3]-s[2]*s[1])/n,i=Math.atan2(s[0]*s[2]+s[1]*s[3],e);return{angle:Nr(t),scaleX:n,scaleY:r,skewX:Nr(i),skewY:0,translateX:s[4]||0,translateY:s[5]||0}},Tc=function(s){return[1,0,0,1,s,arguments.length>1&&arguments[1]!==void 0?arguments[1]:0]};function ma(){let{angle:s=0}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},{x:t=0,y:e=0}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const n=Se(s),r=Tr(n),i=kr(n);return[r,i,-i,r,t?t-(r*t-i*e):0,e?e-(i*t+r*e):0]}const By=function(s){return[s,0,0,arguments.length>1&&arguments[1]!==void 0?arguments[1]:s,0,0]},V1=s=>Math.tan(Se(s)),W1=s=>[1,0,V1(s),1,0,0],U1=s=>[1,V1(s),0,1,0,0],pp=s=>{let{scaleX:t=1,scaleY:e=1,flipX:n=!1,flipY:r=!1,skewX:i=0,skewY:o=0}=s,a=By(n?-t:t,r?-e:e);return i&&(a=Ze(a,W1(i),!0)),o&&(a=Ze(a,U1(o),!0)),a},d_=s=>{const{translateX:t=0,translateY:e=0,angle:n=0}=s;let r=Tc(t,e);n&&(r=Ze(r,ma({angle:n})));const i=pp(s);return h_(i)||(r=Ze(r,i)),r},ud=function(s){let{signal:t,crossOrigin:e=null}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return new Promise((function(n,r){if(t&&t.aborted)return r(new e_("loadImage"));const i=u_();let o;t&&(o=function(l){i.src="",r(l)},t.addEventListener("abort",o,{once:!0}));const a=function(){i.onload=i.onerror=null,o&&t?.removeEventListener("abort",o),n(i)};s?(i.onload=a,i.onerror=function(){o&&t?.removeEventListener("abort",o),r(new Us("Error loading ".concat(i.src)))},e&&(i.crossOrigin=e),i.src=s):a()}))},Jl=function(s){let{signal:t,reviver:e=ad}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return new Promise(((n,r)=>{const i=[];t&&t.addEventListener("abort",r,{once:!0}),Promise.all(s.map((o=>ut.getClass(o.type).fromObject(o,{signal:t}).then((a=>(e(o,a),i.push(a),a)))))).then(n).catch((o=>{i.forEach((a=>{a.dispose&&a.dispose()})),r(o)})).finally((()=>{t&&t.removeEventListener("abort",r)}))}))},fp=function(s){let{signal:t}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return new Promise(((e,n)=>{const r=[];t&&t.addEventListener("abort",n,{once:!0});const i=Object.values(s).map((a=>a&&a.type&&ut.has(a.type)?Jl([a],{signal:t}).then((l=>{let[c]=l;return r.push(c),c})):a)),o=Object.keys(s);Promise.all(i).then((a=>a.reduce(((l,c,u)=>(l[o[u]]=c,l)),{}))).then(e).catch((a=>{r.forEach((l=>{l.dispose&&l.dispose()})),n(a)})).finally((()=>{t&&t.removeEventListener("abort",n)}))}))},ga=function(s){return(arguments.length>1&&arguments[1]!==void 0?arguments[1]:[]).reduce(((t,e)=>(e in s&&(t[e]=s[e]),t)),{})},zy=(s,t)=>Object.keys(s).reduce(((e,n)=>(t(s[n],n,s)&&(e[n]=s[n]),e)),{}),Qt=(s,t)=>parseFloat(Number(s).toFixed(t)),Ql=s=>"matrix("+s.map((t=>Qt(t,Mt.NUM_FRACTION_DIGITS))).join(" ")+")",as=s=>!!s&&s.toLive!==void 0,jx=s=>!!s&&typeof s.toObject=="function",Hx=s=>!!s&&s.offsetX!==void 0&&"source"in s,Pi=s=>!!s&&"multiSelectionStacking"in s;function G1(s){const t=s&&Ts(s);let e=0,n=0;if(!s||!t)return{left:e,top:n};let r=s;const i=t.documentElement,o=t.body||{scrollLeft:0,scrollTop:0};for(;r&&(r.parentNode||r.host)&&(r=r.parentNode||r.host,r===t?(e=o.scrollLeft||i.scrollLeft||0,n=o.scrollTop||i.scrollTop||0):(e+=r.scrollLeft||0,n+=r.scrollTop||0),r.nodeType!==1||r.style.position!=="fixed"););return{left:e,top:n}}const Ts=s=>s.ownerDocument||null,j1=s=>{var t;return((t=s.ownerDocument)===null||t===void 0?void 0:t.defaultView)||null},H1=function(s,t,e){let{width:n,height:r}=e,i=arguments.length>3&&arguments[3]!==void 0?arguments[3]:1;s.width=n,s.height=r,i>1&&(s.setAttribute("width",(n*i).toString()),s.setAttribute("height",(r*i).toString()),t.scale(i,i))},Ig=(s,t)=>{let{width:e,height:n}=t;e&&(s.style.width=typeof e=="number"?"".concat(e,"px"):e),n&&(s.style.height=typeof n=="number"?"".concat(n,"px"):n)};function Xx(s){return s.onselectstart!==void 0&&(s.onselectstart=()=>!1),s.style.userSelect=On,s}class X1{constructor(t){z(this,"_originalCanvasStyle",void 0),z(this,"lower",void 0);const e=this.createLowerCanvas(t);this.lower={el:e,ctx:e.getContext("2d")}}createLowerCanvas(t){const e=(n=t)&&n.getContext!==void 0?t:t&&da().getElementById(t)||Ir();var n;if(e.hasAttribute("data-fabric"))throw new Us("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");return this._originalCanvasStyle=e.style.cssText,e.setAttribute("data-fabric","main"),e.classList.add("lower-canvas"),e}cleanupDOM(t){let{width:e,height:n}=t;const{el:r}=this.lower;r.classList.remove("lower-canvas"),r.removeAttribute("data-fabric"),r.setAttribute("width","".concat(e)),r.setAttribute("height","".concat(n)),r.style.cssText=this._originalCanvasStyle||"",this._originalCanvasStyle=void 0}setDimensions(t,e){const{el:n,ctx:r}=this.lower;H1(n,r,t,e)}setCSSDimensions(t){Ig(this.lower.el,t)}calcOffset(){return(function(t){var e;const n=t&&Ts(t),r={left:0,top:0};if(!n)return r;const i=((e=j1(t))===null||e===void 0?void 0:e.getComputedStyle(t,null))||{};r.left+=parseInt(i.borderLeftWidth,10)||0,r.top+=parseInt(i.borderTopWidth,10)||0,r.left+=parseInt(i.paddingLeft,10)||0,r.top+=parseInt(i.paddingTop,10)||0;let o={left:0,top:0};const a=n.documentElement;t.getBoundingClientRect!==void 0&&(o=t.getBoundingClientRect());const l=G1(t);return{left:o.left+l.left-(a.clientLeft||0)+r.left,top:o.top+l.top-(a.clientTop||0)+r.top}})(this.lower.el)}dispose(){Qs().dispose(this.lower.el),delete this.lower}}const p_={backgroundVpt:!0,backgroundColor:"",overlayVpt:!0,overlayColor:"",includeDefaultValues:!0,svgViewportTransformation:!0,renderOnAddRemove:!0,skipOffscreen:!0,enableRetinaScaling:!0,imageSmoothingEnabled:!0,controlsAboveOverlay:!1,allowTouchScrolling:!1,viewportTransform:[...yn]},f_=["objects"];class kc extends P1(L1){get lowerCanvasEl(){var t;return(t=this.elements.lower)===null||t===void 0?void 0:t.el}get contextContainer(){var t;return(t=this.elements.lower)===null||t===void 0?void 0:t.ctx}static getDefaults(){return kc.ownDefaults}constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),Object.assign(this,this.constructor.getDefaults()),this.set(e),this.initElements(t),this._setDimensionsImpl({width:this.width||this.elements.lower.el.width||0,height:this.height||this.elements.lower.el.height||0}),this.skipControlsDrawing=!1,this.viewportTransform=[...this.viewportTransform],this.calcViewportBoundaries()}initElements(t){this.elements=new X1(t)}add(){const t=super.add(...arguments);return arguments.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),t}insertAt(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const i=super.insertAt(t,...n);return n.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),i}remove(){const t=super.remove(...arguments);return t.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),t}_onObjectAdded(t){t.canvas&&t.canvas!==this&&(ri("warn",`Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`),t.canvas.remove(t)),t._set("canvas",this),t.setCoords(),this.fire("object:added",{target:t}),t.fire("added",{target:this})}_onObjectRemoved(t){t._set("canvas",void 0),this.fire("object:removed",{target:t}),t.fire("removed",{target:this})}_onStackOrderChanged(){this.renderOnAddRemove&&this.requestRenderAll()}getRetinaScaling(){return this.enableRetinaScaling?A1():1}calcOffset(){return this._offset=this.elements.calcOffset()}getWidth(){return this.width}getHeight(){return this.height}setWidth(t,e){return this.setDimensions({width:t},e)}setHeight(t,e){return this.setDimensions({height:t},e)}_setDimensionsImpl(t){let{cssOnly:e=!1,backstoreOnly:n=!1}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!e){const r=V({width:this.width,height:this.height},t);this.elements.setDimensions(r,this.getRetinaScaling()),this.hasLostContext=!0,this.width=r.width,this.height=r.height}n||this.elements.setCSSDimensions(t),this.calcOffset()}setDimensions(t,e){this._setDimensionsImpl(t,e),e&&e.cssOnly||this.requestRenderAll()}getZoom(){return this.viewportTransform[0]}setViewportTransform(t){this.viewportTransform=t,this.calcViewportBoundaries(),this.renderOnAddRemove&&this.requestRenderAll()}zoomToPoint(t,e){const n=t,r=[...this.viewportTransform],i=Nn(t,ks(r));r[0]=e,r[3]=e;const o=Nn(i,r);r[4]+=n.x-o.x,r[5]+=n.y-o.y,this.setViewportTransform(r)}setZoom(t){this.zoomToPoint(new q(0,0),t)}absolutePan(t){const e=[...this.viewportTransform];return e[4]=-t.x,e[5]=-t.y,this.setViewportTransform(e)}relativePan(t){return this.absolutePan(new q(-t.x-this.viewportTransform[4],-t.y-this.viewportTransform[5]))}getElement(){return this.elements.lower.el}clearContext(t){t.clearRect(0,0,this.width,this.height)}getContext(){return this.elements.lower.ctx}clear(){this.remove(...this.getObjects()),this.backgroundImage=void 0,this.overlayImage=void 0,this.backgroundColor="",this.overlayColor="",this.clearContext(this.getContext()),this.fire("canvas:cleared"),this.renderOnAddRemove&&this.requestRenderAll()}renderAll(){this.cancelRequestedRender(),this.destroyed||this.renderCanvas(this.getContext(),this._objects)}renderAndReset(){this.nextRenderHandle=0,this.renderAll()}requestRenderAll(){this.nextRenderHandle||this.disposed||this.destroyed||(this.nextRenderHandle=cd((()=>this.renderAndReset())))}calcViewportBoundaries(){const t=this.width,e=this.height,n=ks(this.viewportTransform),r=Nn({x:0,y:0},n),i=Nn({x:t,y:e},n),o=r.min(i),a=r.max(i);return this.vptCoords={tl:o,tr:new q(a.x,o.y),bl:new q(o.x,a.y),br:a}}cancelRequestedRender(){this.nextRenderHandle&&(l_(this.nextRenderHandle),this.nextRenderHandle=0)}drawControls(t){}renderCanvas(t,e){if(this.destroyed)return;const n=this.viewportTransform,r=this.clipPath;this.calcViewportBoundaries(),this.clearContext(t),t.imageSmoothingEnabled=this.imageSmoothingEnabled,t.patternQuality="best",this.fire("before:render",{ctx:t}),this._renderBackground(t),t.save(),t.transform(n[0],n[1],n[2],n[3],n[4],n[5]),this._renderObjects(t,e),t.restore(),this.controlsAboveOverlay||this.skipControlsDrawing||this.drawControls(t),r&&(r._set("canvas",this),r.shouldCache(),r._transformDone=!0,r.renderCache({forClipping:!0}),this.drawClipPathOnCanvas(t,r)),this._renderOverlay(t),this.controlsAboveOverlay&&!this.skipControlsDrawing&&this.drawControls(t),this.fire("after:render",{ctx:t}),this.__cleanupTask&&(this.__cleanupTask(),this.__cleanupTask=void 0)}drawClipPathOnCanvas(t,e){const n=this.viewportTransform;t.save(),t.transform(...n),t.globalCompositeOperation="destination-in",e.transform(t),t.scale(1/e.zoomX,1/e.zoomY),t.drawImage(e._cacheCanvas,-e.cacheTranslationX,-e.cacheTranslationY),t.restore()}_renderObjects(t,e){for(let n=0,r=e.length;n<r;++n)e[n]&&e[n].render(t)}_renderBackgroundOrOverlay(t,e){const n=this["".concat(e,"Color")],r=this["".concat(e,"Image")],i=this.viewportTransform,o=this["".concat(e,"Vpt")];if(!n&&!r)return;const a=as(n);if(n){if(t.save(),t.beginPath(),t.moveTo(0,0),t.lineTo(this.width,0),t.lineTo(this.width,this.height),t.lineTo(0,this.height),t.closePath(),t.fillStyle=a?n.toLive(t):n,o&&t.transform(...i),a){t.transform(1,0,0,1,n.offsetX||0,n.offsetY||0);const l=n.gradientTransform||n.patternTransform;l&&t.transform(...l)}t.fill(),t.restore()}if(r){t.save();const{skipOffscreen:l}=this;this.skipOffscreen=o,o&&t.transform(...i),r.render(t),this.skipOffscreen=l,t.restore()}}_renderBackground(t){this._renderBackgroundOrOverlay(t,"background")}_renderOverlay(t){this._renderBackgroundOrOverlay(t,"overlay")}getCenter(){return{top:this.height/2,left:this.width/2}}getCenterPoint(){return new q(this.width/2,this.height/2)}centerObjectH(t){return this._centerObject(t,new q(this.getCenterPoint().x,t.getCenterPoint().y))}centerObjectV(t){return this._centerObject(t,new q(t.getCenterPoint().x,this.getCenterPoint().y))}centerObject(t){return this._centerObject(t,this.getCenterPoint())}viewportCenterObject(t){return this._centerObject(t,this.getVpCenter())}viewportCenterObjectH(t){return this._centerObject(t,new q(this.getVpCenter().x,t.getCenterPoint().y))}viewportCenterObjectV(t){return this._centerObject(t,new q(t.getCenterPoint().x,this.getVpCenter().y))}getVpCenter(){return Nn(this.getCenterPoint(),ks(this.viewportTransform))}_centerObject(t,e){t.setXY(e,Et,Et),t.setCoords(),this.renderOnAddRemove&&this.requestRenderAll()}toDatalessJSON(t){return this.toDatalessObject(t)}toObject(t){return this._toObjectMethod("toObject",t)}toJSON(){return this.toObject()}toDatalessObject(t){return this._toObjectMethod("toDatalessObject",t)}_toObjectMethod(t,e){const n=this.clipPath,r=n&&!n.excludeFromExport?this._toObject(n,t,e):null;return V(V(V({version:Tg},ga(this,e)),{},{objects:this._objects.filter((i=>!i.excludeFromExport)).map((i=>this._toObject(i,t,e)))},this.__serializeBgOverlay(t,e)),r?{clipPath:r}:null)}_toObject(t,e,n){let r;this.includeDefaultValues||(r=t.includeDefaultValues,t.includeDefaultValues=!1);const i=t[e](n);return this.includeDefaultValues||(t.includeDefaultValues=!!r),i}__serializeBgOverlay(t,e){const n={},r=this.backgroundImage,i=this.overlayImage,o=this.backgroundColor,a=this.overlayColor;return as(o)?o.excludeFromExport||(n.background=o.toObject(e)):o&&(n.background=o),as(a)?a.excludeFromExport||(n.overlay=a.toObject(e)):a&&(n.overlay=a),r&&!r.excludeFromExport&&(n.backgroundImage=this._toObject(r,t,e)),i&&!i.excludeFromExport&&(n.overlayImage=this._toObject(i,t,e)),n}toSVG(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},e=arguments.length>1?arguments[1]:void 0;t.reviver=e;const n=[];return this._setSVGPreamble(n,t),this._setSVGHeader(n,t),this.clipPath&&n.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId,`)" >
`)),this._setSVGBgOverlayColor(n,"background"),this._setSVGBgOverlayImage(n,"backgroundImage",e),this._setSVGObjects(n,e),this.clipPath&&n.push(`</g>
`),this._setSVGBgOverlayColor(n,"overlay"),this._setSVGBgOverlayImage(n,"overlayImage",e),n.push("</svg>"),n.join("")}_setSVGPreamble(t,e){e.suppressPreamble||t.push('<?xml version="1.0" encoding="',e.encoding||"UTF-8",`" standalone="no" ?>
`,'<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',`"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`)}_setSVGHeader(t,e){const n=e.width||"".concat(this.width),r=e.height||"".concat(this.height),i=Mt.NUM_FRACTION_DIGITS,o=e.viewBox;let a;if(o)a='viewBox="'.concat(o.x," ").concat(o.y," ").concat(o.width," ").concat(o.height,'" ');else if(this.svgViewportTransformation){const l=this.viewportTransform;a='viewBox="'.concat(Qt(-l[4]/l[0],i)," ").concat(Qt(-l[5]/l[3],i)," ").concat(Qt(this.width/l[0],i)," ").concat(Qt(this.height/l[3],i),'" ')}else a='viewBox="0 0 '.concat(this.width," ").concat(this.height,'" ');t.push("<svg ",'xmlns="http://www.w3.org/2000/svg" ','xmlns:xlink="http://www.w3.org/1999/xlink" ','version="1.1" ','width="',n,'" ','height="',r,'" ',a,`xml:space="preserve">
`,"<desc>Created with Fabric.js ",Tg,`</desc>
`,`<defs>
`,this.createSVGFontFacesMarkup(),this.createSVGRefElementsMarkup(),this.createSVGClipPathMarkup(e),`</defs>
`)}createSVGClipPathMarkup(t){const e=this.clipPath;return e?(e.clipPathId="CLIPPATH_".concat(ii()),'<clipPath id="'.concat(e.clipPathId,`" >
`).concat(e.toClipPathSVG(t.reviver),`</clipPath>
`)):""}createSVGRefElementsMarkup(){return["background","overlay"].map((t=>{const e=this["".concat(t,"Color")];if(as(e)){const n=this["".concat(t,"Vpt")],r=this.viewportTransform,i={isType:()=>!1,width:this.width/(n?r[0]:1),height:this.height/(n?r[3]:1)};return e.toSVG(i,{additionalTransform:n?Ql(r):""})}})).join("")}createSVGFontFacesMarkup(){const t=[],e={},n=Mt.fontPaths;this._objects.forEach((function i(o){t.push(o),ld(o)&&o._objects.forEach(i)})),t.forEach((i=>{if(!(o=i)||typeof o._renderText!="function")return;var o;const{styles:a,fontFamily:l}=i;!e[l]&&n[l]&&(e[l]=!0,a&&Object.values(a).forEach((c=>{Object.values(c).forEach((u=>{let{fontFamily:h=""}=u;!e[h]&&n[h]&&(e[h]=!0)}))})))}));const r=Object.keys(e).map((i=>`		@font-face {
			font-family: '`.concat(i,`';
			src: url('`).concat(n[i],`');
		}
`))).join("");return r?`	<style type="text/css"><![CDATA[
`.concat(r,`]]></style>
`):""}_setSVGObjects(t,e){this.forEachObject((n=>{n.excludeFromExport||this._setSVGObject(t,n,e)}))}_setSVGObject(t,e,n){t.push(e.toSVG(n))}_setSVGBgOverlayImage(t,e,n){const r=this[e];r&&!r.excludeFromExport&&r.toSVG&&t.push(r.toSVG(n))}_setSVGBgOverlayColor(t,e){const n=this["".concat(e,"Color")];if(n)if(as(n)){const r=n.repeat||"",i=this.width,o=this.height,a=this["".concat(e,"Vpt")]?Ql(ks(this.viewportTransform)):"";t.push('<rect transform="'.concat(a," translate(").concat(i/2,",").concat(o/2,')" x="').concat(n.offsetX-i/2,'" y="').concat(n.offsetY-o/2,'" width="').concat(r!=="repeat-y"&&r!=="no-repeat"||!Hx(n)?i:n.source.width,'" height="').concat(r!=="repeat-x"&&r!=="no-repeat"||!Hx(n)?o:n.source.height,'" fill="url(#SVGID_').concat(n.id,`)"></rect>
`))}else t.push('<rect x="0" y="0" width="100%" height="100%" ','fill="',n,'"',`></rect>
`)}loadFromJSON(t,e){let{signal:n}=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(!t)return Promise.reject(new Us("`json` is undefined"));const r=typeof t=="string"?JSON.parse(t):t,{objects:i=[]}=r,o=se(r,f_),{backgroundImage:a,background:l,overlayImage:c,overlay:u,clipPath:h}=o,d=this.renderOnAddRemove;return this.renderOnAddRemove=!1,Promise.all([Jl(i,{reviver:e,signal:n}),fp({backgroundImage:a,backgroundColor:l,overlayImage:c,overlayColor:u,clipPath:h},{signal:n})]).then((p=>{let[f,m]=p;return this.clear(),this.add(...f),this.set(o),this.set(m),this.renderOnAddRemove=d,this}))}clone(t){const e=this.toObject(t);return this.cloneWithoutData().loadFromJSON(e)}cloneWithoutData(){const t=hs(this);return new this.constructor(t)}toDataURL(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const{format:e="png",quality:n=1,multiplier:r=1,enableRetinaScaling:i=!1}=t,o=r*(i?this.getRetinaScaling():1);return M1(this.toCanvasElement(o,t),e,n)}toBlob(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const{format:e="png",quality:n=1,multiplier:r=1,enableRetinaScaling:i=!1}=t,o=r*(i?this.getRetinaScaling():1);return B1(this.toCanvasElement(o,t),e,n)}toCanvasElement(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:1,{width:e,height:n,left:r,top:i,filter:o}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const a=(e||this.width)*t,l=(n||this.height)*t,c=this.getZoom(),u=this.width,h=this.height,d=this.skipControlsDrawing,p=c*t,f=this.viewportTransform,m=[p,0,0,p,(f[4]-(r||0))*t,(f[5]-(i||0))*t],g=this.enableRetinaScaling,y=hs({width:a,height:l}),b=o?this._objects.filter((w=>o(w))):this._objects;return this.enableRetinaScaling=!1,this.viewportTransform=m,this.width=a,this.height=l,this.skipControlsDrawing=!0,this.calcViewportBoundaries(),this.renderCanvas(y.getContext("2d"),b),this.viewportTransform=f,this.width=u,this.height=h,this.calcViewportBoundaries(),this.enableRetinaScaling=g,this.skipControlsDrawing=d,y}dispose(){return!this.disposed&&this.elements.cleanupDOM({width:this.width,height:this.height}),Id.cancelByCanvas(this),this.disposed=!0,new Promise(((t,e)=>{const n=()=>{this.destroy(),t(!0)};n.kill=e,this.__cleanupTask&&this.__cleanupTask.kill("aborted"),this.destroyed?t(!1):this.nextRenderHandle?this.__cleanupTask=n:n()}))}destroy(){this.destroyed=!0,this.cancelRequestedRender(),this.forEachObject((t=>t.dispose())),this._objects=[],this.backgroundImage&&this.backgroundImage.dispose(),this.backgroundImage=void 0,this.overlayImage&&this.overlayImage.dispose(),this.overlayImage=void 0,this.elements.dispose()}toString(){return"#<Canvas (".concat(this.complexity(),"): { objects: ").concat(this._objects.length," }>")}}z(kc,"ownDefaults",p_);const m_=["touchstart","touchmove","touchend"],g_=s=>{const t=G1(s.target),e=(function(n){const r=n.changedTouches;return r&&r[0]?r[0]:n})(s);return new q(e.clientX+t.left,e.clientY+t.top)},Ng=s=>m_.includes(s.type)||s.pointerType==="touch",qx=s=>{s.preventDefault(),s.stopPropagation()},vr=s=>{let t=0,e=0,n=0,r=0;for(let i=0,o=s.length;i<o;i++){const{x:a,y:l}=s[i];(a>n||!i)&&(n=a),(a<t||!i)&&(t=a),(l>r||!i)&&(r=l),(l<e||!i)&&(e=l)}return{left:t,top:e,width:n-t,height:r-e}},y_=["translateX","translateY","scaleX","scaleY"],b_=(s,t)=>$d(s,Ze(t,s.calcOwnMatrix())),$d=(s,t)=>{const e=Nd(t),{translateX:n,translateY:r,scaleX:i,scaleY:o}=e,a=se(e,y_),l=new q(n,r);s.flipX=!1,s.flipY=!1,Object.assign(s,a),s.set({scaleX:i,scaleY:o}),s.setPositionByOrigin(l,Et,Et)},x_=s=>{s.scaleX=1,s.scaleY=1,s.skewX=0,s.skewY=0,s.flipX=!1,s.flipY=!1,s.rotate(0)},q1=s=>({scaleX:s.scaleX,scaleY:s.scaleY,skewX:s.skewX,skewY:s.skewY,angle:s.angle,left:s.left,flipX:s.flipX,flipY:s.flipY,top:s.top}),Vy=(s,t,e)=>{const n=s/2,r=t/2,i=[new q(-n,-r),new q(n,-r),new q(-n,r),new q(n,r)].map((a=>a.transform(e))),o=vr(i);return new q(o.width,o.height)},mp=function(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:yn;return Ze(ks(arguments.length>1&&arguments[1]!==void 0?arguments[1]:yn),s)},Go=function(s){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:yn,e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:yn;return s.transform(mp(t,e))},w_=function(s){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:yn,e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:yn;return s.transform(mp(t,e),!0)},v_=(s,t,e)=>{const n=mp(t,e);return $d(s,Ze(n,s.calcOwnMatrix())),n},K1=(s,t)=>{var e;const{transform:{target:n}}=t;(e=n.canvas)===null||e===void 0||e.fire("object:".concat(s),V(V({},t),{},{target:n})),n.fire(s,t)},S_={left:-.5,top:-.5,center:0,bottom:.5,right:.5},ke=s=>typeof s=="string"?S_[s]:s-.5,_d="not-allowed";function Y1(s){return ke(s.originX)===ke(Et)&&ke(s.originY)===ke(Et)}function Kx(s){return .5-ke(s)}const Ns=(s,t)=>s[t],Z1=(s,t,e,n)=>({e:s,transform:t,pointer:new q(e,n)});function J1(s,t){const e=s.getTotalAngle()+Nr(Math.atan2(t.y,t.x))+360;return Math.round(e%360/45)}function Wy(s,t,e,n,r){var i;let{target:o,corner:a}=s;const l=o.controls[a],c=((i=o.canvas)===null||i===void 0?void 0:i.getZoom())||1,u=o.padding/c,h=(function(d,p,f,m){const g=d.getRelativeCenterPoint(),y=f!==void 0&&m!==void 0?d.translateToGivenOrigin(g,Et,Et,f,m):new q(d.left,d.top);return(d.angle?p.rotate(-Se(d.angle),g):p).subtract(y)})(o,new q(n,r),t,e);return h.x>=u&&(h.x-=u),h.x<=-u&&(h.x+=u),h.y>=u&&(h.y-=u),h.y<=u&&(h.y+=u),h.x-=l.offsetX,h.y-=l.offsetY,h}const C_=(s,t,e,n)=>{const{target:r,offsetX:i,offsetY:o}=t,a=e-i,l=n-o,c=!Ns(r,"lockMovementX")&&r.left!==a,u=!Ns(r,"lockMovementY")&&r.top!==l;return c&&r.set(Vt,a),u&&r.set(An,l),(c||u)&&K1(O1,Z1(s,t,e,n)),c||u},Ed=s=>s.replace(/\s+/g," "),Yx={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aqua:"#0FF",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",bisque:"#FFE4C4",black:"#000",blanchedalmond:"#FFEBCD",blue:"#00F",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#0FF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgrey:"#A9A9A9",darkgreen:"#006400",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",fuchsia:"#F0F",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",gray:"#808080",grey:"#808080",green:"#008000",greenyellow:"#ADFF2F",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgray:"#D3D3D3",lightgrey:"#D3D3D3",lightgreen:"#90EE90",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#789",lightslategrey:"#789",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",lime:"#0F0",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#F0F",maroon:"#800000",mediumaquamarine:"#66CDAA",mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",navy:"#000080",oldlace:"#FDF5E6",olive:"#808000",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",purple:"#800080",rebeccapurple:"#639",red:"#F00",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",silver:"#C0C0C0",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",teal:"#008080",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",white:"#FFF",whitesmoke:"#F5F5F5",yellow:"#FF0",yellowgreen:"#9ACD32"},Wm=(s,t,e)=>(e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+6*(t-s)*e:e<.5?t:e<2/3?s+(t-s)*(2/3-e)*6:s),Zx=(s,t,e,n)=>{s/=255,t/=255,e/=255;const r=Math.max(s,t,e),i=Math.min(s,t,e);let o,a;const l=(r+i)/2;if(r===i)o=a=0;else{const c=r-i;switch(a=l>.5?c/(2-r-i):c/(r+i),r){case s:o=(t-e)/c+(t<e?6:0);break;case t:o=(e-s)/c+2;break;case e:o=(s-t)/c+4}o/=6}return[Math.round(360*o),Math.round(100*a),Math.round(100*l),n]},Jx=function(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"1";return parseFloat(s)/(s.endsWith("%")?100:1)},ph=s=>Math.min(Math.round(s),255).toString(16).toUpperCase().padStart(2,"0"),Qx=s=>{let[t,e,n,r=1]=s;const i=Math.round(.3*t+.59*e+.11*n);return[i,i,i,r]};class Gt{constructor(t){if(z(this,"isUnrecognised",!1),t)if(t instanceof Gt)this.setSource([...t._source]);else if(Array.isArray(t)){const[e,n,r,i=1]=t;this.setSource([e,n,r,i])}else this.setSource(this._tryParsingColor(t));else this.setSource([0,0,0,1])}_tryParsingColor(t){return(t=t.toLowerCase())in Yx&&(t=Yx[t]),t==="transparent"?[255,255,255,0]:Gt.sourceFromHex(t)||Gt.sourceFromRgb(t)||Gt.sourceFromHsl(t)||(this.isUnrecognised=!0)&&[0,0,0,1]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const[t,e,n]=this.getSource();return"rgb(".concat(t,",").concat(e,",").concat(n,")")}toRgba(){return"rgba(".concat(this.getSource().join(","),")")}toHsl(){const[t,e,n]=Zx(...this.getSource());return"hsl(".concat(t,",").concat(e,"%,").concat(n,"%)")}toHsla(){const[t,e,n,r]=Zx(...this.getSource());return"hsla(".concat(t,",").concat(e,"%,").concat(n,"%,").concat(r,")")}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[t,e,n,r]=this.getSource();return"".concat(ph(t)).concat(ph(e)).concat(ph(n)).concat(ph(Math.round(255*r)))}getAlpha(){return this.getSource()[3]}setAlpha(t){return this._source[3]=t,this}toGrayscale(){return this.setSource(Qx(this.getSource())),this}toBlackWhite(t){const[e,,,n]=Qx(this.getSource()),r=e<(t||127)?0:255;return this.setSource([r,r,r,n]),this}overlayWith(t){t instanceof Gt||(t=new Gt(t));const e=this.getSource(),n=t.getSource(),[r,i,o]=e.map(((a,l)=>Math.round(.5*a+.5*n[l])));return this.setSource([r,i,o,e[3]]),this}static fromRgb(t){return Gt.fromRgba(t)}static fromRgba(t){return new Gt(Gt.sourceFromRgb(t))}static sourceFromRgb(t){const e=Ed(t).match(/^rgba?\(\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d{0,3}(?:\.\d+)?%?)\s?)?\)$/i);if(e){const[n,r,i]=e.slice(1,4).map((o=>{const a=parseFloat(o);return o.endsWith("%")?Math.round(2.55*a):a}));return[n,r,i,Jx(e[4])]}}static fromHsl(t){return Gt.fromHsla(t)}static fromHsla(t){return new Gt(Gt.sourceFromHsl(t))}static sourceFromHsl(t){const e=Ed(t).match(/^hsla?\(\s?([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d*(?:\.\d+)?%?)\s?)?\)$/i);if(!e)return;const n=(Gt.parseAngletoDegrees(e[1])%360+360)%360/360,r=parseFloat(e[2])/100,i=parseFloat(e[3])/100;let o,a,l;if(r===0)o=a=l=i;else{const c=i<=.5?i*(r+1):i+r-i*r,u=2*i-c;o=Wm(u,c,n+1/3),a=Wm(u,c,n),l=Wm(u,c,n-1/3)}return[Math.round(255*o),Math.round(255*a),Math.round(255*l),Jx(e[4])]}static fromHex(t){return new Gt(Gt.sourceFromHex(t))}static sourceFromHex(t){if(t.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)){const e=t.slice(t.indexOf("#")+1);let n;n=e.length<=4?e.split("").map((l=>l+l)):e.match(/.{2}/g);const[r,i,o,a=255]=n.map((l=>parseInt(l,16)));return[r,i,o,a/255]}}static parseAngletoDegrees(t){const e=t.toLowerCase(),n=parseFloat(e);return e.includes("rad")?Nr(n):e.includes("turn")?360*n:n}}const jo=function(s){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Ry;const e=/\D{0,2}$/.exec(s),n=parseFloat(s),r=Mt.DPI;switch(e?.[0]){case"mm":return n*r/25.4;case"cm":return n*r/2.54;case"in":return n*r;case"pt":return n*r/72;case"pc":return n*r/72*12;case"em":return n*t;default:return n}},T_=s=>{const[t,e]=s.trim().split(" "),[n,r]=(i=t)&&i!==On?[i.slice(1,4),i.slice(5,8)]:i===On?[i,i]:["Mid","Mid"];var i;return{meetOrSlice:e||"meet",alignX:n,alignY:r}},tc=function(s,t){let e,n,r=!(arguments.length>2&&arguments[2]!==void 0)||arguments[2];if(t)if(t.toLive)e="url(#SVGID_".concat(t.id,")");else{const i=new Gt(t),o=i.getAlpha();e=i.toRgb(),o!==1&&(n=o.toString())}else e="none";return r?"".concat(s,": ").concat(e,"; ").concat(n?"".concat(s,"-opacity: ").concat(n,"; "):""):"".concat(s,'="').concat(e,'" ').concat(n?"".concat(s,'-opacity="').concat(n,'" '):"")};class Q1{getSvgStyles(t){const e=this.fillRule?this.fillRule:"nonzero",n=this.strokeWidth?this.strokeWidth:"0",r=this.strokeDashArray?this.strokeDashArray.join(" "):On,i=this.strokeDashOffset?this.strokeDashOffset:"0",o=this.strokeLineCap?this.strokeLineCap:"butt",a=this.strokeLineJoin?this.strokeLineJoin:"miter",l=this.strokeMiterLimit?this.strokeMiterLimit:"4",c=this.opacity!==void 0?this.opacity:"1",u=this.visible?"":" visibility: hidden;",h=t?"":this.getSvgFilter(),d=tc(Fe,this.fill);return[tc(Rn,this.stroke),"stroke-width: ",n,"; ","stroke-dasharray: ",r,"; ","stroke-linecap: ",o,"; ","stroke-dashoffset: ",i,"; ","stroke-linejoin: ",a,"; ","stroke-miterlimit: ",l,"; ",d,"fill-rule: ",e,"; ","opacity: ",c,";",h,u].join("")}getSvgFilter(){return this.shadow?"filter: url(#SVGID_".concat(this.shadow.id,");"):""}getSvgCommons(){return[this.id?'id="'.concat(this.id,'" '):"",this.clipPath?'clip-path="url(#'.concat(this.clipPath.clipPathId,')" '):""].join("")}getSvgTransform(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"";const n=t?this.calcTransformMatrix():this.calcOwnMatrix(),r='transform="'.concat(Ql(n));return"".concat(r).concat(e,'" ')}_toSVG(t){return[""]}toSVG(t){return this._createBaseSVGMarkup(this._toSVG(t),{reviver:t})}toClipPathSVG(t){return"	"+this._createBaseClipPathSVGMarkup(this._toSVG(t),{reviver:t})}_createBaseClipPathSVGMarkup(t){let{reviver:e,additionalTransform:n=""}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r=[this.getSvgTransform(!0,n),this.getSvgCommons()].join(""),i=t.indexOf("COMMON_PARTS");return t[i]=r,e?e(t.join("")):t.join("")}_createBaseSVGMarkup(t){let{noStyle:e,reviver:n,withShadow:r,additionalTransform:i}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const o=e?"":'style="'.concat(this.getSvgStyles(),'" '),a=r?'style="'.concat(this.getSvgFilter(),'" '):"",l=this.clipPath,c=this.strokeUniform?'vector-effect="non-scaling-stroke" ':"",u=l&&l.absolutePositioned,h=this.stroke,d=this.fill,p=this.shadow,f=[],m=t.indexOf("COMMON_PARTS");let g;l&&(l.clipPathId="CLIPPATH_".concat(ii()),g='<clipPath id="'.concat(l.clipPathId,`" >
`).concat(l.toClipPathSVG(n),`</clipPath>
`)),u&&f.push("<g ",a,this.getSvgCommons(),` >
`),f.push("<g ",this.getSvgTransform(!1),u?"":a+this.getSvgCommons(),` >
`);const y=[o,c,e?"":this.addPaintOrder()," ",i?'transform="'.concat(i,'" '):""].join("");return t[m]=y,as(d)&&f.push(d.toSVG(this)),as(h)&&f.push(h.toSVG(this)),p&&f.push(p.toSVG(this)),l&&f.push(g),f.push(t.join("")),f.push(`</g>
`),u&&f.push(`</g>
`),n?n(f.join("")):f.join("")}addPaintOrder(){return this.paintFirst!==Fe?' paint-order="'.concat(this.paintFirst,'" '):""}}function gp(s){return new RegExp("^("+s.join("|")+")\\b","i")}const eo="textDecorationThickness",tS=["fontSize","fontWeight","fontFamily","fontStyle"],eS=["underline","overline","linethrough"],nS=[...tS,"lineHeight","text","charSpacing","textAlign","styles","path","pathStartOffset","pathSide","pathAlign"],sS=[...nS,...eS,"textBackgroundColor","direction",eo],k_=[...tS,...eS,Rn,"strokeWidth",Fe,"deltaY","textBackgroundColor",eo],I_={_reNewline:Fy,_reSpacesAndTabs:/[ \t\r]/g,_reSpaceAndTab:/[ \t\r]/,_reWords:/\S+/g,fontSize:40,fontWeight:"normal",fontFamily:"Times New Roman",underline:!1,overline:!1,linethrough:!1,textAlign:Vt,fontStyle:"normal",lineHeight:1.16,textBackgroundColor:"",stroke:null,shadow:null,path:void 0,pathStartOffset:0,pathSide:Vt,pathAlign:"baseline",charSpacing:0,deltaY:0,direction:"ltr",CACHE_FONT_SIZE:400,MIN_TEXT_WIDTH:2,superscript:{size:.6,baseline:-.35},subscript:{size:.6,baseline:.11},_fontSizeFraction:.222,offsets:{underline:.1,linethrough:-.28167,overline:-.81333},_fontSizeMult:1.13,[eo]:66.667},Ws="justify",Dd="justify-left",Xl="justify-right",ql="justify-center";var tw,ew,nw;const Is=String.raw(tw||(tw=or(["[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"],["[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"]))),Um=String.raw(ew||(ew=or(["(?:s*,?s+|s*,s*)"],["(?:\\s*,?\\s+|\\s*,\\s*)"]))),N_=new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*("+Is+"(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|"+Is+"))?\\s+(.*)"),$_={cx:Vt,x:Vt,r:"radius",cy:An,y:An,display:"visible",visibility:"visible",transform:"transformMatrix","fill-opacity":"fillOpacity","fill-rule":"fillRule","font-family":"fontFamily","font-size":"fontSize","font-style":"fontStyle","font-weight":"fontWeight","letter-spacing":"charSpacing","paint-order":"paintFirst","stroke-dasharray":"strokeDashArray","stroke-dashoffset":"strokeDashOffset","stroke-linecap":"strokeLineCap","stroke-linejoin":"strokeLineJoin","stroke-miterlimit":"strokeMiterLimit","stroke-opacity":"strokeOpacity","stroke-width":"strokeWidth","text-decoration":"textDecoration","text-anchor":"textAnchor",opacity:"opacity","clip-path":"clipPath","clip-rule":"clipRule","vector-effect":"strokeUniform","image-rendering":"imageSmoothing","text-decoration-thickness":eo},Gm="font-size",jm="clip-path";gp(["path","circle","polygon","polyline","ellipse","rect","line","image","text"]);gp(["symbol","image","marker","pattern","view","svg"]);const sw=gp(["symbol","g","a","svg","clipPath","defs"]);new RegExp(String.raw(nw||(nw=or(["^s*(",")","(",")","(",")","(",")s*$"],["^\\s*(",")","(",")","(",")","(",")\\s*$"])),Is,Um,Is,Um,Is,Um,Is));const __=new q(1,0),rS=new q,iS=(s,t)=>s.rotate(t),$g=(s,t)=>new q(t).subtract(s),_g=s=>s.distanceFrom(rS),Eg=(s,t)=>Math.atan2(Kl(s,t),D_(s,t)),E_=s=>Eg(__,s),Uy=s=>s.eq(rS)?s:s.scalarDivide(_g(s)),oS=function(s){let t=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];return Uy(new q(-s.y,s.x).scalarMultiply(t?1:-1))},Kl=(s,t)=>s.x*t.y-s.y*t.x,D_=(s,t)=>s.x*t.x+s.y*t.y,rw=(s,t,e)=>{if(s.eq(t)||s.eq(e))return!0;const n=Kl(t,e),r=Kl(t,s),i=Kl(e,s);return n>=0?r>=0&&i<=0:!(r<=0&&i>=0)},iw="(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?",ow=new RegExp("(?:\\s|^)"+iw+iw+"("+Is+"?(?:px)?)?(?:\\s?|$)(?:$|\\s)");class Sr{constructor(t){const e=typeof t=="string"?Sr.parseShadow(t):t;Object.assign(this,Sr.ownDefaults,e),this.id=ii()}static parseShadow(t){const e=t.trim(),[,n=0,r=0,i=0]=(ow.exec(e)||[]).map((o=>parseFloat(o)||0));return{color:(e.replace(ow,"")||"rgb(0,0,0)").trim(),offsetX:n,offsetY:r,blur:i}}toString(){return[this.offsetX,this.offsetY,this.blur,this.color].join("px ")}toSVG(t){const e=iS(new q(this.offsetX,this.offsetY),Se(-t.angle)),n=new Gt(this.color);let r=40,i=40;return t.width&&t.height&&(r=100*Qt((Math.abs(e.x)+this.blur)/t.width,Mt.NUM_FRACTION_DIGITS)+20,i=100*Qt((Math.abs(e.y)+this.blur)/t.height,Mt.NUM_FRACTION_DIGITS)+20),t.flipX&&(e.x*=-1),t.flipY&&(e.y*=-1),'<filter id="SVGID_'.concat(this.id,'" y="-').concat(i,'%" height="').concat(100+2*i,'%" x="-').concat(r,'%" width="').concat(100+2*r,`%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(Qt(this.blur?this.blur/2:0,Mt.NUM_FRACTION_DIGITS),`"></feGaussianBlur>
	<feOffset dx="`).concat(Qt(e.x,Mt.NUM_FRACTION_DIGITS),'" dy="').concat(Qt(e.y,Mt.NUM_FRACTION_DIGITS),`" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(n.toRgb(),'" flood-opacity="').concat(n.getAlpha(),`"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`)}toObject(){const t={color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke,nonScaling:this.nonScaling,type:this.constructor.type},e=Sr.ownDefaults;return this.includeDefaultValues?t:zy(t,((n,r)=>n!==e[r]))}static async fromObject(t){return new this(t)}}z(Sr,"ownDefaults",{color:"rgb(0,0,0)",blur:0,offsetX:0,offsetY:0,affectStroke:!1,includeDefaultValues:!0,nonScaling:!1}),z(Sr,"type","shadow"),ut.setClass(Sr,"shadow");const Jo=(s,t,e)=>Math.max(s,Math.min(t,e)),A_=[An,Vt,Fn,us,"flipX","flipY","originX","originY","angle","opacity","globalCompositeOperation","shadow","visible",pa,fa],Rr=[Fe,Rn,"strokeWidth","strokeDashArray","width","height","paintFirst","strokeUniform","strokeLineCap","strokeDashOffset","strokeLineJoin","strokeMiterLimit","backgroundColor","clipPath"],O_={top:0,left:0,width:0,height:0,angle:0,flipX:!1,flipY:!1,scaleX:1,scaleY:1,minScaleLimit:0,skewX:0,skewY:0,originX:Vt,originY:An,strokeWidth:1,strokeUniform:!1,padding:0,opacity:1,paintFirst:Fe,fill:"rgb(0,0,0)",fillRule:"nonzero",stroke:null,strokeDashArray:null,strokeDashOffset:0,strokeLineCap:"butt",strokeLineJoin:"miter",strokeMiterLimit:4,globalCompositeOperation:"source-over",backgroundColor:"",shadow:null,visible:!0,includeDefaultValues:!0,excludeFromExport:!1,objectCaching:!0,clipPath:void 0,inverted:!1,absolutePositioned:!1,centeredRotation:!0,centeredScaling:!1,dirty:!0},R_=(s,t,e,n)=>-e*Math.cos(s/n*Cc)+e+t,F_=()=>!1;class Gy{constructor(t){let{startValue:e,byValue:n,duration:r=500,delay:i=0,easing:o=R_,onStart:a=ad,onChange:l=ad,onComplete:c=ad,abort:u=F_,target:h}=t;z(this,"_state","pending"),z(this,"durationProgress",0),z(this,"valueProgress",0),this.tick=this.tick.bind(this),this.duration=r,this.delay=i,this.easing=o,this._onStart=a,this._onChange=l,this._onComplete=c,this._abort=u,this.target=h,this.startValue=e,this.byValue=n,this.value=this.startValue,this.endValue=Object.freeze(this.calculate(this.duration).value)}get state(){return this._state}isDone(){return this._state==="aborted"||this._state==="completed"}start(){const t=e=>{this._state==="pending"&&(this.startTime=e||+new Date,this._state="running",this._onStart(),this.tick(this.startTime))};this.register(),this.delay>0?setTimeout((()=>cd(t)),this.delay):cd(t)}tick(t){const e=(t||+new Date)-this.startTime,n=Math.min(e,this.duration);this.durationProgress=n/this.duration;const{value:r,valueProgress:i}=this.calculate(n);this.value=Object.freeze(r),this.valueProgress=i,this._state!=="aborted"&&(this._abort(this.value,this.valueProgress,this.durationProgress)?(this._state="aborted",this.unregister()):e>=this.duration?(this.durationProgress=this.valueProgress=1,this._onChange(this.endValue,this.valueProgress,this.durationProgress),this._state="completed",this._onComplete(this.endValue,this.valueProgress,this.durationProgress),this.unregister()):(this._onChange(this.value,this.valueProgress,this.durationProgress),cd(this.tick)))}register(){Id.push(this)}unregister(){Id.remove(this)}abort(){this._state="aborted",this.unregister()}}const P_=["startValue","endValue"];class L_ extends Gy{constructor(t){let{startValue:e=0,endValue:n=100}=t;super(V(V({},se(t,P_)),{},{startValue:e,byValue:n-e}))}calculate(t){const e=this.easing(t,this.startValue,this.byValue,this.duration);return{value:e,valueProgress:Math.abs((e-this.startValue)/this.byValue)}}}const M_=["startValue","endValue"];class B_ extends Gy{constructor(t){let{startValue:e=[0],endValue:n=[100]}=t;super(V(V({},se(t,M_)),{},{startValue:e,byValue:n.map(((r,i)=>r-e[i]))}))}calculate(t){const e=this.startValue.map(((n,r)=>this.easing(t,n,this.byValue[r],this.duration,r)));return{value:e,valueProgress:Math.abs((e[0]-this.startValue[0])/this.byValue[0])}}}const z_=["startValue","endValue","easing","onChange","onComplete","abort"],V_=(s,t,e,n)=>t+e*(1-Math.cos(s/n*Cc)),Hm=s=>s&&((t,e,n)=>s(new Gt(t).toRgba(),e,n));class W_ extends Gy{constructor(t){let{startValue:e,endValue:n,easing:r=V_,onChange:i,onComplete:o,abort:a}=t,l=se(t,z_);const c=new Gt(e).getSource(),u=new Gt(n).getSource();super(V(V({},l),{},{startValue:c,byValue:u.map(((h,d)=>h-c[d])),easing:r,onChange:Hm(i),onComplete:Hm(o),abort:Hm(a)}))}calculate(t){const[e,n,r,i]=this.startValue.map(((a,l)=>this.easing(t,a,this.byValue[l],this.duration,l))),o=[...[e,n,r].map(Math.round),Jo(0,i,1)];return{value:o,valueProgress:o.map(((a,l)=>this.byValue[l]!==0?Math.abs((a-this.startValue[l])/this.byValue[l]):0)).find((a=>a!==0))||0}}}function aS(s){const t=(e=>Array.isArray(e.startValue)||Array.isArray(e.endValue))(s)?new B_(s):new L_(s);return t.start(),t}function U_(s){const t=new W_(s);return t.start(),t}class he{constructor(t){this.status=t,this.points=[]}includes(t){return this.points.some((e=>e.eq(t)))}append(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.points=this.points.concat(e.filter((r=>!this.includes(r)))),this}static isPointContained(t,e,n){let r=arguments.length>3&&arguments[3]!==void 0&&arguments[3];if(e.eq(n))return t.eq(e);if(e.x===n.x)return t.x===e.x&&(r||t.y>=Math.min(e.y,n.y)&&t.y<=Math.max(e.y,n.y));if(e.y===n.y)return t.y===e.y&&(r||t.x>=Math.min(e.x,n.x)&&t.x<=Math.max(e.x,n.x));{const i=$g(e,n),o=$g(e,t).divide(i);return r?Math.abs(o.x)===Math.abs(o.y):o.x===o.y&&o.x>=0&&o.x<=1}}static isPointInPolygon(t,e){const n=new q(t).setX(Math.min(t.x-1,...e.map((i=>i.x))));let r=0;for(let i=0;i<e.length;i++){const o=this.intersectSegmentSegment(e[i],e[(i+1)%e.length],t,n);if(o.includes(t))return!0;r+=+(o.status==="Intersection")}return r%2==1}static intersectLineLine(t,e,n,r){let i=!(arguments.length>4&&arguments[4]!==void 0)||arguments[4],o=!(arguments.length>5&&arguments[5]!==void 0)||arguments[5];const a=e.x-t.x,l=e.y-t.y,c=r.x-n.x,u=r.y-n.y,h=t.x-n.x,d=t.y-n.y,p=c*d-u*h,f=a*d-l*h,m=u*a-c*l;if(m!==0){const g=p/m,y=f/m;return(i||0<=g&&g<=1)&&(o||0<=y&&y<=1)?new he("Intersection").append(new q(t.x+g*a,t.y+g*l)):new he}if(p===0||f===0){const g=i||o||he.isPointContained(t,n,r)||he.isPointContained(e,n,r)||he.isPointContained(n,t,e)||he.isPointContained(r,t,e);return new he(g?"Coincident":void 0)}return new he("Parallel")}static intersectSegmentLine(t,e,n,r){return he.intersectLineLine(t,e,n,r,!1,!0)}static intersectSegmentSegment(t,e,n,r){return he.intersectLineLine(t,e,n,r,!1,!1)}static intersectLinePolygon(t,e,n){let r=!(arguments.length>3&&arguments[3]!==void 0)||arguments[3];const i=new he,o=n.length;for(let a,l,c,u=0;u<o;u++){if(a=n[u],l=n[(u+1)%o],c=he.intersectLineLine(t,e,a,l,r,!1),c.status==="Coincident")return c;i.append(...c.points)}return i.points.length>0&&(i.status="Intersection"),i}static intersectSegmentPolygon(t,e,n){return he.intersectLinePolygon(t,e,n,!1)}static intersectPolygonPolygon(t,e){const n=new he,r=t.length,i=[];for(let o=0;o<r;o++){const a=t[o],l=t[(o+1)%r],c=he.intersectSegmentPolygon(a,l,e);c.status==="Coincident"?(i.push(c),n.append(a,l)):n.append(...c.points)}return i.length>0&&i.length===t.length?new he("Coincident"):(n.points.length>0&&(n.status="Intersection"),n)}static intersectPolygonRectangle(t,e,n){const r=e.min(n),i=e.max(n),o=new q(i.x,r.y),a=new q(r.x,i.y);return he.intersectPolygonPolygon(t,[r,o,i,a])}}class G_ extends L1{getX(){return this.getXY().x}setX(t){this.setXY(this.getXY().setX(t))}getY(){return this.getXY().y}setY(t){this.setXY(this.getXY().setY(t))}getRelativeX(){return this.left}setRelativeX(t){this.left=t}getRelativeY(){return this.top}setRelativeY(t){this.top=t}getXY(){const t=this.getRelativeXY();return this.group?Nn(t,this.group.calcTransformMatrix()):t}setXY(t,e,n){this.group&&(t=Nn(t,ks(this.group.calcTransformMatrix()))),this.setRelativeXY(t,e,n)}getRelativeXY(){return new q(this.left,this.top)}setRelativeXY(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.originX,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:this.originY;this.setPositionByOrigin(t,e,n)}isStrokeAccountedForInDimensions(){return!1}getCoords(){const{tl:t,tr:e,br:n,bl:r}=this.aCoords||(this.aCoords=this.calcACoords()),i=[t,e,n,r];if(this.group){const o=this.group.calcTransformMatrix();return i.map((a=>Nn(a,o)))}return i}intersectsWithRect(t,e){return he.intersectPolygonRectangle(this.getCoords(),t,e).status==="Intersection"}intersectsWithObject(t){const e=he.intersectPolygonPolygon(this.getCoords(),t.getCoords());return e.status==="Intersection"||e.status==="Coincident"||t.isContainedWithinObject(this)||this.isContainedWithinObject(t)}isContainedWithinObject(t){return this.getCoords().every((e=>t.containsPoint(e)))}isContainedWithinRect(t,e){const{left:n,top:r,width:i,height:o}=this.getBoundingRect();return n>=t.x&&n+i<=e.x&&r>=t.y&&r+o<=e.y}isOverlapping(t){return this.intersectsWithObject(t)||this.isContainedWithinObject(t)||t.isContainedWithinObject(this)}containsPoint(t){return he.isPointInPolygon(t,this.getCoords())}isOnScreen(){if(!this.canvas)return!1;const{tl:t,br:e}=this.canvas.vptCoords;return!!this.getCoords().some((n=>n.x<=e.x&&n.x>=t.x&&n.y<=e.y&&n.y>=t.y))||!!this.intersectsWithRect(t,e)||this.containsPoint(t.midPointFrom(e))}isPartiallyOnScreen(){if(!this.canvas)return!1;const{tl:t,br:e}=this.canvas.vptCoords;return this.intersectsWithRect(t,e)?!0:this.getCoords().every((n=>(n.x>=e.x||n.x<=t.x)&&(n.y>=e.y||n.y<=t.y)))&&this.containsPoint(t.midPointFrom(e))}getBoundingRect(){return vr(this.getCoords())}getScaledWidth(){return this._getTransformedDimensions().x}getScaledHeight(){return this._getTransformedDimensions().y}scale(t){this._set(Fn,t),this._set(us,t),this.setCoords()}scaleToWidth(t){const e=this.getBoundingRect().width/this.getScaledWidth();return this.scale(t/this.width/e)}scaleToHeight(t){const e=this.getBoundingRect().height/this.getScaledHeight();return this.scale(t/this.height/e)}getCanvasRetinaScaling(){var t;return((t=this.canvas)===null||t===void 0?void 0:t.getRetinaScaling())||1}getTotalAngle(){return this.group?Nr(z1(this.calcTransformMatrix())):this.angle}getViewportTransform(){var t;return((t=this.canvas)===null||t===void 0?void 0:t.viewportTransform)||yn.concat()}calcACoords(){const t=ma({angle:this.angle}),{x:e,y:n}=this.getRelativeCenterPoint(),r=Tc(e,n),i=Ze(r,t),o=this._getTransformedDimensions(),a=o.x/2,l=o.y/2;return{tl:Nn({x:-a,y:-l},i),tr:Nn({x:a,y:-l},i),bl:Nn({x:-a,y:l},i),br:Nn({x:a,y:l},i)}}setCoords(){this.aCoords=this.calcACoords()}transformMatrixKey(){let t=arguments.length>0&&arguments[0]!==void 0&&arguments[0],e=[];return!t&&this.group&&(e=this.group.transformMatrixKey(t)),e.push(this.top,this.left,this.width,this.height,this.scaleX,this.scaleY,this.angle,this.strokeWidth,this.skewX,this.skewY,+this.flipX,+this.flipY,ke(this.originX),ke(this.originY)),e}calcTransformMatrix(){let t=arguments.length>0&&arguments[0]!==void 0&&arguments[0],e=this.calcOwnMatrix();if(t||!this.group)return e;const n=this.transformMatrixKey(t),r=this.matrixCache;return r&&r.key.every(((i,o)=>i===n[o]))?r.value:(this.group&&(e=Ze(this.group.calcTransformMatrix(!1),e)),this.matrixCache={key:n,value:e},e)}calcOwnMatrix(){const t=this.transformMatrixKey(!0),e=this.ownMatrixCache;if(e&&e.key===t)return e.value;const n=this.getRelativeCenterPoint(),r={angle:this.angle,translateX:n.x,translateY:n.y,scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY},i=d_(r);return this.ownMatrixCache={key:t,value:i},i}_getNonTransformedDimensions(){return new q(this.width,this.height).scalarAdd(this.strokeWidth)}_calculateCurrentDimensions(t){return this._getTransformedDimensions(t).transform(this.getViewportTransform(),!0).scalarAdd(2*this.padding)}_getTransformedDimensions(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const e=V({scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,width:this.width,height:this.height,strokeWidth:this.strokeWidth},t),n=e.strokeWidth;let r=n,i=0;this.strokeUniform&&(r=0,i=n);const o=e.width+r,a=e.height+r;let l;return l=e.skewX===0&&e.skewY===0?new q(o*e.scaleX,a*e.scaleY):Vy(o,a,pp(e)),l.scalarAdd(i)}translateToGivenOrigin(t,e,n,r,i){let o=t.x,a=t.y;const l=ke(r)-ke(e),c=ke(i)-ke(n);if(l||c){const u=this._getTransformedDimensions();o+=l*u.x,a+=c*u.y}return new q(o,a)}translateToCenterPoint(t,e,n){if(e===Et&&n===Et)return t;const r=this.translateToGivenOrigin(t,e,n,Et,Et);return this.angle?r.rotate(Se(this.angle),t):r}translateToOriginPoint(t,e,n){const r=this.translateToGivenOrigin(t,Et,Et,e,n);return this.angle?r.rotate(Se(this.angle),t):r}getCenterPoint(){const t=this.getRelativeCenterPoint();return this.group?Nn(t,this.group.calcTransformMatrix()):t}getRelativeCenterPoint(){return this.translateToCenterPoint(new q(this.left,this.top),this.originX,this.originY)}getPointByOrigin(t,e){return this.translateToOriginPoint(this.getRelativeCenterPoint(),t,e)}setPositionByOrigin(t,e,n){const r=this.translateToCenterPoint(t,e,n),i=this.translateToOriginPoint(r,this.originX,this.originY);this.set({left:i.x,top:i.y})}_getLeftTopCoords(){return this.translateToOriginPoint(this.getRelativeCenterPoint(),Vt,An)}}const j_=["type"],H_=["extraParam"];let hr=class hd extends G_{static getDefaults(){return hd.ownDefaults}get type(){const t=this.constructor.type;return t==="FabricObject"?"object":t.toLowerCase()}set type(t){ri("warn","Setting type has no effect",t)}constructor(t){super(),z(this,"_cacheContext",null),Object.assign(this,hd.ownDefaults),this.setOptions(t)}_createCacheCanvas(){this._cacheCanvas=Ir(),this._cacheContext=this._cacheCanvas.getContext("2d"),this._updateCacheCanvas(),this.dirty=!0}_limitCacheSize(t){const e=t.width,n=t.height,r=Mt.maxCacheSideLimit,i=Mt.minCacheSideLimit;if(e<=r&&n<=r&&e*n<=Mt.perfLimitSizeTotal)return e<i&&(t.width=i),n<i&&(t.height=i),t;const o=e/n,[a,l]=Hl.limitDimsByArea(o),c=Jo(i,a,r),u=Jo(i,l,r);return e>c&&(t.zoomX/=e/c,t.width=c,t.capped=!0),n>u&&(t.zoomY/=n/u,t.height=u,t.capped=!0),t}_getCacheCanvasDimensions(){const t=this.getTotalObjectScaling(),e=this._getTransformedDimensions({skewX:0,skewY:0}),n=e.x*t.x/this.scaleX,r=e.y*t.y/this.scaleY;return{width:Math.ceil(n+2),height:Math.ceil(r+2),zoomX:t.x,zoomY:t.y,x:n,y:r}}_updateCacheCanvas(){const t=this._cacheCanvas,e=this._cacheContext,{width:n,height:r,zoomX:i,zoomY:o,x:a,y:l}=this._limitCacheSize(this._getCacheCanvasDimensions()),c=n!==t.width||r!==t.height,u=this.zoomX!==i||this.zoomY!==o;if(!t||!e)return!1;if(c||u){n!==t.width||r!==t.height?(t.width=n,t.height=r):(e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,t.width,t.height));const h=a/2,d=l/2;return this.cacheTranslationX=Math.round(t.width/2-h)+h,this.cacheTranslationY=Math.round(t.height/2-d)+d,e.translate(this.cacheTranslationX,this.cacheTranslationY),e.scale(i,o),this.zoomX=i,this.zoomY=o,!0}return!1}setOptions(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this._setOptions(t)}transform(t){const e=this.group&&!this.group._transformDone||this.group&&this.canvas&&t===this.canvas.contextTop,n=this.calcTransformMatrix(!e);t.transform(n[0],n[1],n[2],n[3],n[4],n[5])}getObjectScaling(){if(!this.group)return new q(Math.abs(this.scaleX),Math.abs(this.scaleY));const t=Nd(this.calcTransformMatrix());return new q(Math.abs(t.scaleX),Math.abs(t.scaleY))}getTotalObjectScaling(){const t=this.getObjectScaling();if(this.canvas){const e=this.canvas.getZoom(),n=this.getCanvasRetinaScaling();return t.scalarMultiply(e*n)}return t}getObjectOpacity(){let t=this.opacity;return this.group&&(t*=this.group.getObjectOpacity()),t}_constrainScale(t){return Math.abs(t)<this.minScaleLimit?t<0?-this.minScaleLimit:this.minScaleLimit:t===0?1e-4:t}_set(t,e){t!==Fn&&t!==us||(e=this._constrainScale(e)),t===Fn&&e<0?(this.flipX=!this.flipX,e*=-1):t==="scaleY"&&e<0?(this.flipY=!this.flipY,e*=-1):t!=="shadow"||!e||e instanceof Sr||(e=new Sr(e));const n=this[t]!==e;return this[t]=e,n&&this.constructor.cacheProperties.includes(t)&&(this.dirty=!0),this.parent&&(this.dirty||n&&this.constructor.stateProperties.includes(t))&&this.parent._set("dirty",!0),this}isNotVisible(){return this.opacity===0||!this.width&&!this.height&&this.strokeWidth===0||!this.visible}render(t){this.isNotVisible()||this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(t.save(),this._setupCompositeOperation(t),this.drawSelectionBackground(t),this.transform(t),this._setOpacity(t),this._setShadow(t),this.shouldCache()?(this.renderCache(),this.drawCacheOnCanvas(t)):(this._removeCacheCanvas(),this.drawObject(t,!1,{}),this.dirty=!1),t.restore())}drawSelectionBackground(t){}renderCache(t){if(t=t||{},this._cacheCanvas&&this._cacheContext||this._createCacheCanvas(),this.isCacheDirty()&&this._cacheContext){const{zoomX:e,zoomY:n,cacheTranslationX:r,cacheTranslationY:i}=this,{width:o,height:a}=this._cacheCanvas;this.drawObject(this._cacheContext,t.forClipping,{zoomX:e,zoomY:n,cacheTranslationX:r,cacheTranslationY:i,width:o,height:a,parentClipPaths:[]}),this.dirty=!1}}_removeCacheCanvas(){this._cacheCanvas=void 0,this._cacheContext=null}hasStroke(){return this.stroke&&this.stroke!=="transparent"&&this.strokeWidth!==0}hasFill(){return this.fill&&this.fill!=="transparent"}needsItsOwnCache(){return!!(this.paintFirst===Rn&&this.hasFill()&&this.hasStroke()&&this.shadow)||!!this.clipPath}shouldCache(){return this.ownCaching=this.objectCaching&&(!this.parent||!this.parent.isOnACache())||this.needsItsOwnCache(),this.ownCaching}willDrawShadow(){return!!this.shadow&&(this.shadow.offsetX!==0||this.shadow.offsetY!==0)}drawClipPathOnCache(t,e,n){t.save(),e.inverted?t.globalCompositeOperation="destination-out":t.globalCompositeOperation="destination-in",t.setTransform(1,0,0,1,0,0),t.drawImage(n,0,0),t.restore()}drawObject(t,e,n){const r=this.fill,i=this.stroke;e?(this.fill="black",this.stroke="",this._setClippingProperties(t)):this._renderBackground(t),this._render(t),this._drawClipPath(t,this.clipPath,n),this.fill=r,this.stroke=i}createClipPathLayer(t,e){const n=hs(e),r=n.getContext("2d");if(r.translate(e.cacheTranslationX,e.cacheTranslationY),r.scale(e.zoomX,e.zoomY),t._cacheCanvas=n,e.parentClipPaths.forEach((i=>{i.transform(r)})),e.parentClipPaths.push(t),t.absolutePositioned){const i=ks(this.calcTransformMatrix());r.transform(i[0],i[1],i[2],i[3],i[4],i[5])}return t.transform(r),t.drawObject(r,!0,e),n}_drawClipPath(t,e,n){if(!e)return;e._transformDone=!0;const r=this.createClipPathLayer(e,n);this.drawClipPathOnCache(t,e,r)}drawCacheOnCanvas(t){t.scale(1/this.zoomX,1/this.zoomY),t.drawImage(this._cacheCanvas,-this.cacheTranslationX,-this.cacheTranslationY)}isCacheDirty(){let t=arguments.length>0&&arguments[0]!==void 0&&arguments[0];if(this.isNotVisible())return!1;const e=this._cacheCanvas,n=this._cacheContext;return!(!e||!n||t||!this._updateCacheCanvas())||!!(this.dirty||this.clipPath&&this.clipPath.absolutePositioned)&&(e&&n&&!t&&(n.save(),n.setTransform(1,0,0,1,0,0),n.clearRect(0,0,e.width,e.height),n.restore()),!0)}_renderBackground(t){if(!this.backgroundColor)return;const e=this._getNonTransformedDimensions();t.fillStyle=this.backgroundColor,t.fillRect(-e.x/2,-e.y/2,e.x,e.y),this._removeShadow(t)}_setOpacity(t){this.group&&!this.group._transformDone?t.globalAlpha=this.getObjectOpacity():t.globalAlpha*=this.opacity}_setStrokeStyles(t,e){const n=e.stroke;n&&(t.lineWidth=e.strokeWidth,t.lineCap=e.strokeLineCap,t.lineDashOffset=e.strokeDashOffset,t.lineJoin=e.strokeLineJoin,t.miterLimit=e.strokeMiterLimit,as(n)?n.gradientUnits==="percentage"||n.gradientTransform||n.patternTransform?this._applyPatternForTransformedGradient(t,n):(t.strokeStyle=n.toLive(t),this._applyPatternGradientTransform(t,n)):t.strokeStyle=e.stroke)}_setFillStyles(t,e){let{fill:n}=e;n&&(as(n)?(t.fillStyle=n.toLive(t),this._applyPatternGradientTransform(t,n)):t.fillStyle=n)}_setClippingProperties(t){t.globalAlpha=1,t.strokeStyle="transparent",t.fillStyle="#000000"}_setLineDash(t,e){e&&e.length!==0&&t.setLineDash(e)}_setShadow(t){if(!this.shadow)return;const e=this.shadow,n=this.canvas,r=this.getCanvasRetinaScaling(),[i,,,o]=n?.viewportTransform||yn,a=i*r,l=o*r,c=e.nonScaling?new q(1,1):this.getObjectScaling();t.shadowColor=e.color,t.shadowBlur=e.blur*Mt.browserShadowBlurConstant*(a+l)*(c.x+c.y)/4,t.shadowOffsetX=e.offsetX*a*c.x,t.shadowOffsetY=e.offsetY*l*c.y}_removeShadow(t){this.shadow&&(t.shadowColor="",t.shadowBlur=t.shadowOffsetX=t.shadowOffsetY=0)}_applyPatternGradientTransform(t,e){if(!as(e))return{offsetX:0,offsetY:0};const n=e.gradientTransform||e.patternTransform,r=-this.width/2+e.offsetX||0,i=-this.height/2+e.offsetY||0;return e.gradientUnits==="percentage"?t.transform(this.width,0,0,this.height,r,i):t.transform(1,0,0,1,r,i),n&&t.transform(n[0],n[1],n[2],n[3],n[4],n[5]),{offsetX:r,offsetY:i}}_renderPaintInOrder(t){this.paintFirst===Rn?(this._renderStroke(t),this._renderFill(t)):(this._renderFill(t),this._renderStroke(t))}_render(t){}_renderFill(t){this.fill&&(t.save(),this._setFillStyles(t,this),this.fillRule==="evenodd"?t.fill("evenodd"):t.fill(),t.restore())}_renderStroke(t){if(this.stroke&&this.strokeWidth!==0){if(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this.strokeUniform){const e=this.getObjectScaling();t.scale(1/e.x,1/e.y)}this._setLineDash(t,this.strokeDashArray),this._setStrokeStyles(t,this),t.stroke(),t.restore()}}_applyPatternForTransformedGradient(t,e){var n;const r=this._limitCacheSize(this._getCacheCanvasDimensions()),i=this.getCanvasRetinaScaling(),o=r.x/this.scaleX/i,a=r.y/this.scaleY/i,l=hs({width:Math.ceil(o),height:Math.ceil(a)}),c=l.getContext("2d");c&&(c.beginPath(),c.moveTo(0,0),c.lineTo(o,0),c.lineTo(o,a),c.lineTo(0,a),c.closePath(),c.translate(o/2,a/2),c.scale(r.zoomX/this.scaleX/i,r.zoomY/this.scaleY/i),this._applyPatternGradientTransform(c,e),c.fillStyle=e.toLive(t),c.fill(),t.translate(-this.width/2-this.strokeWidth/2,-this.height/2-this.strokeWidth/2),t.scale(i*this.scaleX/r.zoomX,i*this.scaleY/r.zoomY),t.strokeStyle=(n=c.createPattern(l,"no-repeat"))!==null&&n!==void 0?n:"")}_findCenterFromElement(){return new q(this.left+this.width/2,this.top+this.height/2)}clone(t){const e=this.toObject(t);return this.constructor.fromObject(e)}cloneAsImage(t){const e=this.toCanvasElement(t);return new(ut.getClass("image"))(e)}toCanvasElement(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const e=q1(this),n=this.group,r=this.shadow,i=Math.abs,o=t.enableRetinaScaling?A1():1,a=(t.multiplier||1)*o,l=t.canvasProvider||(b=>new kc(b,{enableRetinaScaling:!1,renderOnAddRemove:!1,skipOffscreen:!1}));delete this.group,t.withoutTransform&&x_(this),t.withoutShadow&&(this.shadow=null),t.viewportTransform&&v_(this,this.getViewportTransform()),this.setCoords();const c=Ir(),u=this.getBoundingRect(),h=this.shadow,d=new q;if(h){const b=h.blur,w=h.nonScaling?new q(1,1):this.getObjectScaling();d.x=2*Math.round(i(h.offsetX)+b)*i(w.x),d.y=2*Math.round(i(h.offsetY)+b)*i(w.y)}const p=u.width+d.x,f=u.height+d.y;c.width=Math.ceil(p),c.height=Math.ceil(f);const m=l(c);t.format==="jpeg"&&(m.backgroundColor="#fff"),this.setPositionByOrigin(new q(m.width/2,m.height/2),Et,Et);const g=this.canvas;m._objects=[this],this.set("canvas",m),this.setCoords();const y=m.toCanvasElement(a||1,t);return this.set("canvas",g),this.shadow=r,n&&(this.group=n),this.set(e),this.setCoords(),m._objects=[],m.destroy(),y}toDataURL(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return M1(this.toCanvasElement(t),t.format||"png",t.quality||1)}toBlob(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return B1(this.toCanvasElement(t),t.format||"png",t.quality||1)}isType(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return e.includes(this.constructor.type)||e.includes(this.type)}complexity(){return 1}toJSON(){return this.toObject()}rotate(t){const{centeredRotation:e,originX:n,originY:r}=this;if(e){const{x:i,y:o}=this.getRelativeCenterPoint();this.originX=Et,this.originY=Et,this.left=i,this.top=o}if(this.set("angle",t),e){const{x:i,y:o}=this.translateToOriginPoint(this.getRelativeCenterPoint(),n,r);this.left=i,this.top=o,this.originX=n,this.originY=r}}setOnGroup(){}_setupCompositeOperation(t){this.globalCompositeOperation&&(t.globalCompositeOperation=this.globalCompositeOperation)}dispose(){Id.cancelByTarget(this),this.off(),this._set("canvas",void 0),this._cacheCanvas&&Qs().dispose(this._cacheCanvas),this._cacheCanvas=void 0,this._cacheContext=null}animate(t,e){return Object.entries(t).reduce(((n,r)=>{let[i,o]=r;return n[i]=this._animate(i,o,e),n}),{})}_animate(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const r=t.split("."),i=this.constructor.colorProperties.includes(r[r.length-1]),{abort:o,startValue:a,onChange:l,onComplete:c}=n,u=V(V({},n),{},{target:this,startValue:a??r.reduce(((h,d)=>h[d]),this),endValue:e,abort:o?.bind(this),onChange:(h,d,p)=>{r.reduce(((f,m,g)=>(g===r.length-1&&(f[m]=h),f[m])),this),l&&l(h,d,p)},onComplete:(h,d,p)=>{this.setCoords(),c&&c(h,d,p)}});return i?U_(u):aS(u)}isDescendantOf(t){const{parent:e,group:n}=this;return e===t||n===t||!!e&&e.isDescendantOf(t)||!!n&&n!==e&&n.isDescendantOf(t)}getAncestors(){const t=[];let e=this;do e=e.parent,e&&t.push(e);while(e);return t}findCommonAncestors(t){if(this===t)return{fork:[],otherFork:[],common:[this,...this.getAncestors()]};const e=this.getAncestors(),n=t.getAncestors();if(e.length===0&&n.length>0&&this===n[n.length-1])return{fork:[],otherFork:[t,...n.slice(0,n.length-1)],common:[this]};for(let r,i=0;i<e.length;i++){if(r=e[i],r===t)return{fork:[this,...e.slice(0,i)],otherFork:[],common:e.slice(i)};for(let o=0;o<n.length;o++){if(this===n[o])return{fork:[],otherFork:[t,...n.slice(0,o)],common:[this,...e]};if(r===n[o])return{fork:[this,...e.slice(0,i)],otherFork:[t,...n.slice(0,o)],common:e.slice(i)}}}return{fork:[this,...e],otherFork:[t,...n],common:[]}}hasCommonAncestors(t){const e=this.findCommonAncestors(t);return e&&!!e.common.length}isInFrontOf(t){if(this===t)return;const e=this.findCommonAncestors(t);if(e.fork.includes(t))return!0;if(e.otherFork.includes(this))return!1;const n=e.common[0]||this.canvas;if(!n)return;const r=e.fork.pop(),i=e.otherFork.pop(),o=n._objects.indexOf(r),a=n._objects.indexOf(i);return o>-1&&o>a}toObject(){const t=(arguments.length>0&&arguments[0]!==void 0?arguments[0]:[]).concat(hd.customProperties,this.constructor.customProperties||[]);let e;const n=Mt.NUM_FRACTION_DIGITS,{clipPath:r,fill:i,stroke:o,shadow:a,strokeDashArray:l,left:c,top:u,originX:h,originY:d,width:p,height:f,strokeWidth:m,strokeLineCap:g,strokeDashOffset:y,strokeLineJoin:b,strokeUniform:w,strokeMiterLimit:x,scaleX:v,scaleY:C,angle:k,flipX:I,flipY:N,opacity:_,visible:T,backgroundColor:D,fillRule:R,paintFirst:P,globalCompositeOperation:B,skewX:U,skewY:H}=this;r&&!r.excludeFromExport&&(e=r.toObject(t.concat("inverted","absolutePositioned")));const G=Z=>Qt(Z,n),X=V(V({},ga(this,t)),{},{type:this.constructor.type,version:Tg,originX:h,originY:d,left:G(c),top:G(u),width:G(p),height:G(f),fill:jx(i)?i.toObject():i,stroke:jx(o)?o.toObject():o,strokeWidth:G(m),strokeDashArray:l&&l.concat(),strokeLineCap:g,strokeDashOffset:y,strokeLineJoin:b,strokeUniform:w,strokeMiterLimit:G(x),scaleX:G(v),scaleY:G(C),angle:G(k),flipX:I,flipY:N,opacity:G(_),shadow:a&&a.toObject(),visible:T,backgroundColor:D,fillRule:R,paintFirst:P,globalCompositeOperation:B,skewX:G(U),skewY:G(H)},e?{clipPath:e}:null);return this.includeDefaultValues?X:this._removeDefaultValues(X)}toDatalessObject(t){return this.toObject(t)}_removeDefaultValues(t){const e=this.constructor.getDefaults(),n=Object.keys(e).length>0?e:Object.getPrototypeOf(this);return zy(t,((r,i)=>{if(i===Vt||i===An||i==="type")return!0;const o=n[i];return r!==o&&!(Array.isArray(r)&&Array.isArray(o)&&r.length===0&&o.length===0)}))}toString(){return"#<".concat(this.constructor.type,">")}static _fromObject(t){let e=se(t,j_),n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},{extraParam:r}=n,i=se(n,H_);return fp(e,i).then((o=>r?(delete o[r],new this(e[r],o)):new this(o)))}static fromObject(t,e){return this._fromObject(t,e)}};z(hr,"stateProperties",A_),z(hr,"cacheProperties",Rr),z(hr,"ownDefaults",O_),z(hr,"type","FabricObject"),z(hr,"colorProperties",[Fe,Rn,"backgroundColor"]),z(hr,"customProperties",[]),ut.setClass(hr),ut.setClass(hr,"object");const ya=(s,t,e)=>(n,r,i,o)=>{const a=t(n,r,i,o);return a&&K1(s,V(V({},Z1(n,r,i,o)),e)),a};function ba(s){return(t,e,n,r)=>{const{target:i,originX:o,originY:a}=e,l=i.getRelativeCenterPoint(),c=i.translateToOriginPoint(l,o,a),u=s(t,e,n,r);return i.setPositionByOrigin(c,e.originX,e.originY),u}}const aw=ya(Zl,ba(((s,t,e,n)=>{const r=Wy(t,t.originX,t.originY,e,n);if(ke(t.originX)===ke(Et)||ke(t.originX)===ke(xe)&&r.x<0||ke(t.originX)===ke(Vt)&&r.x>0){const{target:i}=t,o=i.strokeWidth/(i.strokeUniform?i.scaleX:1),a=Y1(t)?2:1,l=i.width,c=Math.abs(r.x*a/i.scaleX)-o;return i.set("width",Math.max(c,1)),l!==i.width}return!1})));function X_(s,t,e,n,r){n=n||{};const i=this.sizeX||n.cornerSize||r.cornerSize,o=this.sizeY||n.cornerSize||r.cornerSize,a=n.transparentCorners!==void 0?n.transparentCorners:r.transparentCorners,l=a?Rn:Fe,c=!a&&(n.cornerStrokeColor||r.cornerStrokeColor);let u,h=t,d=e;s.save(),s.fillStyle=n.cornerColor||r.cornerColor||"",s.strokeStyle=n.cornerStrokeColor||r.cornerStrokeColor||"",i>o?(u=i,s.scale(1,o/i),d=e*i/o):o>i?(u=o,s.scale(i/o,1),h=t*o/i):u=i,s.beginPath(),s.arc(h,d,u/2,0,Cd,!1),s[l](),c&&s.stroke(),s.restore()}function q_(s,t,e,n,r){n=n||{};const i=this.sizeX||n.cornerSize||r.cornerSize,o=this.sizeY||n.cornerSize||r.cornerSize,a=n.transparentCorners!==void 0?n.transparentCorners:r.transparentCorners,l=a?Rn:Fe,c=!a&&(n.cornerStrokeColor||r.cornerStrokeColor),u=i/2,h=o/2;s.save(),s.fillStyle=n.cornerColor||r.cornerColor||"",s.strokeStyle=n.cornerStrokeColor||r.cornerStrokeColor||"",s.translate(t,e);const d=r.getTotalAngle();s.rotate(Se(d)),s["".concat(l,"Rect")](-u,-h,i,o),c&&s.strokeRect(-u,-h,i,o),s.restore()}class bs{constructor(t){z(this,"visible",!0),z(this,"actionName",dp),z(this,"angle",0),z(this,"x",0),z(this,"y",0),z(this,"offsetX",0),z(this,"offsetY",0),z(this,"sizeX",0),z(this,"sizeY",0),z(this,"touchSizeX",0),z(this,"touchSizeY",0),z(this,"cursorStyle","crosshair"),z(this,"withConnection",!1),Object.assign(this,t)}shouldActivate(t,e,n,r){var i;let{tl:o,tr:a,br:l,bl:c}=r;return((i=e.canvas)===null||i===void 0?void 0:i.getActiveObject())===e&&e.isControlVisible(t)&&he.isPointInPolygon(n,[o,a,l,c])}getActionHandler(t,e,n){return this.actionHandler}getMouseDownHandler(t,e,n){return this.mouseDownHandler}getMouseUpHandler(t,e,n){return this.mouseUpHandler}cursorStyleHandler(t,e,n){return e.cursorStyle}getActionName(t,e,n){return e.actionName}getVisibility(t,e){var n,r;return(n=(r=t._controlsVisibility)===null||r===void 0?void 0:r[e])!==null&&n!==void 0?n:this.visible}setVisibility(t,e,n){this.visible=t}positionHandler(t,e,n,r){return new q(this.x*t.x+this.offsetX,this.y*t.y+this.offsetY).transform(e)}calcCornerCoords(t,e,n,r,i,o){const a=My([Tc(n,r),ma({angle:t}),By((i?this.touchSizeX:this.sizeX)||e,(i?this.touchSizeY:this.sizeY)||e)]);return{tl:new q(-.5,-.5).transform(a),tr:new q(.5,-.5).transform(a),br:new q(.5,.5).transform(a),bl:new q(-.5,.5).transform(a)}}render(t,e,n,r,i){((r=r||{}).cornerStyle||i.cornerStyle)==="circle"?X_.call(this,t,e,n,r,i):q_.call(this,t,e,n,r,i)}}const K_=(s,t,e)=>e.lockRotation?_d:t.cursorStyle,Y_=ya(R1,ba(((s,t,e,n)=>{let{target:r,ex:i,ey:o,theta:a,originX:l,originY:c}=t;const u=r.translateToOriginPoint(r.getRelativeCenterPoint(),l,c);if(Ns(r,"lockRotation"))return!1;const h=Math.atan2(o-u.y,i-u.x),d=Math.atan2(n-u.y,e-u.x);let p=Nr(d-h+a);if(r.snapAngle&&r.snapAngle>0){const m=r.snapAngle,g=r.snapThreshold||m,y=Math.ceil(p/m)*m,b=Math.floor(p/m)*m;Math.abs(p-b)<g?p=b:Math.abs(p-y)<g&&(p=y)}p<0&&(p=360+p),p%=360;const f=r.angle!==p;return r.angle=p,f})));function lS(s,t){const e=t.canvas,n=s[e.uniScaleKey];return e.uniformScaling&&!n||!e.uniformScaling&&n}function cS(s,t,e){const n=Ns(s,"lockScalingX"),r=Ns(s,"lockScalingY");if(n&&r||!t&&(n||r)&&e||n&&t==="x"||r&&t==="y")return!0;const{width:i,height:o,strokeWidth:a}=s;return i===0&&a===0&&t!=="y"||o===0&&a===0&&t!=="x"}const Z_=["e","se","s","sw","w","nw","n","ne","e"],Ll=(s,t,e)=>{const n=lS(s,e);if(cS(e,t.x!==0&&t.y===0?"x":t.x===0&&t.y!==0?"y":"",n))return _d;const r=J1(e,t);return"".concat(Z_[r],"-resize")};function jy(s,t,e,n){let r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};const i=t.target,o=r.by,a=lS(s,i);let l,c,u,h,d,p;if(cS(i,o,a))return!1;if(t.gestureScale)c=t.scaleX*t.gestureScale,u=t.scaleY*t.gestureScale;else{if(l=Wy(t,t.originX,t.originY,e,n),d=o!=="y"?Math.sign(l.x||t.signX||1):1,p=o!=="x"?Math.sign(l.y||t.signY||1):1,t.signX||(t.signX=d),t.signY||(t.signY=p),Ns(i,"lockScalingFlip")&&(t.signX!==d||t.signY!==p))return!1;if(h=i._getTransformedDimensions(),a&&!o){const g=Math.abs(l.x)+Math.abs(l.y),{original:y}=t,b=g/(Math.abs(h.x*y.scaleX/i.scaleX)+Math.abs(h.y*y.scaleY/i.scaleY));c=y.scaleX*b,u=y.scaleY*b}else c=Math.abs(l.x*i.scaleX/h.x),u=Math.abs(l.y*i.scaleY/h.y);Y1(t)&&(c*=2,u*=2),t.signX!==d&&o!=="y"&&(t.originX=Kx(t.originX),c*=-1,t.signX=d),t.signY!==p&&o!=="x"&&(t.originY=Kx(t.originY),u*=-1,t.signY=p)}const f=i.scaleX,m=i.scaleY;return o?(o==="x"&&i.set(Fn,c),o==="y"&&i.set(us,u)):(!Ns(i,"lockScalingX")&&i.set(Fn,c),!Ns(i,"lockScalingY")&&i.set(us,u)),f!==i.scaleX||m!==i.scaleY}const fh=ya(hp,ba(((s,t,e,n)=>jy(s,t,e,n)))),J_=ya(hp,ba(((s,t,e,n)=>jy(s,t,e,n,{by:"x"})))),Q_=ya(hp,ba(((s,t,e,n)=>jy(s,t,e,n,{by:"y"})))),tE=["target","ex","ey","skewingSide"],Xm={x:{counterAxis:"y",scale:Fn,skew:pa,lockSkewing:"lockSkewingX",origin:"originX",flip:"flipX"},y:{counterAxis:"x",scale:us,skew:fa,lockSkewing:"lockSkewingY",origin:"originY",flip:"flipY"}},eE=["ns","nesw","ew","nwse"],nE=(s,t,e)=>{if(t.x!==0&&Ns(e,"lockSkewingY")||t.y!==0&&Ns(e,"lockSkewingX"))return _d;const n=J1(e,t)%4;return"".concat(eE[n],"-resize")};function uS(s,t,e,n,r){const{target:i}=e,{counterAxis:o,origin:a,lockSkewing:l,skew:c,flip:u}=Xm[s];if(Ns(i,l))return!1;const{origin:h,flip:d}=Xm[o],p=ke(e[h])*(i[d]?-1:1),f=-Math.sign(p)*(i[u]?-1:1),m=.5*-((i[c]===0&&Wy(e,Et,Et,n,r)[s]>0||i[c]>0?1:-1)*f)+.5;return ya(F1,ba(((y,b,w,x)=>(function(v,C,k){let{target:I,ex:N,ey:_,skewingSide:T}=C,D=se(C,tE);const{skew:R}=Xm[v],P=k.subtract(new q(N,_)).divide(new q(I.scaleX,I.scaleY))[v],B=I[R],U=D[R],H=Math.tan(Se(U)),G=v==="y"?I._getTransformedDimensions({scaleX:1,scaleY:1,skewX:0}).x:I._getTransformedDimensions({scaleX:1,scaleY:1}).y,X=2*P*T/Math.max(G,1)+H,Z=Nr(Math.atan(X));I.set(R,Z);const J=B!==I[R];if(J&&v==="y"){const{skewX:et,scaleX:Q}=I,st=I._getTransformedDimensions({skewY:B}),it=I._getTransformedDimensions(),at=et!==0?st.x/it.x:1;at!==1&&I.set(Fn,at*Q)}return J})(s,b,new q(w,x)))))(t,V(V({},e),{},{[a]:m,skewingSide:f}),n,r)}const sE=(s,t,e,n)=>uS("x",s,t,e,n),rE=(s,t,e,n)=>uS("y",s,t,e,n);function yp(s,t){return s[t.canvas.altActionKey]}const mh=(s,t,e)=>{const n=yp(s,e);return t.x===0?n?pa:us:t.y===0?n?fa:Fn:""},Vo=(s,t,e)=>yp(s,e)?nE(0,t,e):Ll(s,t,e),lw=(s,t,e,n)=>yp(s,t.target)?rE(s,t,e,n):J_(s,t,e,n),cw=(s,t,e,n)=>yp(s,t.target)?sE(s,t,e,n):Q_(s,t,e,n),hS=()=>({ml:new bs({x:-.5,y:0,cursorStyleHandler:Vo,actionHandler:lw,getActionName:mh}),mr:new bs({x:.5,y:0,cursorStyleHandler:Vo,actionHandler:lw,getActionName:mh}),mb:new bs({x:0,y:.5,cursorStyleHandler:Vo,actionHandler:cw,getActionName:mh}),mt:new bs({x:0,y:-.5,cursorStyleHandler:Vo,actionHandler:cw,getActionName:mh}),tl:new bs({x:-.5,y:-.5,cursorStyleHandler:Ll,actionHandler:fh}),tr:new bs({x:.5,y:-.5,cursorStyleHandler:Ll,actionHandler:fh}),bl:new bs({x:-.5,y:.5,cursorStyleHandler:Ll,actionHandler:fh}),br:new bs({x:.5,y:.5,cursorStyleHandler:Ll,actionHandler:fh}),mtr:new bs({x:0,y:-.5,actionHandler:Y_,cursorStyleHandler:K_,offsetY:-40,withConnection:!0,actionName:Py})}),iE=()=>({mr:new bs({x:.5,y:0,actionHandler:aw,cursorStyleHandler:Vo,actionName:Zl}),ml:new bs({x:-.5,y:0,actionHandler:aw,cursorStyleHandler:Vo,actionName:Zl})}),oE=()=>V(V({},hS()),iE());class ec extends hr{static getDefaults(){return V(V({},super.getDefaults()),ec.ownDefaults)}constructor(t){super(),Object.assign(this,this.constructor.createControls(),ec.ownDefaults),this.setOptions(t)}static createControls(){return{controls:hS()}}_updateCacheCanvas(){const t=this.canvas;if(this.noScaleCache&&t&&t._currentTransform){const e=t._currentTransform,n=e.target,r=e.action;if(this===n&&r&&r.startsWith(dp))return!1}return super._updateCacheCanvas()}getActiveControl(){const t=this.__corner;return t?{key:t,control:this.controls[t],coord:this.oCoords[t]}:void 0}findControl(t){let e=arguments.length>1&&arguments[1]!==void 0&&arguments[1];if(!this.hasControls||!this.canvas)return;this.__corner=void 0;const n=Object.entries(this.oCoords);for(let r=n.length-1;r>=0;r--){const[i,o]=n[r],a=this.controls[i];if(a.shouldActivate(i,this,t,e?o.touchCorner:o.corner))return this.__corner=i,{key:i,control:a,coord:this.oCoords[i]}}}calcOCoords(){const t=this.getViewportTransform(),e=this.getCenterPoint(),n=Tc(e.x,e.y),r=ma({angle:this.getTotalAngle()-(this.group&&this.flipX?180:0)}),i=Ze(n,r),o=Ze(t,i),a=Ze(o,[1/t[0],0,0,1/t[3],0,0]),l=this.group?Nd(this.calcTransformMatrix()):void 0;l&&(l.scaleX=Math.abs(l.scaleX),l.scaleY=Math.abs(l.scaleY));const c=this._calculateCurrentDimensions(l),u={};return this.forEachControl(((h,d)=>{const p=h.positionHandler(c,a,this,h);u[d]=Object.assign(p,this._calcCornerCoords(h,p))})),u}_calcCornerCoords(t,e){const n=this.getTotalAngle();return{corner:t.calcCornerCoords(n,this.cornerSize,e.x,e.y,!1,this),touchCorner:t.calcCornerCoords(n,this.touchCornerSize,e.x,e.y,!0,this)}}setCoords(){super.setCoords(),this.canvas&&(this.oCoords=this.calcOCoords())}forEachControl(t){for(const e in this.controls)t(this.controls[e],e,this)}drawSelectionBackground(t){if(!this.selectionBackgroundColor||this.canvas&&this.canvas._activeObject!==this)return;t.save();const e=this.getRelativeCenterPoint(),n=this._calculateCurrentDimensions(),r=this.getViewportTransform();t.translate(e.x,e.y),t.scale(1/r[0],1/r[3]),t.rotate(Se(this.angle)),t.fillStyle=this.selectionBackgroundColor,t.fillRect(-n.x/2,-n.y/2,n.x,n.y),t.restore()}strokeBorders(t,e){t.strokeRect(-e.x/2,-e.y/2,e.x,e.y)}_drawBorders(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const r=V({hasControls:this.hasControls,borderColor:this.borderColor,borderDashArray:this.borderDashArray},n);t.save(),t.strokeStyle=r.borderColor,this._setLineDash(t,r.borderDashArray),this.strokeBorders(t,e),r.hasControls&&this.drawControlsConnectingLines(t,e),t.restore()}_renderControls(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const{hasBorders:n,hasControls:r}=this,i=V({hasBorders:n,hasControls:r},e),o=this.getViewportTransform(),a=i.hasBorders,l=i.hasControls,c=Ze(o,this.calcTransformMatrix()),u=Nd(c);t.save(),t.translate(u.translateX,u.translateY),t.lineWidth=this.borderScaleFactor,this.group===this.parent&&(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.flipX&&(u.angle-=180),t.rotate(Se(this.group?u.angle:this.angle)),a&&this.drawBorders(t,u,e),l&&this.drawControls(t,e),t.restore()}drawBorders(t,e,n){let r;if(n&&n.forActiveSelection||this.group){const i=Vy(this.width,this.height,pp(e)),o=this.isStrokeAccountedForInDimensions()?Ly:(this.strokeUniform?new q().scalarAdd(this.canvas?this.canvas.getZoom():1):new q(e.scaleX,e.scaleY)).scalarMultiply(this.strokeWidth);r=i.add(o).scalarAdd(this.borderScaleFactor).scalarAdd(2*this.padding)}else r=this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);this._drawBorders(t,r,n)}drawControlsConnectingLines(t,e){let n=!1;t.beginPath(),this.forEachControl(((r,i)=>{r.withConnection&&r.getVisibility(this,i)&&(n=!0,t.moveTo(r.x*e.x,r.y*e.y),t.lineTo(r.x*e.x+r.offsetX,r.y*e.y+r.offsetY))})),n&&t.stroke()}drawControls(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};t.save();const n=this.getCanvasRetinaScaling(),{cornerStrokeColor:r,cornerDashArray:i,cornerColor:o}=this,a=V({cornerStrokeColor:r,cornerDashArray:i,cornerColor:o},e);t.setTransform(n,0,0,n,0,0),t.strokeStyle=t.fillStyle=a.cornerColor,this.transparentCorners||(t.strokeStyle=a.cornerStrokeColor),this._setLineDash(t,a.cornerDashArray),this.forEachControl(((l,c)=>{if(l.getVisibility(this,c)){const u=this.oCoords[c];l.render(t,u.x,u.y,a,this)}})),t.restore()}isControlVisible(t){return this.controls[t]&&this.controls[t].getVisibility(this,t)}setControlVisible(t,e){this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[t]=e}setControlsVisibility(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};Object.entries(t).forEach((e=>{let[n,r]=e;return this.setControlVisible(n,r)}))}clearContextTop(t){if(!this.canvas)return;const e=this.canvas.contextTop;if(!e)return;const n=this.canvas.viewportTransform;e.save(),e.transform(n[0],n[1],n[2],n[3],n[4],n[5]),this.transform(e);const r=this.width+4,i=this.height+4;return e.clearRect(-r/2,-i/2,r,i),t||e.restore(),e}onDeselect(t){return!1}onSelect(t){return!1}shouldStartDragging(t){return!1}onDragStart(t){return!1}canDrop(t){return!1}renderDragSourceEffect(t){}renderDropTargetEffect(t){}}function dS(s,t){return t.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((n=>{n!=="constructor"&&Object.defineProperty(s.prototype,n,Object.getOwnPropertyDescriptor(e.prototype,n)||Object.create(null))}))})),s}z(ec,"ownDefaults",{noScaleCache:!0,lockMovementX:!1,lockMovementY:!1,lockRotation:!1,lockScalingX:!1,lockScalingY:!1,lockSkewingX:!1,lockSkewingY:!1,lockScalingFlip:!1,cornerSize:13,touchCornerSize:24,transparentCorners:!0,cornerColor:"rgb(178,204,255)",cornerStrokeColor:"",cornerStyle:"rect",cornerDashArray:null,hasControls:!0,borderColor:"rgb(178,204,255)",borderDashArray:null,borderOpacityWhenMoving:.4,borderScaleFactor:1,hasBorders:!0,selectionBackgroundColor:"",selectable:!0,evented:!0,perPixelTargetFind:!1,activeOn:"down",hoverCursor:null,moveCursor:null});class an extends ec{}dS(an,[Q1]),ut.setClass(an),ut.setClass(an,"object");const aE=(s,t,e,n)=>{const r=2*(n=Math.round(n))+1,{data:i}=s.getImageData(t-n,e-n,r,r);for(let o=3;o<i.length;o+=4)if(i[o]>0)return!1;return!0};class pS{constructor(t){this.options=t,this.strokeProjectionMagnitude=this.options.strokeWidth/2,this.scale=new q(this.options.scaleX,this.options.scaleY),this.strokeUniformScalar=this.options.strokeUniform?new q(1/this.options.scaleX,1/this.options.scaleY):new q(1,1)}createSideVector(t,e){const n=$g(t,e);return this.options.strokeUniform?n.multiply(this.scale):n}projectOrthogonally(t,e,n){return this.applySkew(t.add(this.calcOrthogonalProjection(t,e,n)))}isSkewed(){return this.options.skewX!==0||this.options.skewY!==0}applySkew(t){const e=new q(t);return e.y+=e.x*Math.tan(Se(this.options.skewY)),e.x+=e.y*Math.tan(Se(this.options.skewX)),e}scaleUnitVector(t,e){return t.multiply(this.strokeUniformScalar).scalarMultiply(e)}}const lE=new q;class Ho extends pS{static getOrthogonalRotationFactor(t,e){const n=e?Eg(t,e):E_(t);return Math.abs(n)<Cc?-1:1}constructor(t,e,n,r){super(r),z(this,"AB",void 0),z(this,"AC",void 0),z(this,"alpha",void 0),z(this,"bisector",void 0),this.A=new q(t),this.B=new q(e),this.C=new q(n),this.AB=this.createSideVector(this.A,this.B),this.AC=this.createSideVector(this.A,this.C),this.alpha=Eg(this.AB,this.AC),this.bisector=Uy(iS(this.AB.eq(lE)?this.AC:this.AB,this.alpha/2))}calcOrthogonalProjection(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:this.strokeProjectionMagnitude;const r=this.createSideVector(t,e),i=oS(r),o=Ho.getOrthogonalRotationFactor(i,this.bisector);return this.scaleUnitVector(i,n*o)}projectBevel(){const t=[];return(this.alpha%Cd==0?[this.B]:[this.B,this.C]).forEach((e=>{t.push(this.projectOrthogonally(this.A,e)),t.push(this.projectOrthogonally(this.A,e,-this.strokeProjectionMagnitude))})),t}projectMiter(){const t=[],e=Math.abs(this.alpha),n=1/Math.sin(e/2),r=this.scaleUnitVector(this.bisector,-this.strokeProjectionMagnitude*n),i=this.options.strokeUniform?_g(this.scaleUnitVector(this.bisector,this.options.strokeMiterLimit)):this.options.strokeMiterLimit;return _g(r)/this.strokeProjectionMagnitude<=i&&t.push(this.applySkew(this.A.add(r))),t.push(...this.projectBevel()),t}projectRoundNoSkew(t,e){const n=[],r=new q(Ho.getOrthogonalRotationFactor(this.bisector),Ho.getOrthogonalRotationFactor(new q(this.bisector.y,this.bisector.x)));return[new q(1,0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r),new q(0,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r)].forEach((i=>{rw(i,t,e)&&n.push(this.A.add(i))})),n}projectRoundWithSkew(t,e){const n=[],{skewX:r,skewY:i,scaleX:o,scaleY:a,strokeUniform:l}=this.options,c=new q(Math.tan(Se(r)),Math.tan(Se(i))),u=this.strokeProjectionMagnitude,h=l?u/a/Math.sqrt(1/a**2+1/o**2*c.y**2):u/Math.sqrt(1+c.y**2),d=new q(Math.sqrt(Math.max(u**2-h**2,0)),h),p=l?u/Math.sqrt(1+c.x**2*(1/a)**2/(1/o+1/o*c.x*c.y)**2):u/Math.sqrt(1+c.x**2/(1+c.x*c.y)**2),f=new q(p,Math.sqrt(Math.max(u**2-p**2,0)));return[f,f.scalarMultiply(-1),d,d.scalarMultiply(-1)].map((m=>this.applySkew(l?m.multiply(this.strokeUniformScalar):m))).forEach((m=>{rw(m,t,e)&&n.push(this.applySkew(this.A).add(m))})),n}projectRound(){const t=[];t.push(...this.projectBevel());const e=this.alpha%Cd==0,n=this.applySkew(this.A),r=t[e?0:2].subtract(n),i=t[e?1:0].subtract(n),o=e?this.applySkew(this.AB.scalarMultiply(-1)):this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)),a=Kl(r,o)>0,l=a?r:i,c=a?i:r;return this.isSkewed()?t.push(...this.projectRoundWithSkew(l,c)):t.push(...this.projectRoundNoSkew(l,c)),t}projectPoints(){switch(this.options.strokeLineJoin){case"miter":return this.projectMiter();case"round":return this.projectRound();default:return this.projectBevel()}}project(){return this.projectPoints().map((t=>({originPoint:this.A,projectedPoint:t,angle:this.alpha,bisector:this.bisector})))}}class uw extends pS{constructor(t,e,n){super(n),this.A=new q(t),this.T=new q(e)}calcOrthogonalProjection(t,e){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:this.strokeProjectionMagnitude;const r=this.createSideVector(t,e);return this.scaleUnitVector(oS(r),n)}projectButt(){return[this.projectOrthogonally(this.A,this.T,this.strokeProjectionMagnitude),this.projectOrthogonally(this.A,this.T,-this.strokeProjectionMagnitude)]}projectRound(){const t=[];if(!this.isSkewed()&&this.A.eq(this.T)){const e=new q(1,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);t.push(this.applySkew(this.A.add(e)),this.applySkew(this.A.subtract(e)))}else t.push(...new Ho(this.A,this.T,this.T,this.options).projectRound());return t}projectSquare(){const t=[];if(this.A.eq(this.T)){const e=new q(1,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);t.push(this.A.add(e),this.A.subtract(e))}else{const e=this.calcOrthogonalProjection(this.A,this.T,this.strokeProjectionMagnitude),n=this.scaleUnitVector(Uy(this.createSideVector(this.A,this.T)),-this.strokeProjectionMagnitude),r=this.A.add(n);t.push(r.add(e),r.subtract(e))}return t.map((e=>this.applySkew(e)))}projectPoints(){switch(this.options.strokeLineCap){case"round":return this.projectRound();case"square":return this.projectSquare();default:return this.projectButt()}}project(){return this.projectPoints().map((t=>({originPoint:this.A,projectedPoint:t})))}}const cE=function(s,t){let e=arguments.length>2&&arguments[2]!==void 0&&arguments[2];const n=[];if(s.length===0)return n;const r=s.reduce(((i,o)=>(i[i.length-1].eq(o)||i.push(new q(o)),i)),[new q(s[0])]);if(r.length===1)e=!0;else if(!e){const i=r[0],o=((a,l)=>{for(let c=a.length-1;c>=0;c--)if(l(a[c],c,a))return c;return-1})(r,(a=>!a.eq(i)));r.splice(o+1)}return r.forEach(((i,o,a)=>{let l,c;o===0?(c=a[1],l=e?i:a[a.length-1]):o===a.length-1?(l=a[o-1],c=e?i:a[0]):(l=a[o-1],c=a[o+1]),e&&a.length===1?n.push(...new uw(i,i,t).project()):!e||o!==0&&o!==a.length-1?n.push(...new Ho(i,l,c,t).project()):n.push(...new uw(i,o===0?c:l,t).project())})),n},Hy=s=>{const t={};return Object.keys(s).forEach((e=>{t[e]={},Object.keys(s[e]).forEach((n=>{t[e][n]=V({},s[e][n])}))})),t},uE=s=>s.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&apos;").replace(/</g,"&lt;").replace(/>/g,"&gt;");let Dl;const Xy=s=>{if(Dl||Dl||(Dl="Intl"in up()&&"Segmenter"in Intl&&new Intl.Segmenter(void 0,{granularity:"grapheme"})),Dl){const t=Dl.segment(s);return Array.from(t).map((e=>{let{segment:n}=e;return n}))}return hE(s)},hE=s=>{const t=[];for(let e,n=0;n<s.length;n++)(e=dE(s,n))!==!1&&t.push(e);return t},dE=(s,t)=>{const e=s.charCodeAt(t);if(isNaN(e))return"";if(e<55296||e>57343)return s.charAt(t);if(55296<=e&&e<=56319){if(s.length<=t+1)throw"High surrogate without following low surrogate";const r=s.charCodeAt(t+1);if(56320>r||r>57343)throw"High surrogate without following low surrogate";return s.charAt(t)+s.charAt(t+1)}if(t===0)throw"Low surrogate without preceding high surrogate";const n=s.charCodeAt(t-1);if(55296>n||n>56319)throw"Low surrogate without preceding high surrogate";return!1},qy=function(s,t){let e=arguments.length>2&&arguments[2]!==void 0&&arguments[2];return s.fill!==t.fill||s.stroke!==t.stroke||s.strokeWidth!==t.strokeWidth||s.fontSize!==t.fontSize||s.fontFamily!==t.fontFamily||s.fontWeight!==t.fontWeight||s.fontStyle!==t.fontStyle||s.textDecorationThickness!==t.textDecorationThickness||s.textBackgroundColor!==t.textBackgroundColor||s.deltaY!==t.deltaY||e&&(s.overline!==t.overline||s.underline!==t.underline||s.linethrough!==t.linethrough)},pE=(s,t)=>{const e=t.split(`
`),n=[];let r=-1,i={};s=Hy(s);for(let o=0;o<e.length;o++){const a=Xy(e[o]);if(s[o])for(let l=0;l<a.length;l++){r++;const c=s[o][l];c&&Object.keys(c).length>0&&(qy(i,c,!0)?n.push({start:r,end:r+1,style:c}):n[n.length-1].end++),i=c||{}}else r+=a.length,i={}}return n},fE=(s,t)=>{if(!Array.isArray(s))return Hy(s);const e=t.split(Fy),n={};let r=-1,i=0;for(let o=0;o<e.length;o++){const a=Xy(e[o]);for(let l=0;l<a.length;l++)r++,s[i]&&s[i].start<=r&&r<s[i].end&&(n[o]=n[o]||{},n[o][l]=V({},s[i].style),r===s[i].end-1&&i++)}return n},xi=["display","transform",Fe,"fill-opacity","fill-rule","opacity",Rn,"stroke-dasharray","stroke-linecap","stroke-dashoffset","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","id","paint-order","vector-effect","instantiated_by_use","clip-path"];function hw(s,t){const e=s.nodeName,n=s.getAttribute("class"),r=s.getAttribute("id"),i="(?![a-zA-Z\\-]+)";let o;if(o=new RegExp("^"+e,"i"),t=t.replace(o,""),r&&t.length&&(o=new RegExp("#"+r+i,"i"),t=t.replace(o,"")),n&&t.length){const a=n.split(" ");for(let l=a.length;l--;)o=new RegExp("\\."+a[l]+i,"i"),t=t.replace(o,"")}return t.length===0}function mE(s,t){let e=!0;const n=hw(s,t.pop());return n&&t.length&&(e=(function(r,i){let o,a=!0;for(;r.parentElement&&r.parentElement.nodeType===1&&i.length;)a&&(o=i.pop()),a=hw(r=r.parentElement,o);return i.length===0})(s,t)),n&&e&&t.length===0}const gE=s=>{var t;return(t=$_[s])!==null&&t!==void 0?t:s},yE=new RegExp("(".concat(Is,")"),"gi"),bE=s=>Ed(s.replace(yE," $1 ").replace(/,/gi," "));var dw,pw,fw,mw,gw,yw,bw;const pn="(".concat(Is,")"),xE=String.raw(dw||(dw=or(["(skewX)(",")"],["(skewX)\\(","\\)"])),pn),wE=String.raw(pw||(pw=or(["(skewY)(",")"],["(skewY)\\(","\\)"])),pn),vE=String.raw(fw||(fw=or(["(rotate)(","(?: "," ",")?)"],["(rotate)\\(","(?: "," ",")?\\)"])),pn,pn,pn),SE=String.raw(mw||(mw=or(["(scale)(","(?: ",")?)"],["(scale)\\(","(?: ",")?\\)"])),pn,pn),CE=String.raw(gw||(gw=or(["(translate)(","(?: ",")?)"],["(translate)\\(","(?: ",")?\\)"])),pn,pn),TE=String.raw(yw||(yw=or(["(matrix)("," "," "," "," "," ",")"],["(matrix)\\("," "," "," "," "," ","\\)"])),pn,pn,pn,pn,pn,pn),Ky="(?:".concat(TE,"|").concat(CE,"|").concat(vE,"|").concat(SE,"|").concat(xE,"|").concat(wE,")"),kE="(?:".concat(Ky,"*)"),IE=String.raw(bw||(bw=or(["^s*(?:","?)s*$"],["^\\s*(?:","?)\\s*$"])),kE),NE=new RegExp(IE),$E=new RegExp(Ky),_E=new RegExp(Ky,"g");function Dg(s){const t=[];if(!(s=bE(s).replace(/\s*([()])\s*/gi,"$1"))||s&&!NE.test(s))return[...yn];for(const e of s.matchAll(_E)){const n=$E.exec(e[0]);if(!n)continue;let r=yn;const i=n.filter((f=>!!f)),[,o,...a]=i,[l,c,u,h,d,p]=a.map((f=>parseFloat(f)));switch(o){case"translate":r=Tc(l,c);break;case Py:r=ma({angle:l},{x:c,y:u});break;case dp:r=By(l,c);break;case pa:r=W1(l);break;case fa:r=U1(l);break;case"matrix":r=[l,c,u,h,d,p]}t.push(r)}return My(t)}function EE(s,t,e,n){const r=Array.isArray(t);let i,o=t;if(s!==Fe&&s!==Rn||t!==On){if(s==="strokeUniform")return t==="non-scaling-stroke";if(s==="strokeDashArray")o=t===On?null:t.replace(/,/g," ").split(/\s+/).map(parseFloat);else if(s==="transformMatrix")o=e&&e.transformMatrix?Ze(e.transformMatrix,Dg(t)):Dg(t);else if(s==="visible")o=t!==On&&t!=="hidden",e&&e.visible===!1&&(o=!1);else if(s==="opacity")o=parseFloat(t),e&&e.opacity!==void 0&&(o*=e.opacity);else if(s==="textAnchor")o=t==="start"?Vt:t==="end"?xe:Et;else if(s==="charSpacing"||s===eo)i=jo(t,n)/n*1e3;else if(s==="paintFirst"){const a=t.indexOf(Fe),l=t.indexOf(Rn);o=Fe,(a>-1&&l>-1&&l<a||a===-1&&l>-1)&&(o=Rn)}else{if(s==="href"||s==="xlink:href"||s==="font"||s==="id")return t;if(s==="imageSmoothing")return t==="optimizeQuality";i=r?t.map(jo):jo(t,n)}}else o="";return!r&&isNaN(i)?o:i}function DE(s,t){const e=s.match(N_);if(!e)return;const n=e[1],r=e[3],i=e[4],o=e[5],a=e[6];n&&(t.fontStyle=n),r&&(t.fontWeight=isNaN(parseFloat(r))?r:parseFloat(r)),i&&(t.fontSize=jo(i)),a&&(t.fontFamily=a),o&&(t.lineHeight=o==="normal"?1:o)}function AE(s,t){s.replace(/;\s*$/,"").split(";").forEach((e=>{if(!e)return;const[n,r]=e.split(":");t[n.trim().toLowerCase()]=r.trim()}))}function OE(s){const t={},e=s.getAttribute("style");return e&&(typeof e=="string"?AE(e,t):(function(n,r){Object.entries(n).forEach((i=>{let[o,a]=i;a!==void 0&&(r[o.toLowerCase()]=a)}))})(e,t)),t}const RE={stroke:"strokeOpacity",fill:"fillOpacity"};function Fr(s,t,e){if(!s)return{};let n,r={},i=Ry;s.parentNode&&sw.test(s.parentNode.nodeName)&&(r=Fr(s.parentElement,t,e),r.fontSize&&(n=i=jo(r.fontSize)));const o=V(V(V({},t.reduce(((c,u)=>{const h=s.getAttribute(u);return h&&(c[u]=h),c}),{})),(function(c){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},h={};for(const d in u)mE(c,d.split(" "))&&(h=V(V({},h),u[d]));return h})(s,e)),OE(s));o[jm]&&s.setAttribute(jm,o[jm]),o[Gm]&&(n=jo(o[Gm],i),o[Gm]="".concat(n));const a={};for(const c in o){const u=gE(c),h=EE(u,o[c],r,n);a[u]=h}a&&a.font&&DE(a.font,a);const l=V(V({},r),a);return sw.test(s.nodeName)?l:(function(c){const u=an.getDefaults();return Object.entries(RE).forEach((h=>{let[d,p]=h;if(c[p]===void 0||c[d]==="")return;if(c[d]===void 0){if(!u[d])return;c[d]=u[d]}if(c[d].indexOf("url(")===0)return;const f=new Gt(c[d]);c[d]=f.setAlpha(Qt(f.getAlpha()*c[p],2)).toRgba()})),c})(l)}const FE=["left","top","width","height","visible"],fS=["rx","ry"];class Ms extends an{static getDefaults(){return V(V({},super.getDefaults()),Ms.ownDefaults)}constructor(t){super(),Object.assign(this,Ms.ownDefaults),this.setOptions(t),this._initRxRy()}_initRxRy(){const{rx:t,ry:e}=this;t&&!e?this.ry=t:e&&!t&&(this.rx=e)}_render(t){const{width:e,height:n}=this,r=-e/2,i=-n/2,o=this.rx?Math.min(this.rx,e/2):0,a=this.ry?Math.min(this.ry,n/2):0,l=o!==0||a!==0;t.beginPath(),t.moveTo(r+o,i),t.lineTo(r+e-o,i),l&&t.bezierCurveTo(r+e-Kr*o,i,r+e,i+Kr*a,r+e,i+a),t.lineTo(r+e,i+n-a),l&&t.bezierCurveTo(r+e,i+n-Kr*a,r+e-Kr*o,i+n,r+e-o,i+n),t.lineTo(r+o,i+n),l&&t.bezierCurveTo(r+Kr*o,i+n,r,i+n-Kr*a,r,i+n-a),t.lineTo(r,i+a),l&&t.bezierCurveTo(r,i+Kr*a,r+Kr*o,i,r+o,i),t.closePath(),this._renderPaintInOrder(t)}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return super.toObject([...fS,...t])}_toSVG(){const{width:t,height:e,rx:n,ry:r}=this;return["<rect ","COMMON_PARTS",'x="'.concat(-t/2,'" y="').concat(-e/2,'" rx="').concat(n,'" ry="').concat(r,'" width="').concat(t,'" height="').concat(e,`" />
`)]}static async fromElement(t,e,n){const r=Fr(t,this.ATTRIBUTE_NAMES,n),{left:i=0,top:o=0,width:a=0,height:l=0,visible:c=!0}=r,u=se(r,FE);return new this(V(V(V({},e),u),{},{left:i,top:o,width:a,height:l,visible:!!(c&&a&&l)}))}}z(Ms,"type","Rect"),z(Ms,"cacheProperties",[...Rr,...fS]),z(Ms,"ownDefaults",{rx:0,ry:0}),z(Ms,"ATTRIBUTE_NAMES",[...xi,"x","y","rx","ry","width","height"]),ut.setClass(Ms),ut.setSVGClass(Ms);const xr="initialization",Ad="added",Yy="removed",Od="imperative",mS=(s,t)=>{const{strokeUniform:e,strokeWidth:n,width:r,height:i,group:o}=t,a=o&&o!==s?mp(o.calcTransformMatrix(),s.calcTransformMatrix()):null,l=a?t.getRelativeCenterPoint().transform(a):t.getRelativeCenterPoint(),c=!t.isStrokeAccountedForInDimensions(),u=e&&c?w_(new q(n,n),void 0,s.calcTransformMatrix()):Ly,h=!e&&c?n:0,d=Vy(r+h,i+h,My([a,t.calcOwnMatrix()],!0)).add(u).scalarDivide(2);return[l.subtract(d),l.add(d)]};class bp{calcLayoutResult(t,e){if(this.shouldPerformLayout(t))return this.calcBoundingBox(e,t)}shouldPerformLayout(t){let{type:e,prevStrategy:n,strategy:r}=t;return e===xr||e===Od||!!n&&r!==n}shouldLayoutClipPath(t){let{type:e,target:{clipPath:n}}=t;return e!==xr&&n&&!n.absolutePositioned}getInitialSize(t,e){return e.size}calcBoundingBox(t,e){const{type:n,target:r}=e;if(n===Od&&e.overrides)return e.overrides;if(t.length===0)return;const{left:i,top:o,width:a,height:l}=vr(t.map((h=>mS(r,h))).reduce(((h,d)=>h.concat(d)),[])),c=new q(a,l),u=new q(i,o).add(c.scalarDivide(2));if(n===xr){const h=this.getInitialSize(e,{size:c,center:u});return{center:u,relativeCorrection:new q(0,0),size:h}}return{center:u.transform(r.calcOwnMatrix()),size:c}}}z(bp,"type","strategy");class Ag extends bp{shouldPerformLayout(t){return!0}}z(Ag,"type","fit-content"),ut.setClass(Ag);const PE=["strategy"],LE=["target","strategy","bubbles","prevStrategy"],gS="layoutManager";class nc{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:new Ag;z(this,"strategy",void 0),this.strategy=t,this._subscriptions=new Map}performLayout(t){const e=V(V({bubbles:!0,strategy:this.strategy},t),{},{prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}});this.onBeforeLayout(e);const n=this.getLayoutResult(e);n&&this.commitLayout(e,n),this.onAfterLayout(e,n),this._prevLayoutStrategy=e.strategy}attachHandlers(t,e){const{target:n}=e;return[kd,O1,Zl,R1,hp,F1,Td,i_,o_].map((r=>t.on(r,(i=>this.performLayout(r===kd?{type:"object_modified",trigger:r,e:i,target:n}:{type:"object_modifying",trigger:r,e:i,target:n})))))}subscribe(t,e){this.unsubscribe(t,e);const n=this.attachHandlers(t,e);this._subscriptions.set(t,n)}unsubscribe(t,e){(this._subscriptions.get(t)||[]).forEach((n=>n())),this._subscriptions.delete(t)}unsubscribeTargets(t){t.targets.forEach((e=>this.unsubscribe(e,t)))}subscribeTargets(t){t.targets.forEach((e=>this.subscribe(e,t)))}onBeforeLayout(t){const{target:e,type:n}=t,{canvas:r}=e;if(n===xr||n===Ad?this.subscribeTargets(t):n===Yy&&this.unsubscribeTargets(t),e.fire("layout:before",{context:t}),r&&r.fire("object:layout:before",{target:e,context:t}),n===Od&&t.deep){const i=se(t,PE);e.forEachObject((o=>o.layoutManager&&o.layoutManager.performLayout(V(V({},i),{},{bubbles:!1,target:o}))))}}getLayoutResult(t){const{target:e,strategy:n,type:r}=t,i=n.calcLayoutResult(t,e.getObjects());if(!i)return;const o=r===xr?new q:e.getRelativeCenterPoint(),{center:a,correction:l=new q,relativeCorrection:c=new q}=i,u=o.subtract(a).add(l).transform(r===xr?yn:ks(e.calcOwnMatrix()),!0).add(c);return{result:i,prevCenter:o,nextCenter:a,offset:u}}commitLayout(t,e){const{target:n}=t,{result:{size:r},nextCenter:i}=e;var o,a;n.set({width:r.x,height:r.y}),this.layoutObjects(t,e),t.type===xr?n.set({left:(o=t.x)!==null&&o!==void 0?o:i.x+r.x*ke(n.originX),top:(a=t.y)!==null&&a!==void 0?a:i.y+r.y*ke(n.originY)}):(n.setPositionByOrigin(i,Et,Et),n.setCoords(),n.set("dirty",!0))}layoutObjects(t,e){const{target:n}=t;n.forEachObject((r=>{r.group===n&&this.layoutObject(t,e,r)})),t.strategy.shouldLayoutClipPath(t)&&this.layoutObject(t,e,n.clipPath)}layoutObject(t,e,n){let{offset:r}=e;n.set({left:n.left+r.x,top:n.top+r.y})}onAfterLayout(t,e){const{target:n,strategy:r,bubbles:i,prevStrategy:o}=t,a=se(t,LE),{canvas:l}=n;n.fire("layout:after",{context:t,result:e}),l&&l.fire("object:layout:after",{context:t,result:e,target:n});const c=n.parent;i&&c!=null&&c.layoutManager&&((a.path||(a.path=[])).push(n),c.layoutManager.performLayout(V(V({},a),{},{target:c}))),n.set("dirty",!0)}dispose(){const{_subscriptions:t}=this;t.forEach((e=>e.forEach((n=>n())))),t.clear()}toObject(){return{type:gS,strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}ut.setClass(nc,gS);const ME=["type","objects","layoutManager"];class BE extends nc{performLayout(){}}class Ki extends P1(an){static getDefaults(){return V(V({},super.getDefaults()),Ki.ownDefaults)}constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),z(this,"_activeObjects",[]),z(this,"__objectSelectionTracker",void 0),z(this,"__objectSelectionDisposer",void 0),Object.assign(this,Ki.ownDefaults),this.setOptions(e),this.groupInit(t,e)}groupInit(t,e){var n;this._objects=[...t],this.__objectSelectionTracker=this.__objectSelectionMonitor.bind(this,!0),this.__objectSelectionDisposer=this.__objectSelectionMonitor.bind(this,!1),this.forEachObject((r=>{this.enterGroup(r,!1)})),this.layoutManager=(n=e.layoutManager)!==null&&n!==void 0?n:new nc,this.layoutManager.performLayout({type:xr,target:this,targets:[...t],x:e.left,y:e.top})}canEnterGroup(t){return t===this||this.isDescendantOf(t)?(ri("error","Group: circular object trees are not supported, this call has no effect"),!1):this._objects.indexOf(t)===-1||(ri("error","Group: duplicate objects are not supported inside group, this call has no effect"),!1)}_filterObjectsBeforeEnteringGroup(t){return t.filter(((e,n,r)=>this.canEnterGroup(e)&&r.indexOf(e)===n))}add(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];const r=this._filterObjectsBeforeEnteringGroup(e),i=super.add(...r);return this._onAfterObjectsChange(Ad,r),i}insertAt(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const i=this._filterObjectsBeforeEnteringGroup(n),o=super.insertAt(t,...i);return this._onAfterObjectsChange(Ad,i),o}remove(){const t=super.remove(...arguments);return this._onAfterObjectsChange(Yy,t),t}_onObjectAdded(t){this.enterGroup(t,!0),this.fire("object:added",{target:t}),t.fire("added",{target:this})}_onObjectRemoved(t,e){this.exitGroup(t,e),this.fire("object:removed",{target:t}),t.fire("removed",{target:this})}_onAfterObjectsChange(t,e){this.layoutManager.performLayout({type:t,targets:e,target:this})}_onStackOrderChanged(){this._set("dirty",!0)}_set(t,e){const n=this[t];return super._set(t,e),t==="canvas"&&n!==e&&(this._objects||[]).forEach((r=>{r._set(t,e)})),this}_shouldSetNestedCoords(){return this.subTargetCheck}removeAll(){return this._activeObjects=[],this.remove(...this._objects)}__objectSelectionMonitor(t,e){let{target:n}=e;const r=this._activeObjects;if(t)r.push(n),this._set("dirty",!0);else if(r.length>0){const i=r.indexOf(n);i>-1&&(r.splice(i,1),this._set("dirty",!0))}}_watchObject(t,e){t&&this._watchObject(!1,e),t?(e.on("selected",this.__objectSelectionTracker),e.on("deselected",this.__objectSelectionDisposer)):(e.off("selected",this.__objectSelectionTracker),e.off("deselected",this.__objectSelectionDisposer))}enterGroup(t,e){t.group&&t.group.remove(t),t._set("parent",this),this._enterGroup(t,e)}_enterGroup(t,e){e&&$d(t,Ze(ks(this.calcTransformMatrix()),t.calcTransformMatrix())),this._shouldSetNestedCoords()&&t.setCoords(),t._set("group",this),t._set("canvas",this.canvas),this._watchObject(!0,t);const n=this.canvas&&this.canvas.getActiveObject&&this.canvas.getActiveObject();n&&(n===t||t.isDescendantOf(n))&&this._activeObjects.push(t)}exitGroup(t,e){this._exitGroup(t,e),t._set("parent",void 0),t._set("canvas",void 0)}_exitGroup(t,e){t._set("group",void 0),e||($d(t,Ze(this.calcTransformMatrix(),t.calcTransformMatrix())),t.setCoords()),this._watchObject(!1,t);const n=this._activeObjects.length>0?this._activeObjects.indexOf(t):-1;n>-1&&this._activeObjects.splice(n,1)}shouldCache(){const t=an.prototype.shouldCache.call(this);if(t){for(let e=0;e<this._objects.length;e++)if(this._objects[e].willDrawShadow())return this.ownCaching=!1,!1}return t}willDrawShadow(){if(super.willDrawShadow())return!0;for(let t=0;t<this._objects.length;t++)if(this._objects[t].willDrawShadow())return!0;return!1}isOnACache(){return this.ownCaching||!!this.parent&&this.parent.isOnACache()}drawObject(t,e,n){this._renderBackground(t);for(let i=0;i<this._objects.length;i++){var r;const o=this._objects[i];(r=this.canvas)!==null&&r!==void 0&&r.preserveObjectStacking&&o.group!==this?(t.save(),t.transform(...ks(this.calcTransformMatrix())),o.render(t),t.restore()):o.group===this&&o.render(t)}this._drawClipPath(t,this.clipPath,n)}setCoords(){super.setCoords(),this._shouldSetNestedCoords()&&this.forEachObject((t=>t.setCoords()))}triggerLayout(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.layoutManager.performLayout(V({target:this,type:Od},t))}render(t){this._transformDone=!0,super.render(t),this._transformDone=!1}__serializeObjects(t,e){const n=this.includeDefaultValues;return this._objects.filter((function(r){return!r.excludeFromExport})).map((function(r){const i=r.includeDefaultValues;r.includeDefaultValues=n;const o=r[t||"toObject"](e);return r.includeDefaultValues=i,o}))}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];const e=this.layoutManager.toObject();return V(V(V({},super.toObject(["subTargetCheck","interactive",...t])),e.strategy!=="fit-content"||this.includeDefaultValues?{layoutManager:e}:{}),{},{objects:this.__serializeObjects("toObject",t)})}toString(){return"#<Group: (".concat(this.complexity(),")>")}dispose(){this.layoutManager.unsubscribeTargets({targets:this.getObjects(),target:this}),this._activeObjects=[],this.forEachObject((t=>{this._watchObject(!1,t),t.dispose()})),super.dispose()}_createSVGBgRect(t){if(!this.backgroundColor)return"";const e=Ms.prototype._toSVG.call(this),n=e.indexOf("COMMON_PARTS");e[n]='for="group" ';const r=e.join("");return t?t(r):r}_toSVG(t){const e=["<g ","COMMON_PARTS",` >
`],n=this._createSVGBgRect(t);n&&e.push("		",n);for(let r=0;r<this._objects.length;r++)e.push("		",this._objects[r].toSVG(t));return e.push(`</g>
`),e}getSvgStyles(){const t=this.opacity!==void 0&&this.opacity!==1?"opacity: ".concat(this.opacity,";"):"",e=this.visible?"":" visibility: hidden;";return[t,this.getSvgFilter(),e].join("")}toClipPathSVG(t){const e=[],n=this._createSVGBgRect(t);n&&e.push("	",n);for(let r=0;r<this._objects.length;r++)e.push("	",this._objects[r].toClipPathSVG(t));return this._createBaseClipPathSVGMarkup(e,{reviver:t})}static fromObject(t,e){let{type:n,objects:r=[],layoutManager:i}=t,o=se(t,ME);return Promise.all([Jl(r,e),fp(o,e)]).then((a=>{let[l,c]=a;const u=new this(l,V(V(V({},o),c),{},{layoutManager:new BE}));if(i){const h=ut.getClass(i.type),d=ut.getClass(i.strategy);u.layoutManager=new h(new d)}else u.layoutManager=new nc;return u.layoutManager.subscribeTargets({type:xr,target:u,targets:u.getObjects()}),u.setCoords(),u}))}}z(Ki,"type","Group"),z(Ki,"ownDefaults",{strokeWidth:0,subTargetCheck:!1,interactive:!1}),ut.setClass(Ki);const zE=(s,t)=>Math.min(t.width/s.width,t.height/s.height),VE=(s,t)=>Math.max(t.width/s.width,t.height/s.height),Og="\\s*,?\\s*",Al="".concat(Og,"(").concat(Is,")"),WE="".concat(Al).concat(Al).concat(Al).concat(Og,"([01])").concat(Og,"([01])").concat(Al).concat(Al),UE={m:"l",M:"L"},GE=(s,t,e,n,r,i,o,a,l,c,u)=>{const h=Tr(s),d=kr(s),p=Tr(t),f=kr(t),m=e*r*p-n*i*f+o,g=n*r*p+e*i*f+a;return["C",c+l*(-e*r*d-n*i*h),u+l*(-n*r*d+e*i*h),m+l*(e*r*f+n*i*p),g+l*(n*r*f-e*i*p),m,g]},xw=(s,t,e,n)=>{const r=Math.atan2(t,s),i=Math.atan2(n,e);return i>=r?i-r:2*Math.PI-(r-i)};function ww(s,t,e,n,r,i,o,a){let l;if(Mt.cachesBoundsOfCurve&&(l=[...arguments].join(),Hl.boundsOfCurveCache[l]))return Hl.boundsOfCurveCache[l];const c=Math.sqrt,u=Math.abs,h=[],d=[[0,0],[0,0]];let p=6*s-12*e+6*r,f=-3*s+9*e-9*r+3*o,m=3*e-3*s;for(let x=0;x<2;++x){if(x>0&&(p=6*t-12*n+6*i,f=-3*t+9*n-9*i+3*a,m=3*n-3*t),u(f)<1e-12){if(u(p)<1e-12)continue;const N=-m/p;0<N&&N<1&&h.push(N);continue}const v=p*p-4*m*f;if(v<0)continue;const C=c(v),k=(-p+C)/(2*f);0<k&&k<1&&h.push(k);const I=(-p-C)/(2*f);0<I&&I<1&&h.push(I)}let g=h.length;const y=g,b=yS(s,t,e,n,r,i,o,a);for(;g--;){const{x,y:v}=b(h[g]);d[0][g]=x,d[1][g]=v}d[0][y]=s,d[1][y]=t,d[0][y+1]=o,d[1][y+1]=a;const w=[new q(Math.min(...d[0]),Math.min(...d[1])),new q(Math.max(...d[0]),Math.max(...d[1]))];return Mt.cachesBoundsOfCurve&&(Hl.boundsOfCurveCache[l]=w),w}const jE=(s,t,e)=>{let[n,r,i,o,a,l,c,u]=e;const h=((d,p,f,m,g,y,b)=>{if(f===0||m===0)return[];let w=0,x=0,v=0;const C=Math.PI,k=b*Oy,I=kr(k),N=Tr(k),_=.5*(-N*d-I*p),T=.5*(-N*p+I*d),D=f**2,R=m**2,P=T**2,B=_**2,U=D*R-D*P-R*B;let H=Math.abs(f),G=Math.abs(m);if(U<0){const wt=Math.sqrt(1-U/(D*R));H*=wt,G*=wt}else v=(g===y?-1:1)*Math.sqrt(U/(D*P+R*B));const X=v*H*T/G,Z=-v*G*_/H,J=N*X-I*Z+.5*d,et=I*X+N*Z+.5*p;let Q=xw(1,0,(_-X)/H,(T-Z)/G),st=xw((_-X)/H,(T-Z)/G,(-_-X)/H,(-T-Z)/G);y===0&&st>0?st-=2*C:y===1&&st<0&&(st+=2*C);const it=Math.ceil(Math.abs(st/C*2)),at=[],pt=st/it,xt=8/3*Math.sin(pt/4)*Math.sin(pt/4)/Math.sin(pt/2);let bt=Q+pt;for(let wt=0;wt<it;wt++)at[wt]=GE(Q,bt,N,I,H,G,J,et,xt,w,x),w=at[wt][5],x=at[wt][6],Q=bt,bt+=pt;return at})(c-s,u-t,r,i,a,l,o);for(let d=0,p=h.length;d<p;d++)h[d][1]+=s,h[d][2]+=t,h[d][3]+=s,h[d][4]+=t,h[d][5]+=s,h[d][6]+=t;return h},HE=s=>{let t=0,e=0,n=0,r=0;const i=[];let o,a=0,l=0;for(const c of s){const u=[...c];let h;switch(u[0]){case"l":u[1]+=t,u[2]+=e;case"L":t=u[1],e=u[2],h=["L",t,e];break;case"h":u[1]+=t;case"H":t=u[1],h=["L",t,e];break;case"v":u[1]+=e;case"V":e=u[1],h=["L",t,e];break;case"m":u[1]+=t,u[2]+=e;case"M":t=u[1],e=u[2],n=u[1],r=u[2],h=["M",t,e];break;case"c":u[1]+=t,u[2]+=e,u[3]+=t,u[4]+=e,u[5]+=t,u[6]+=e;case"C":a=u[3],l=u[4],t=u[5],e=u[6],h=["C",u[1],u[2],a,l,t,e];break;case"s":u[1]+=t,u[2]+=e,u[3]+=t,u[4]+=e;case"S":o==="C"?(a=2*t-a,l=2*e-l):(a=t,l=e),t=u[3],e=u[4],h=["C",a,l,u[1],u[2],t,e],a=h[3],l=h[4];break;case"q":u[1]+=t,u[2]+=e,u[3]+=t,u[4]+=e;case"Q":a=u[1],l=u[2],t=u[3],e=u[4],h=["Q",a,l,t,e];break;case"t":u[1]+=t,u[2]+=e;case"T":o==="Q"?(a=2*t-a,l=2*e-l):(a=t,l=e),t=u[1],e=u[2],h=["Q",a,l,t,e];break;case"a":u[6]+=t,u[7]+=e;case"A":jE(t,e,u).forEach((d=>i.push(d))),t=u[6],e=u[7];break;case"z":case"Z":t=n,e=r,h=["Z"]}h?(i.push(h),o=h[0]):o=""}return i},Rd=(s,t,e,n)=>Math.sqrt((e-s)**2+(n-t)**2),yS=(s,t,e,n,r,i,o,a)=>l=>{const c=l**3,u=(p=>3*p**2*(1-p))(l),h=(p=>3*p*(1-p)**2)(l),d=(p=>(1-p)**3)(l);return new q(o*c+r*u+e*h+s*d,a*c+i*u+n*h+t*d)},bS=s=>s**2,xS=s=>2*s*(1-s),wS=s=>(1-s)**2,XE=(s,t,e,n,r,i,o,a)=>l=>{const c=bS(l),u=xS(l),h=wS(l),d=3*(h*(e-s)+u*(r-e)+c*(o-r)),p=3*(h*(n-t)+u*(i-n)+c*(a-i));return Math.atan2(p,d)},qE=(s,t,e,n,r,i)=>o=>{const a=bS(o),l=xS(o),c=wS(o);return new q(r*a+e*l+s*c,i*a+n*l+t*c)},KE=(s,t,e,n,r,i)=>o=>{const a=1-o,l=2*(a*(e-s)+o*(r-e)),c=2*(a*(n-t)+o*(i-n));return Math.atan2(c,l)},vw=(s,t,e)=>{let n=new q(t,e),r=0;for(let i=1;i<=100;i+=1){const o=s(i/100);r+=Rd(n.x,n.y,o.x,o.y),n=o}return r},YE=(s,t)=>{let e,n=0,r=0,i={x:s.x,y:s.y},o=V({},i),a=.01,l=0;const c=s.iterator,u=s.angleFinder;for(;r<t&&a>1e-4;)o=c(n),l=n,e=Rd(i.x,i.y,o.x,o.y),e+r>t?(n-=a,a/=2):(i=o,n+=a,r+=e);return V(V({},o),{},{angle:u(l)})},vS=s=>{let t,e,n=0,r=0,i=0,o=0,a=0;const l=[];for(const c of s){const u={x:r,y:i,command:c[0],length:0};switch(c[0]){case"M":e=u,e.x=o=r=c[1],e.y=a=i=c[2];break;case"L":e=u,e.length=Rd(r,i,c[1],c[2]),r=c[1],i=c[2];break;case"C":t=yS(r,i,c[1],c[2],c[3],c[4],c[5],c[6]),e=u,e.iterator=t,e.angleFinder=XE(r,i,c[1],c[2],c[3],c[4],c[5],c[6]),e.length=vw(t,r,i),r=c[5],i=c[6];break;case"Q":t=qE(r,i,c[1],c[2],c[3],c[4]),e=u,e.iterator=t,e.angleFinder=KE(r,i,c[1],c[2],c[3],c[4]),e.length=vw(t,r,i),r=c[3],i=c[4];break;case"Z":e=u,e.destX=o,e.destY=a,e.length=Rd(r,i,o,a),r=o,i=a}n+=e.length,l.push(e)}return l.push({length:n,x:r,y:i}),l},ZE=function(s,t){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:vS(s),n=0;for(;t-e[n].length>0&&n<e.length-2;)t-=e[n].length,n++;const r=e[n],i=t/r.length,o=s[n];switch(r.command){case"M":return{x:r.x,y:r.y,angle:0};case"Z":return V(V({},new q(r.x,r.y).lerp(new q(r.destX,r.destY),i)),{},{angle:Math.atan2(r.destY-r.y,r.destX-r.x)});case"L":return V(V({},new q(r.x,r.y).lerp(new q(o[1],o[2]),i)),{},{angle:Math.atan2(o[2]-r.y,o[1]-r.x)});case"C":case"Q":return YE(r,t)}},JE=new RegExp("[mzlhvcsqta][^mzlhvcsqta]*","gi"),Sw=new RegExp(WE,"g"),QE=new RegExp(Is,"gi"),tD={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},eD=s=>{var t;const e=[],n=(t=s.match(JE))!==null&&t!==void 0?t:[];for(const r of n){const i=r[0];if(i==="z"||i==="Z"){e.push([i]);continue}const o=tD[i.toLowerCase()];let a=[];if(i==="a"||i==="A"){Sw.lastIndex=0;for(let l=null;l=Sw.exec(r);)a.push(...l.slice(1))}else a=r.match(QE)||[];for(let l=0;l<a.length;l+=o){const c=new Array(o),u=UE[i];c[0]=l>0&&u?u:i;for(let h=0;h<o;h++)c[h+1]=parseFloat(a[l+h]);e.push(c)}}return e},nD=(s,t)=>s.map((e=>e.map(((n,r)=>r===0||t===void 0?n:Qt(n,t))).join(" "))).join(" ");function Rg(s,t){const e=s.style;e&&t&&(typeof t=="string"?e.cssText+=";"+t:Object.entries(t).forEach((n=>{let[r,i]=n;return e.setProperty(r,i)})))}class sD extends X1{constructor(t){let{allowTouchScrolling:e=!1,containerClass:n=""}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(t),z(this,"upper",void 0),z(this,"container",void 0);const{el:r}=this.lower,i=this.createUpperCanvas();this.upper={el:i,ctx:i.getContext("2d")},this.applyCanvasStyle(r,{allowTouchScrolling:e}),this.applyCanvasStyle(i,{allowTouchScrolling:e,styles:{position:"absolute",left:"0",top:"0"}});const o=this.createContainerElement();o.classList.add(n),r.parentNode&&r.parentNode.replaceChild(o,r),o.append(r,i),this.container=o}createUpperCanvas(){const{el:t}=this.lower,e=Ir();return e.className=t.className,e.classList.remove("lower-canvas"),e.classList.add("upper-canvas"),e.setAttribute("data-fabric","top"),e.style.cssText=t.style.cssText,e.setAttribute("draggable","true"),e}createContainerElement(){const t=da().createElement("div");return t.setAttribute("data-fabric","wrapper"),Rg(t,{position:"relative"}),Xx(t),t}applyCanvasStyle(t,e){const{styles:n,allowTouchScrolling:r}=e;Rg(t,V(V({},n),{},{"touch-action":r?"manipulation":On})),Xx(t)}setDimensions(t,e){super.setDimensions(t,e);const{el:n,ctx:r}=this.upper;H1(n,r,t,e)}setCSSDimensions(t){super.setCSSDimensions(t),Ig(this.upper.el,t),Ig(this.container,t)}cleanupDOM(t){const e=this.container,{el:n}=this.lower,{el:r}=this.upper;super.cleanupDOM(t),e.removeChild(r),e.removeChild(n),e.parentNode&&e.parentNode.replaceChild(n,e)}dispose(){super.dispose(),Qs().dispose(this.upper.el),delete this.upper,delete this.container}}class xp extends kc{constructor(){super(...arguments),z(this,"targets",[]),z(this,"_hoveredTargets",[]),z(this,"_currentTransform",null),z(this,"_groupSelector",null),z(this,"contextTopDirty",!1)}static getDefaults(){return V(V({},super.getDefaults()),xp.ownDefaults)}get upperCanvasEl(){var t;return(t=this.elements.upper)===null||t===void 0?void 0:t.el}get contextTop(){var t;return(t=this.elements.upper)===null||t===void 0?void 0:t.ctx}get wrapperEl(){return this.elements.container}initElements(t){this.elements=new sD(t,{allowTouchScrolling:this.allowTouchScrolling,containerClass:this.containerClass}),this._createCacheCanvas()}_onObjectAdded(t){this._objectsToRender=void 0,super._onObjectAdded(t)}_onObjectRemoved(t){this._objectsToRender=void 0,t===this._activeObject&&(this.fire("before:selection:cleared",{deselected:[t]}),this._discardActiveObject(),this.fire("selection:cleared",{deselected:[t]}),t.fire("deselected",{target:t})),t===this._hoveredTarget&&(this._hoveredTarget=void 0,this._hoveredTargets=[]),super._onObjectRemoved(t)}_onStackOrderChanged(){this._objectsToRender=void 0,super._onStackOrderChanged()}_chooseObjectsToRender(){const t=this._activeObject;return!this.preserveObjectStacking&&t?this._objects.filter((e=>!e.group&&e!==t)).concat(t):this._objects}renderAll(){this.cancelRequestedRender(),this.destroyed||(!this.contextTopDirty||this._groupSelector||this.isDrawingMode||(this.clearContext(this.contextTop),this.contextTopDirty=!1),this.hasLostContext&&(this.renderTopLayer(this.contextTop),this.hasLostContext=!1),!this._objectsToRender&&(this._objectsToRender=this._chooseObjectsToRender()),this.renderCanvas(this.getContext(),this._objectsToRender))}renderTopLayer(t){t.save(),this.isDrawingMode&&this._isCurrentlyDrawing&&(this.freeDrawingBrush&&this.freeDrawingBrush._render(),this.contextTopDirty=!0),this.selection&&this._groupSelector&&(this._drawSelection(t),this.contextTopDirty=!0),t.restore()}renderTop(){const t=this.contextTop;this.clearContext(t),this.renderTopLayer(t),this.fire("after:render",{ctx:t})}setTargetFindTolerance(t){t=Math.round(t),this.targetFindTolerance=t;const e=this.getRetinaScaling(),n=Math.ceil((2*t+1)*e);this.pixelFindCanvasEl.width=this.pixelFindCanvasEl.height=n,this.pixelFindContext.scale(e,e)}isTargetTransparent(t,e,n){const r=this.targetFindTolerance,i=this.pixelFindContext;this.clearContext(i),i.save(),i.translate(-e+r,-n+r),i.transform(...this.viewportTransform);const o=t.selectionBackgroundColor;t.selectionBackgroundColor="",t.render(i),t.selectionBackgroundColor=o,i.restore();const a=Math.round(r*this.getRetinaScaling());return aE(i,a,a,a)}_isSelectionKeyPressed(t){const e=this.selectionKey;return!!e&&(Array.isArray(e)?!!e.find((n=>!!n&&t[n]===!0)):t[e])}_shouldClearSelection(t,e){const n=this.getActiveObjects(),r=this._activeObject;return!!(!e||e&&r&&n.length>1&&n.indexOf(e)===-1&&r!==e&&!this._isSelectionKeyPressed(t)||e&&!e.evented||e&&!e.selectable&&r&&r!==e)}_shouldCenterTransform(t,e,n){if(!t)return;let r;return e===dp||e===Fn||e===us||e===Zl?r=this.centeredScaling||t.centeredScaling:e===Py&&(r=this.centeredRotation||t.centeredRotation),r?!n:n}_getOriginFromCorner(t,e){const n={x:t.originX,y:t.originY};return e&&(["ml","tl","bl"].includes(e)?n.x=xe:["mr","tr","br"].includes(e)&&(n.x=Vt),["tl","mt","tr"].includes(e)?n.y=kg:["bl","mb","br"].includes(e)&&(n.y=An)),n}_setupCurrentTransform(t,e,n){var r;const i=e.group?Go(this.getScenePoint(t),void 0,e.group.calcTransformMatrix()):this.getScenePoint(t),{key:o="",control:a}=e.getActiveControl()||{},l=n&&a?(r=a.getActionHandler(t,e,a))===null||r===void 0?void 0:r.bind(a):C_,c=((p,f,m,g)=>{if(!f||!p)return"drag";const y=g.controls[f];return y.getActionName(m,y,g)})(n,o,t,e),u=t[this.centeredKey],h=this._shouldCenterTransform(e,c,u)?{x:Et,y:Et}:this._getOriginFromCorner(e,o),d={target:e,action:c,actionHandler:l,actionPerformed:!1,corner:o,scaleX:e.scaleX,scaleY:e.scaleY,skewX:e.skewX,skewY:e.skewY,offsetX:i.x-e.left,offsetY:i.y-e.top,originX:h.x,originY:h.y,ex:i.x,ey:i.y,lastX:i.x,lastY:i.y,theta:Se(e.angle),width:e.width,height:e.height,shiftKey:t.shiftKey,altKey:u,original:V(V({},q1(e)),{},{originX:h.x,originY:h.y})};this._currentTransform=d,this.fire("before:transform",{e:t,transform:d})}setCursor(t){this.upperCanvasEl.style.cursor=t}_drawSelection(t){const{x:e,y:n,deltaX:r,deltaY:i}=this._groupSelector,o=new q(e,n).transform(this.viewportTransform),a=new q(e+r,n+i).transform(this.viewportTransform),l=this.selectionLineWidth/2;let c=Math.min(o.x,a.x),u=Math.min(o.y,a.y),h=Math.max(o.x,a.x),d=Math.max(o.y,a.y);this.selectionColor&&(t.fillStyle=this.selectionColor,t.fillRect(c,u,h-c,d-u)),this.selectionLineWidth&&this.selectionBorderColor&&(t.lineWidth=this.selectionLineWidth,t.strokeStyle=this.selectionBorderColor,c+=l,u+=l,h-=l,d-=l,an.prototype._setLineDash.call(this,t,this.selectionDashArray),t.strokeRect(c,u,h-c,d-u))}findTarget(t){if(this.skipTargetFind)return;const e=this.getViewportPoint(t),n=this._activeObject,r=this.getActiveObjects();if(this.targets=[],n&&r.length>=1){if(n.findControl(e,Ng(t))||r.length>1&&this.searchPossibleTargets([n],e))return n;if(n===this.searchPossibleTargets([n],e)){if(this.preserveObjectStacking){const i=this.targets;this.targets=[];const o=this.searchPossibleTargets(this._objects,e);return t[this.altSelectionKey]&&o&&o!==n?(this.targets=i,n):o}return n}}return this.searchPossibleTargets(this._objects,e)}_pointIsInObjectSelectionArea(t,e){let n=t.getCoords();const r=this.getZoom(),i=t.padding/r;if(i){const[o,a,l,c]=n,u=Math.atan2(a.y-o.y,a.x-o.x),h=Tr(u)*i,d=kr(u)*i,p=h+d,f=h-d;n=[new q(o.x-f,o.y-p),new q(a.x+p,a.y-f),new q(l.x+f,l.y+p),new q(c.x-p,c.y+f)]}return he.isPointInPolygon(e,n)}_checkTarget(t,e){return!!(t&&t.visible&&t.evented&&this._pointIsInObjectSelectionArea(t,Go(e,void 0,this.viewportTransform))&&(!this.perPixelTargetFind&&!t.perPixelTargetFind||t.isEditing||!this.isTargetTransparent(t,e.x,e.y)))}_searchPossibleTargets(t,e){let n=t.length;for(;n--;){const r=t[n];if(this._checkTarget(r,e)){if(ld(r)&&r.subTargetCheck){const i=this._searchPossibleTargets(r._objects,e);i&&this.targets.push(i)}return r}}}searchPossibleTargets(t,e){const n=this._searchPossibleTargets(t,e);if(n&&ld(n)&&n.interactive&&this.targets[0]){const r=this.targets;for(let i=r.length-1;i>0;i--){const o=r[i];if(!ld(o)||!o.interactive)return o}return r[0]}return n}getViewportPoint(t){return this._pointer?this._pointer:this.getPointer(t,!0)}getScenePoint(t){return this._absolutePointer?this._absolutePointer:this.getPointer(t)}getPointer(t){let e=arguments.length>1&&arguments[1]!==void 0&&arguments[1];const n=this.upperCanvasEl,r=n.getBoundingClientRect();let i=g_(t),o=r.width||0,a=r.height||0;o&&a||(An in r&&kg in r&&(a=Math.abs(r.top-r.bottom)),xe in r&&Vt in r&&(o=Math.abs(r.right-r.left))),this.calcOffset(),i.x=i.x-this._offset.left,i.y=i.y-this._offset.top,e||(i=Go(i,void 0,this.viewportTransform));const l=this.getRetinaScaling();l!==1&&(i.x/=l,i.y/=l);const c=o===0||a===0?new q(1,1):new q(n.width/o,n.height/a);return i.multiply(c)}_setDimensionsImpl(t,e){this._resetTransformEventData(),super._setDimensionsImpl(t,e),this._isCurrentlyDrawing&&this.freeDrawingBrush&&this.freeDrawingBrush._setBrushStyles(this.contextTop)}_createCacheCanvas(){this.pixelFindCanvasEl=Ir(),this.pixelFindContext=this.pixelFindCanvasEl.getContext("2d",{willReadFrequently:!0}),this.setTargetFindTolerance(this.targetFindTolerance)}getTopContext(){return this.elements.upper.ctx}getSelectionContext(){return this.elements.upper.ctx}getSelectionElement(){return this.elements.upper.el}getActiveObject(){return this._activeObject}getActiveObjects(){const t=this._activeObject;return Pi(t)?t.getObjects():t?[t]:[]}_fireSelectionEvents(t,e){let n=!1,r=!1;const i=this.getActiveObjects(),o=[],a=[];t.forEach((l=>{i.includes(l)||(n=!0,l.fire("deselected",{e,target:l}),a.push(l))})),i.forEach((l=>{t.includes(l)||(n=!0,l.fire("selected",{e,target:l}),o.push(l))})),t.length>0&&i.length>0?(r=!0,n&&this.fire("selection:updated",{e,selected:o,deselected:a})):i.length>0?(r=!0,this.fire("selection:created",{e,selected:o})):t.length>0&&(r=!0,this.fire("selection:cleared",{e,deselected:a})),r&&(this._objectsToRender=void 0)}setActiveObject(t,e){const n=this.getActiveObjects(),r=this._setActiveObject(t,e);return this._fireSelectionEvents(n,e),r}_setActiveObject(t,e){const n=this._activeObject;return n!==t&&!(!this._discardActiveObject(e,t)&&this._activeObject)&&!t.onSelect({e})&&(this._activeObject=t,Pi(t)&&n!==t&&t.set("canvas",this),t.setCoords(),!0)}_discardActiveObject(t,e){const n=this._activeObject;return!!n&&!n.onDeselect({e:t,object:e})&&(this._currentTransform&&this._currentTransform.target===n&&this.endCurrentTransform(t),Pi(n)&&n===this._hoveredTarget&&(this._hoveredTarget=void 0),this._activeObject=void 0,!0)}discardActiveObject(t){const e=this.getActiveObjects(),n=this.getActiveObject();e.length&&this.fire("before:selection:cleared",{e:t,deselected:[n]});const r=this._discardActiveObject(t);return this._fireSelectionEvents(e,t),r}endCurrentTransform(t){const e=this._currentTransform;this._finalizeCurrentTransform(t),e&&e.target&&(e.target.isMoving=!1),this._currentTransform=null}_finalizeCurrentTransform(t){const e=this._currentTransform,n=e.target,r={e:t,target:n,transform:e,action:e.action};n._scaling&&(n._scaling=!1),n.setCoords(),e.actionPerformed&&(this.fire("object:modified",r),n.fire(kd,r))}setViewportTransform(t){super.setViewportTransform(t);const e=this._activeObject;e&&e.setCoords()}destroy(){const t=this._activeObject;Pi(t)&&(t.removeAll(),t.dispose()),delete this._activeObject,super.destroy(),this.pixelFindContext=null,this.pixelFindCanvasEl=void 0}clear(){this.discardActiveObject(),this._activeObject=void 0,this.clearContext(this.contextTop),super.clear()}drawControls(t){const e=this._activeObject;e&&e._renderControls(t)}_toObject(t,e,n){const r=this._realizeGroupTransformOnObject(t),i=super._toObject(t,e,n);return t.set(r),i}_realizeGroupTransformOnObject(t){const{group:e}=t;if(e&&Pi(e)&&this._activeObject===e){const n=ga(t,["angle","flipX","flipY",Vt,Fn,us,pa,fa,An]);return b_(t,e.calcOwnMatrix()),n}return{}}_setSVGObject(t,e,n){const r=this._realizeGroupTransformOnObject(e);super._setSVGObject(t,e,n),e.set(r)}}z(xp,"ownDefaults",{uniformScaling:!0,uniScaleKey:"shiftKey",centeredScaling:!1,centeredRotation:!1,centeredKey:"altKey",altActionKey:"shiftKey",selection:!0,selectionKey:"shiftKey",selectionColor:"rgba(100, 100, 255, 0.3)",selectionDashArray:[],selectionBorderColor:"rgba(255, 255, 255, 0.3)",selectionLineWidth:1,selectionFullyContained:!1,hoverCursor:"move",moveCursor:"move",defaultCursor:"default",freeDrawingCursor:"crosshair",notAllowedCursor:"not-allowed",perPixelTargetFind:!1,targetFindTolerance:0,skipTargetFind:!1,stopContextMenu:!1,fireRightClick:!1,fireMiddleClick:!1,enablePointerEvents:!1,containerClass:"canvas-container",preserveObjectStacking:!1});class rD{constructor(t){z(this,"targets",[]),z(this,"__disposer",void 0);const e=()=>{const{hiddenTextarea:r}=t.getActiveObject()||{};r&&r.focus()},n=t.upperCanvasEl;n.addEventListener("click",e),this.__disposer=()=>n.removeEventListener("click",e)}exitTextEditing(){this.target=void 0,this.targets.forEach((t=>{t.isEditing&&t.exitEditing()}))}add(t){this.targets.push(t)}remove(t){this.unregister(t),Mo(this.targets,t)}register(t){this.target=t}unregister(t){t===this.target&&(this.target=void 0)}onMouseMove(t){var e;!((e=this.target)===null||e===void 0)&&e.isEditing&&this.target.updateSelectionOnMouseMove(t)}clear(){this.targets=[],this.target=void 0}dispose(){this.clear(),this.__disposer(),delete this.__disposer}}const iD=["target","oldTarget","fireCanvas","e"],Un={passive:!1},Oo=(s,t)=>{const e=s.getViewportPoint(t),n=s.getScenePoint(t);return{viewportPoint:e,scenePoint:n,pointer:e,absolutePointer:n}},Yr=function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return s.addEventListener(...e)},ns=function(s){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return s.removeEventListener(...e)},oD={mouse:{in:"over",out:"out",targetIn:"mouseover",targetOut:"mouseout",canvasIn:"mouse:over",canvasOut:"mouse:out"},drag:{in:"enter",out:"leave",targetIn:"dragenter",targetOut:"dragleave",canvasIn:"drag:enter",canvasOut:"drag:leave"}};class Fg extends xp{constructor(t){super(t,arguments.length>1&&arguments[1]!==void 0?arguments[1]:{}),z(this,"_isClick",void 0),z(this,"textEditingManager",new rD(this)),["_onMouseDown","_onTouchStart","_onMouseMove","_onMouseUp","_onTouchEnd","_onResize","_onMouseWheel","_onMouseOut","_onMouseEnter","_onContextMenu","_onClick","_onDragStart","_onDragEnd","_onDragProgress","_onDragOver","_onDragEnter","_onDragLeave","_onDrop"].forEach((e=>{this[e]=this[e].bind(this)})),this.addOrRemove(Yr,"add")}_getEventPrefix(){return this.enablePointerEvents?"pointer":"mouse"}addOrRemove(t,e){const n=this.upperCanvasEl,r=this._getEventPrefix();t(j1(n),"resize",this._onResize),t(n,r+"down",this._onMouseDown),t(n,"".concat(r,"move"),this._onMouseMove,Un),t(n,"".concat(r,"out"),this._onMouseOut),t(n,"".concat(r,"enter"),this._onMouseEnter),t(n,"wheel",this._onMouseWheel,{passive:!1}),t(n,"contextmenu",this._onContextMenu),t(n,"click",this._onClick),t(n,"dblclick",this._onClick),t(n,"dragstart",this._onDragStart),t(n,"dragend",this._onDragEnd),t(n,"dragover",this._onDragOver),t(n,"dragenter",this._onDragEnter),t(n,"dragleave",this._onDragLeave),t(n,"drop",this._onDrop),this.enablePointerEvents||t(n,"touchstart",this._onTouchStart,Un)}removeListeners(){this.addOrRemove(ns,"remove");const t=this._getEventPrefix(),e=Ts(this.upperCanvasEl);ns(e,"".concat(t,"up"),this._onMouseUp),ns(e,"touchend",this._onTouchEnd,Un),ns(e,"".concat(t,"move"),this._onMouseMove,Un),ns(e,"touchmove",this._onMouseMove,Un),clearTimeout(this._willAddMouseDown)}_onMouseWheel(t){this.__onMouseWheel(t)}_onMouseOut(t){const e=this._hoveredTarget,n=V({e:t},Oo(this,t));this.fire("mouse:out",V(V({},n),{},{target:e})),this._hoveredTarget=void 0,e&&e.fire("mouseout",V({},n)),this._hoveredTargets.forEach((r=>{this.fire("mouse:out",V(V({},n),{},{target:r})),r&&r.fire("mouseout",V({},n))})),this._hoveredTargets=[]}_onMouseEnter(t){this._currentTransform||this.findTarget(t)||(this.fire("mouse:over",V({e:t},Oo(this,t))),this._hoveredTarget=void 0,this._hoveredTargets=[])}_onDragStart(t){this._isClick=!1;const e=this.getActiveObject();if(e&&e.onDragStart(t)){this._dragSource=e;const n={e:t,target:e};return this.fire("dragstart",n),e.fire("dragstart",n),void Yr(this.upperCanvasEl,"drag",this._onDragProgress)}qx(t)}_renderDragEffects(t,e,n){let r=!1;const i=this._dropTarget;i&&i!==e&&i!==n&&(i.clearContextTop(),r=!0),e?.clearContextTop(),n!==e&&n?.clearContextTop();const o=this.contextTop;o.save(),o.transform(...this.viewportTransform),e&&(o.save(),e.transform(o),e.renderDragSourceEffect(t),o.restore(),r=!0),n&&(o.save(),n.transform(o),n.renderDropTargetEffect(t),o.restore(),r=!0),o.restore(),r&&(this.contextTopDirty=!0)}_onDragEnd(t){const e=!!t.dataTransfer&&t.dataTransfer.dropEffect!==On,n=e?this._activeObject:void 0,r={e:t,target:this._dragSource,subTargets:this.targets,dragSource:this._dragSource,didDrop:e,dropTarget:n};ns(this.upperCanvasEl,"drag",this._onDragProgress),this.fire("dragend",r),this._dragSource&&this._dragSource.fire("dragend",r),delete this._dragSource,this._onMouseUp(t)}_onDragProgress(t){const e={e:t,target:this._dragSource,dragSource:this._dragSource,dropTarget:this._draggedoverTarget};this.fire("drag",e),this._dragSource&&this._dragSource.fire("drag",e)}findDragTargets(t){return this.targets=[],{target:this._searchPossibleTargets(this._objects,this.getViewportPoint(t)),targets:[...this.targets]}}_onDragOver(t){const e="dragover",{target:n,targets:r}=this.findDragTargets(t),i=this._dragSource,o={e:t,target:n,subTargets:r,dragSource:i,canDrop:!1,dropTarget:void 0};let a;this.fire(e,o),this._fireEnterLeaveEvents(n,o),n&&(n.canDrop(t)&&(a=n),n.fire(e,o));for(let l=0;l<r.length;l++){const c=r[l];c.canDrop(t)&&(a=c),c.fire(e,o)}this._renderDragEffects(t,i,a),this._dropTarget=a}_onDragEnter(t){const{target:e,targets:n}=this.findDragTargets(t),r={e:t,target:e,subTargets:n,dragSource:this._dragSource};this.fire("dragenter",r),this._fireEnterLeaveEvents(e,r)}_onDragLeave(t){const e={e:t,target:this._draggedoverTarget,subTargets:this.targets,dragSource:this._dragSource};this.fire("dragleave",e),this._fireEnterLeaveEvents(void 0,e),this._renderDragEffects(t,this._dragSource),this._dropTarget=void 0,this.targets=[],this._hoveredTargets=[]}_onDrop(t){const{target:e,targets:n}=this.findDragTargets(t),r=this._basicEventHandler("drop:before",V({e:t,target:e,subTargets:n,dragSource:this._dragSource},Oo(this,t)));r.didDrop=!1,r.dropTarget=void 0,this._basicEventHandler("drop",r),this.fire("drop:after",r)}_onContextMenu(t){const e=this.findTarget(t),n=this.targets||[],r=this._basicEventHandler("contextmenu:before",{e:t,target:e,subTargets:n});return this.stopContextMenu&&qx(t),this._basicEventHandler("contextmenu",r),!1}_onClick(t){const e=t.detail;e>3||e<2||(this._cacheTransformEventData(t),e==2&&t.type==="dblclick"&&this._handleEvent(t,"dblclick"),e==3&&this._handleEvent(t,"tripleclick"),this._resetTransformEventData())}getPointerId(t){const e=t.changedTouches;return e?e[0]&&e[0].identifier:this.enablePointerEvents?t.pointerId:-1}_isMainEvent(t){return t.isPrimary===!0||t.isPrimary!==!1&&(t.type==="touchend"&&t.touches.length===0||!t.changedTouches||t.changedTouches[0].identifier===this.mainTouchId)}_onTouchStart(t){let e=!this.allowTouchScrolling;const n=this._activeObject;this.mainTouchId===void 0&&(this.mainTouchId=this.getPointerId(t)),this.__onMouseDown(t),(this.isDrawingMode||n&&this._target===n)&&(e=!0),e&&t.preventDefault(),this._resetTransformEventData();const r=this.upperCanvasEl,i=this._getEventPrefix(),o=Ts(r);Yr(o,"touchend",this._onTouchEnd,Un),e&&Yr(o,"touchmove",this._onMouseMove,Un),ns(r,"".concat(i,"down"),this._onMouseDown)}_onMouseDown(t){this.__onMouseDown(t),this._resetTransformEventData();const e=this.upperCanvasEl,n=this._getEventPrefix();ns(e,"".concat(n,"move"),this._onMouseMove,Un);const r=Ts(e);Yr(r,"".concat(n,"up"),this._onMouseUp),Yr(r,"".concat(n,"move"),this._onMouseMove,Un)}_onTouchEnd(t){if(t.touches.length>0)return;this.__onMouseUp(t),this._resetTransformEventData(),delete this.mainTouchId;const e=this._getEventPrefix(),n=Ts(this.upperCanvasEl);ns(n,"touchend",this._onTouchEnd,Un),ns(n,"touchmove",this._onMouseMove,Un),this._willAddMouseDown&&clearTimeout(this._willAddMouseDown),this._willAddMouseDown=setTimeout((()=>{Yr(this.upperCanvasEl,"".concat(e,"down"),this._onMouseDown),this._willAddMouseDown=0}),400)}_onMouseUp(t){this.__onMouseUp(t),this._resetTransformEventData();const e=this.upperCanvasEl,n=this._getEventPrefix();if(this._isMainEvent(t)){const r=Ts(this.upperCanvasEl);ns(r,"".concat(n,"up"),this._onMouseUp),ns(r,"".concat(n,"move"),this._onMouseMove,Un),Yr(e,"".concat(n,"move"),this._onMouseMove,Un)}}_onMouseMove(t){const e=this.getActiveObject();!this.allowTouchScrolling&&(!e||!e.shouldStartDragging(t))&&t.preventDefault&&t.preventDefault(),this.__onMouseMove(t)}_onResize(){this.calcOffset(),this._resetTransformEventData()}_shouldRender(t){const e=this.getActiveObject();return!!e!=!!t||e&&t&&e!==t}__onMouseUp(t){var e;this._cacheTransformEventData(t),this._handleEvent(t,"up:before");const n=this._currentTransform,r=this._isClick,i=this._target,{button:o}=t;if(o)return(this.fireMiddleClick&&o===1||this.fireRightClick&&o===2)&&this._handleEvent(t,"up"),void this._resetTransformEventData();if(this.isDrawingMode&&this._isCurrentlyDrawing)return void this._onMouseUpInDrawingMode(t);if(!this._isMainEvent(t))return;let a,l,c=!1;if(n&&(this._finalizeCurrentTransform(t),c=n.actionPerformed),!r){const u=i===this._activeObject;this.handleSelection(t),c||(c=this._shouldRender(i)||!u&&i===this._activeObject)}if(i){const u=i.findControl(this.getViewportPoint(t),Ng(t)),{key:h,control:d}=u||{};if(l=h,i.selectable&&i!==this._activeObject&&i.activeOn==="up")this.setActiveObject(i,t),c=!0;else if(d){const p=d.getMouseUpHandler(t,i,d);p&&(a=this.getScenePoint(t),p.call(d,t,n,a.x,a.y))}i.isMoving=!1}if(n&&(n.target!==i||n.corner!==l)){const u=n.target&&n.target.controls[n.corner],h=u&&u.getMouseUpHandler(t,n.target,u);a=a||this.getScenePoint(t),h&&h.call(u,t,n,a.x,a.y)}this._setCursorFromEvent(t,i),this._handleEvent(t,"up"),this._groupSelector=null,this._currentTransform=null,i&&(i.__corner=void 0),c?this.requestRenderAll():r||(e=this._activeObject)!==null&&e!==void 0&&e.isEditing||this.renderTop()}_basicEventHandler(t,e){const{target:n,subTargets:r=[]}=e;this.fire(t,e),n&&n.fire(t,e);for(let i=0;i<r.length;i++)r[i]!==n&&r[i].fire(t,e);return e}_handleEvent(t,e,n){const r=this._target,i=this.targets||[],o=V(V(V({e:t,target:r,subTargets:i},Oo(this,t)),{},{transform:this._currentTransform},e==="up:before"||e==="up"?{isClick:this._isClick,currentTarget:this.findTarget(t),currentSubTargets:this.targets}:{}),e==="down:before"||e==="down"?n:{});this.fire("mouse:".concat(e),o),r&&r.fire("mouse".concat(e),o);for(let a=0;a<i.length;a++)i[a]!==r&&i[a].fire("mouse".concat(e),o)}_onMouseDownInDrawingMode(t){this._isCurrentlyDrawing=!0,this.getActiveObject()&&(this.discardActiveObject(t),this.requestRenderAll());const e=this.getScenePoint(t);this.freeDrawingBrush&&this.freeDrawingBrush.onMouseDown(e,{e:t,pointer:e}),this._handleEvent(t,"down",{alreadySelected:!1})}_onMouseMoveInDrawingMode(t){if(this._isCurrentlyDrawing){const e=this.getScenePoint(t);this.freeDrawingBrush&&this.freeDrawingBrush.onMouseMove(e,{e:t,pointer:e})}this.setCursor(this.freeDrawingCursor),this._handleEvent(t,"move")}_onMouseUpInDrawingMode(t){const e=this.getScenePoint(t);this.freeDrawingBrush?this._isCurrentlyDrawing=!!this.freeDrawingBrush.onMouseUp({e:t,pointer:e}):this._isCurrentlyDrawing=!1,this._handleEvent(t,"up")}__onMouseDown(t){this._isClick=!0,this._cacheTransformEventData(t),this._handleEvent(t,"down:before");let e=this._target,n=!!e&&e===this._activeObject;const{button:r}=t;if(r)return(this.fireMiddleClick&&r===1||this.fireRightClick&&r===2)&&this._handleEvent(t,"down",{alreadySelected:n}),void this._resetTransformEventData();if(this.isDrawingMode)return void this._onMouseDownInDrawingMode(t);if(!this._isMainEvent(t)||this._currentTransform)return;let i=this._shouldRender(e),o=!1;if(this.handleMultiSelection(t,e)?(e=this._activeObject,o=!0,i=!0):this._shouldClearSelection(t,e)&&this.discardActiveObject(t),this.selection&&(!e||!e.selectable&&!e.isEditing&&e!==this._activeObject)){const a=this.getScenePoint(t);this._groupSelector={x:a.x,y:a.y,deltaY:0,deltaX:0}}if(n=!!e&&e===this._activeObject,e){e.selectable&&e.activeOn==="down"&&this.setActiveObject(e,t);const a=e.findControl(this.getViewportPoint(t),Ng(t));if(e===this._activeObject&&(a||!o)){this._setupCurrentTransform(t,e,n);const l=a?a.control:void 0,c=this.getScenePoint(t),u=l&&l.getMouseDownHandler(t,e,l);u&&u.call(l,t,this._currentTransform,c.x,c.y)}}i&&(this._objectsToRender=void 0),this._handleEvent(t,"down",{alreadySelected:n}),i&&this.requestRenderAll()}_resetTransformEventData(){this._target=this._pointer=this._absolutePointer=void 0}_cacheTransformEventData(t){this._resetTransformEventData(),this._pointer=this.getViewportPoint(t),this._absolutePointer=Go(this._pointer,void 0,this.viewportTransform),this._target=this._currentTransform?this._currentTransform.target:this.findTarget(t)}__onMouseMove(t){if(this._isClick=!1,this._cacheTransformEventData(t),this._handleEvent(t,"move:before"),this.isDrawingMode)return void this._onMouseMoveInDrawingMode(t);if(!this._isMainEvent(t))return;const e=this._groupSelector;if(e){const n=this.getScenePoint(t);e.deltaX=n.x-e.x,e.deltaY=n.y-e.y,this.renderTop()}else if(this._currentTransform)this._transformObject(t);else{const n=this.findTarget(t);this._setCursorFromEvent(t,n),this._fireOverOutEvents(t,n)}this.textEditingManager.onMouseMove(t),this._handleEvent(t,"move"),this._resetTransformEventData()}_fireOverOutEvents(t,e){const n=this._hoveredTarget,r=this._hoveredTargets,i=this.targets,o=Math.max(r.length,i.length);this.fireSyntheticInOutEvents("mouse",{e:t,target:e,oldTarget:n,fireCanvas:!0});for(let a=0;a<o;a++)i[a]===e||r[a]&&r[a]===n||this.fireSyntheticInOutEvents("mouse",{e:t,target:i[a],oldTarget:r[a]});this._hoveredTarget=e,this._hoveredTargets=this.targets.concat()}_fireEnterLeaveEvents(t,e){const n=this._draggedoverTarget,r=this._hoveredTargets,i=this.targets,o=Math.max(r.length,i.length);this.fireSyntheticInOutEvents("drag",V(V({},e),{},{target:t,oldTarget:n,fireCanvas:!0}));for(let a=0;a<o;a++)this.fireSyntheticInOutEvents("drag",V(V({},e),{},{target:i[a],oldTarget:r[a]}));this._draggedoverTarget=t}fireSyntheticInOutEvents(t,e){let{target:n,oldTarget:r,fireCanvas:i,e:o}=e,a=se(e,iD);const{targetIn:l,targetOut:c,canvasIn:u,canvasOut:h}=oD[t],d=r!==n;if(r&&d){const p=V(V({},a),{},{e:o,target:r,nextTarget:n},Oo(this,o));i&&this.fire(h,p),r.fire(c,p)}if(n&&d){const p=V(V({},a),{},{e:o,target:n,previousTarget:r},Oo(this,o));i&&this.fire(u,p),n.fire(l,p)}}__onMouseWheel(t){this._cacheTransformEventData(t),this._handleEvent(t,"wheel"),this._resetTransformEventData()}_transformObject(t){const e=this.getScenePoint(t),n=this._currentTransform,r=n.target,i=r.group?Go(e,void 0,r.group.calcTransformMatrix()):e;n.shiftKey=t.shiftKey,n.altKey=!!this.centeredKey&&t[this.centeredKey],this._performTransformAction(t,n,i),n.actionPerformed&&this.requestRenderAll()}_performTransformAction(t,e,n){const{action:r,actionHandler:i,target:o}=e,a=!!i&&i(t,e,n.x,n.y);a&&o.setCoords(),r==="drag"&&a&&(e.target.isMoving=!0,this.setCursor(e.target.moveCursor||this.moveCursor)),e.actionPerformed=e.actionPerformed||a}_setCursorFromEvent(t,e){if(!e)return void this.setCursor(this.defaultCursor);let n=e.hoverCursor||this.hoverCursor;const r=Pi(this._activeObject)?this._activeObject:null,i=(!r||e.group!==r)&&e.findControl(this.getViewportPoint(t));if(i){const o=i.control;this.setCursor(o.cursorStyleHandler(t,o,e))}else e.subTargetCheck&&this.targets.concat().reverse().map((o=>{n=o.hoverCursor||n})),this.setCursor(n)}handleMultiSelection(t,e){const n=this._activeObject,r=Pi(n);if(n&&this._isSelectionKeyPressed(t)&&this.selection&&e&&e.selectable&&(n!==e||r)&&(r||!e.isDescendantOf(n)&&!n.isDescendantOf(e))&&!e.onSelect({e:t})&&!n.getActiveControl()){if(r){const i=n.getObjects();if(e===n){const o=this.getViewportPoint(t);if(!(e=this.searchPossibleTargets(i,o)||this.searchPossibleTargets(this._objects,o))||!e.selectable)return!1}e.group===n?(n.remove(e),this._hoveredTarget=e,this._hoveredTargets=[...this.targets],n.size()===1&&this._setActiveObject(n.item(0),t)):(n.multiSelectAdd(e),this._hoveredTarget=n,this._hoveredTargets=[...this.targets]),this._fireSelectionEvents(i,t)}else{n.isEditing&&n.exitEditing();const i=new(ut.getClass("ActiveSelection"))([],{canvas:this});i.multiSelectAdd(n,e),this._hoveredTarget=i,this._setActiveObject(i,t),this._fireSelectionEvents([n],t)}return!0}return!1}handleSelection(t){if(!this.selection||!this._groupSelector)return!1;const{x:e,y:n,deltaX:r,deltaY:i}=this._groupSelector,o=new q(e,n),a=o.add(new q(r,i)),l=o.min(a),c=o.max(a).subtract(l),u=this.collectObjects({left:l.x,top:l.y,width:c.x,height:c.y},{includeIntersecting:!this.selectionFullyContained}),h=o.eq(a)?u[0]?[u[0]]:[]:u.length>1?u.filter((d=>!d.onSelect({e:t}))).reverse():u;if(h.length===1)this.setActiveObject(h[0],t);else if(h.length>1){const d=ut.getClass("ActiveSelection");this.setActiveObject(new d(h,{canvas:this}),t)}return this._groupSelector=null,!0}clear(){this.textEditingManager.clear(),super.clear()}destroy(){this.removeListeners(),this.textEditingManager.dispose(),super.destroy()}}const SS={x1:0,y1:0,x2:0,y2:0},aD=V(V({},SS),{},{r1:0,r2:0}),Wo=(s,t)=>isNaN(s)&&typeof t=="number"?t:s;function CS(s){return s&&/%$/.test(s)&&Number.isFinite(parseFloat(s))}function TS(s,t){const e=typeof s=="number"?s:typeof s=="string"?parseFloat(s)/(CS(s)?100:1):NaN;return Jo(0,Wo(e,t),1)}const lD=/\s*;\s*/,cD=/\s*:\s*/;function uD(s,t){let e,n;const r=s.getAttribute("style");if(r){const o=r.split(lD);o[o.length-1]===""&&o.pop();for(let a=o.length;a--;){const[l,c]=o[a].split(cD).map((u=>u.trim()));l==="stop-color"?e=c:l==="stop-opacity"&&(n=c)}}const i=new Gt(e||s.getAttribute("stop-color")||"rgb(0,0,0)");return{offset:TS(s.getAttribute("offset"),0),color:i.toRgb(),opacity:Wo(parseFloat(n||s.getAttribute("stop-opacity")||""),1)*i.getAlpha()*t}}function hD(s,t){const e=[],n=s.getElementsByTagName("stop"),r=TS(t,1);for(let i=n.length;i--;)e.push(uD(n[i],r));return e}function kS(s){return s.nodeName==="linearGradient"||s.nodeName==="LINEARGRADIENT"?"linear":"radial"}function IS(s){return s.getAttribute("gradientUnits")==="userSpaceOnUse"?"pixels":"percentage"}function gs(s,t){return s.getAttribute(t)}function dD(s,t){return(function(e,n){let r,{width:i,height:o,gradientUnits:a}=n;return Object.entries(e).reduce(((l,c)=>{let[u,h]=c;if(h==="Infinity")r=1;else if(h==="-Infinity")r=0;else{const d=typeof h=="string";r=d?parseFloat(h):h,d&&CS(h)&&(r*=.01,a==="pixels"&&(u!=="x1"&&u!=="x2"&&u!=="r2"||(r*=i),u!=="y1"&&u!=="y2"||(r*=o)))}return l[u]=r,l}),{})})(kS(s)==="linear"?(function(e){return{x1:gs(e,"x1")||0,y1:gs(e,"y1")||0,x2:gs(e,"x2")||"100%",y2:gs(e,"y2")||0}})(s):(function(e){return{x1:gs(e,"fx")||gs(e,"cx")||"50%",y1:gs(e,"fy")||gs(e,"cy")||"50%",r1:0,x2:gs(e,"cx")||"50%",y2:gs(e,"cy")||"50%",r2:gs(e,"r")||"50%"}})(s),V(V({},t),{},{gradientUnits:IS(s)}))}class gh{constructor(t){const{type:e="linear",gradientUnits:n="pixels",coords:r={},colorStops:i=[],offsetX:o=0,offsetY:a=0,gradientTransform:l,id:c}=t||{};Object.assign(this,{type:e,gradientUnits:n,coords:V(V({},e==="radial"?aD:SS),r),colorStops:i,offsetX:o,offsetY:a,gradientTransform:l,id:c?"".concat(c,"_").concat(ii()):ii()})}addColorStop(t){for(const e in t){const n=new Gt(t[e]);this.colorStops.push({offset:parseFloat(e),color:n.toRgb(),opacity:n.getAlpha()})}return this}toObject(t){return V(V({},ga(this,t)),{},{type:this.type,coords:V({},this.coords),colorStops:this.colorStops.map((e=>V({},e))),offsetX:this.offsetX,offsetY:this.offsetY,gradientUnits:this.gradientUnits,gradientTransform:this.gradientTransform?[...this.gradientTransform]:void 0})}toSVG(t){let{additionalTransform:e}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const n=[],r=this.gradientTransform?this.gradientTransform.concat():yn.concat(),i=this.gradientUnits==="pixels"?"userSpaceOnUse":"objectBoundingBox",o=this.colorStops.map((h=>V({},h))).sort(((h,d)=>h.offset-d.offset));let a=-this.offsetX,l=-this.offsetY;var c;i==="objectBoundingBox"?(a/=t.width,l/=t.height):(a+=t.width/2,l+=t.height/2),(c=t)&&typeof c._renderPathCommands=="function"&&this.gradientUnits!=="percentage"&&(a-=t.pathOffset.x,l-=t.pathOffset.y),r[4]-=a,r[5]-=l;const u=['id="SVGID_'.concat(this.id,'"'),'gradientUnits="'.concat(i,'"'),'gradientTransform="'.concat(e?e+" ":"").concat(Ql(r),'"'),""].join(" ");if(this.type==="linear"){const{x1:h,y1:d,x2:p,y2:f}=this.coords;n.push("<linearGradient ",u,' x1="',h,'" y1="',d,'" x2="',p,'" y2="',f,`">
`)}else if(this.type==="radial"){const{x1:h,y1:d,x2:p,y2:f,r1:m,r2:g}=this.coords,y=m>g;n.push("<radialGradient ",u,' cx="',y?h:p,'" cy="',y?d:f,'" r="',y?m:g,'" fx="',y?p:h,'" fy="',y?f:d,`">
`),y&&(o.reverse(),o.forEach((w=>{w.offset=1-w.offset})));const b=Math.min(m,g);if(b>0){const w=b/Math.max(m,g);o.forEach((x=>{x.offset+=w*(1-x.offset)}))}}return o.forEach((h=>{let{color:d,offset:p,opacity:f}=h;n.push("<stop ",'offset="',100*p+"%",'" style="stop-color:',d,f!==void 0?";stop-opacity: "+f:";",`"/>
`)})),n.push(this.type==="linear"?"</linearGradient>":"</radialGradient>",`
`),n.join("")}toLive(t){const{x1:e,y1:n,x2:r,y2:i,r1:o,r2:a}=this.coords,l=this.type==="linear"?t.createLinearGradient(e,n,r,i):t.createRadialGradient(e,n,o,r,i,a);return this.colorStops.forEach((c=>{let{color:u,opacity:h,offset:d}=c;l.addColorStop(d,h!==void 0?new Gt(u).setAlpha(h).toRgba():u)})),l}static async fromObject(t){const{colorStops:e,gradientTransform:n}=t;return new this(V(V({},t),{},{colorStops:e?e.map((r=>V({},r))):void 0,gradientTransform:n?[...n]:void 0}))}static fromElement(t,e,n){const r=IS(t),i=e._findCenterFromElement();return new this(V({id:t.getAttribute("id")||void 0,type:kS(t),coords:dD(t,{width:n.viewBoxWidth||n.width,height:n.viewBoxHeight||n.height}),colorStops:hD(t,n.opacity),gradientUnits:r,gradientTransform:Dg(t.getAttribute("gradientTransform")||"")},r==="pixels"?{offsetX:e.width/2-i.x,offsetY:e.height/2-i.y}:{offsetX:0,offsetY:0}))}}z(gh,"type","Gradient"),ut.setClass(gh,"gradient"),ut.setClass(gh,"linear"),ut.setClass(gh,"radial");const pD=["type","source","patternTransform"];class qm{get type(){return"pattern"}set type(t){ri("warn","Setting type has no effect",t)}constructor(t){z(this,"repeat","repeat"),z(this,"offsetX",0),z(this,"offsetY",0),z(this,"crossOrigin",""),this.id=ii(),Object.assign(this,t)}isImageSource(){return!!this.source&&typeof this.source.src=="string"}isCanvasSource(){return!!this.source&&!!this.source.toDataURL}sourceToString(){return this.isImageSource()?this.source.src:this.isCanvasSource()?this.source.toDataURL():""}toLive(t){return this.source&&(!this.isImageSource()||this.source.complete&&this.source.naturalWidth!==0&&this.source.naturalHeight!==0)?t.createPattern(this.source,this.repeat):null}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];const{repeat:e,crossOrigin:n}=this;return V(V({},ga(this,t)),{},{type:"pattern",source:this.sourceToString(),repeat:e,crossOrigin:n,offsetX:Qt(this.offsetX,Mt.NUM_FRACTION_DIGITS),offsetY:Qt(this.offsetY,Mt.NUM_FRACTION_DIGITS),patternTransform:this.patternTransform?[...this.patternTransform]:null})}toSVG(t){let{width:e,height:n}=t;const{source:r,repeat:i,id:o}=this,a=Wo(this.offsetX/e,0),l=Wo(this.offsetY/n,0),c=i==="repeat-y"||i==="no-repeat"?1+Math.abs(a||0):Wo(r.width/e,0),u=i==="repeat-x"||i==="no-repeat"?1+Math.abs(l||0):Wo(r.height/n,0);return['<pattern id="SVGID_'.concat(o,'" x="').concat(a,'" y="').concat(l,'" width="').concat(c,'" height="').concat(u,'">'),'<image x="0" y="0" width="'.concat(r.width,'" height="').concat(r.height,'" xlink:href="').concat(this.sourceToString(),'"></image>'),"</pattern>",""].join(`
`)}static async fromObject(t,e){let{type:n,source:r,patternTransform:i}=t,o=se(t,pD);const a=await ud(r,V(V({},e),{},{crossOrigin:o.crossOrigin}));return new this(V(V({},o),{},{patternTransform:i&&i.slice(0),source:a}))}}z(qm,"type","Pattern"),ut.setClass(qm),ut.setClass(qm,"pattern");const fD=["path","left","top"],mD=["d"];class Li extends an{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},{path:n,left:r,top:i}=e,o=se(e,fD);super(),Object.assign(this,Li.ownDefaults),this.setOptions(o),this._setPath(t||[],!0),typeof r=="number"&&this.set(Vt,r),typeof i=="number"&&this.set(An,i)}_setPath(t,e){this.path=HE(Array.isArray(t)?t:eD(t)),this.setBoundingBox(e)}_findCenterFromElement(){const t=this._calcBoundsFromPath();return new q(t.left+t.width/2,t.top+t.height/2)}_renderPathCommands(t){const e=-this.pathOffset.x,n=-this.pathOffset.y;t.beginPath();for(const r of this.path)switch(r[0]){case"L":t.lineTo(r[1]+e,r[2]+n);break;case"M":t.moveTo(r[1]+e,r[2]+n);break;case"C":t.bezierCurveTo(r[1]+e,r[2]+n,r[3]+e,r[4]+n,r[5]+e,r[6]+n);break;case"Q":t.quadraticCurveTo(r[1]+e,r[2]+n,r[3]+e,r[4]+n);break;case"Z":t.closePath()}}_render(t){this._renderPathCommands(t),this._renderPaintInOrder(t)}toString(){return"#<Path (".concat(this.complexity(),'): { "top": ').concat(this.top,', "left": ').concat(this.left," }>")}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return V(V({},super.toObject(t)),{},{path:this.path.map((e=>e.slice()))})}toDatalessObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];const e=this.toObject(t);return this.sourcePath&&(delete e.path,e.sourcePath=this.sourcePath),e}_toSVG(){const t=nD(this.path,Mt.NUM_FRACTION_DIGITS);return["<path ","COMMON_PARTS",'d="'.concat(t,`" stroke-linecap="round" />
`)]}_getOffsetTransform(){const t=Mt.NUM_FRACTION_DIGITS;return" translate(".concat(Qt(-this.pathOffset.x,t),", ").concat(Qt(-this.pathOffset.y,t),")")}toClipPathSVG(t){const e=this._getOffsetTransform();return"	"+this._createBaseClipPathSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})}toSVG(t){const e=this._getOffsetTransform();return this._createBaseSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})}complexity(){return this.path.length}setDimensions(){this.setBoundingBox()}setBoundingBox(t){const{width:e,height:n,pathOffset:r}=this._calcDimensions();this.set({width:e,height:n,pathOffset:r}),t&&this.setPositionByOrigin(r,Et,Et)}_calcBoundsFromPath(){const t=[];let e=0,n=0,r=0,i=0;for(const o of this.path)switch(o[0]){case"L":r=o[1],i=o[2],t.push({x:e,y:n},{x:r,y:i});break;case"M":r=o[1],i=o[2],e=r,n=i;break;case"C":t.push(...ww(r,i,o[1],o[2],o[3],o[4],o[5],o[6])),r=o[5],i=o[6];break;case"Q":t.push(...ww(r,i,o[1],o[2],o[1],o[2],o[3],o[4])),r=o[3],i=o[4];break;case"Z":r=e,i=n}return vr(t)}_calcDimensions(){const t=this._calcBoundsFromPath();return V(V({},t),{},{pathOffset:new q(t.left+t.width/2,t.top+t.height/2)})}static fromObject(t){return this._fromObject(t,{extraParam:"path"})}static async fromElement(t,e,n){const r=Fr(t,this.ATTRIBUTE_NAMES,n),{d:i}=r;return new this(i,V(V(V({},se(r,mD)),e),{},{left:void 0,top:void 0}))}}z(Li,"type","Path"),z(Li,"cacheProperties",[...Rr,"path","fillRule"]),z(Li,"ATTRIBUTE_NAMES",[...xi,"d"]),ut.setClass(Li),ut.setSVGClass(Li);const gD=["left","top","radius"],NS=["radius","startAngle","endAngle","counterClockwise"];class dr extends an{static getDefaults(){return V(V({},super.getDefaults()),dr.ownDefaults)}constructor(t){super(),Object.assign(this,dr.ownDefaults),this.setOptions(t)}_set(t,e){return super._set(t,e),t==="radius"&&this.setRadius(e),this}_render(t){t.beginPath(),t.arc(0,0,this.radius,Se(this.startAngle),Se(this.endAngle),this.counterClockwise),this._renderPaintInOrder(t)}getRadiusX(){return this.get("radius")*this.get(Fn)}getRadiusY(){return this.get("radius")*this.get(us)}setRadius(t){this.radius=t,this.set({width:2*t,height:2*t})}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return super.toObject([...NS,...t])}_toSVG(){const t=(this.endAngle-this.startAngle)%360;if(t===0)return["<circle ","COMMON_PARTS",'cx="0" cy="0" ','r="',"".concat(this.radius),`" />
`];{const{radius:e}=this,n=Se(this.startAngle),r=Se(this.endAngle),i=Tr(n)*e,o=kr(n)*e,a=Tr(r)*e,l=kr(r)*e,c=t>180?1:0,u=this.counterClockwise?0:1;return['<path d="M '.concat(i," ").concat(o," A ").concat(e," ").concat(e," 0 ").concat(c," ").concat(u," ").concat(a," ").concat(l,'" '),"COMMON_PARTS",` />
`]}}static async fromElement(t,e,n){const r=Fr(t,this.ATTRIBUTE_NAMES,n),{left:i=0,top:o=0,radius:a=0}=r;return new this(V(V({},se(r,gD)),{},{radius:a,left:i-a,top:o-a}))}static fromObject(t){return super._fromObject(t)}}z(dr,"type","Circle"),z(dr,"cacheProperties",[...Rr,...NS]),z(dr,"ownDefaults",{radius:0,startAngle:0,endAngle:360,counterClockwise:!1}),z(dr,"ATTRIBUTE_NAMES",["cx","cy","r",...xi]),ut.setClass(dr),ut.setSVGClass(dr);const yD=["x1","y1","x2","y2"],bD=["x1","y1","x2","y2"],Pg=["x1","x2","y1","y2"];class Mi extends an{constructor(){let[t,e,n,r]=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[0,0,0,0],i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),Object.assign(this,Mi.ownDefaults),this.setOptions(i),this.x1=t,this.x2=n,this.y1=e,this.y2=r,this._setWidthHeight();const{left:o,top:a}=i;typeof o=="number"&&this.set(Vt,o),typeof a=="number"&&this.set(An,a)}_setWidthHeight(){const{x1:t,y1:e,x2:n,y2:r}=this;this.width=Math.abs(n-t),this.height=Math.abs(r-e);const{left:i,top:o,width:a,height:l}=vr([{x:t,y:e},{x:n,y:r}]),c=new q(i+a/2,o+l/2);this.setPositionByOrigin(c,Et,Et)}_set(t,e){return super._set(t,e),Pg.includes(t)&&this._setWidthHeight(),this}_render(t){t.beginPath();const e=this.calcLinePoints();t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2),t.lineWidth=this.strokeWidth;const n=t.strokeStyle;var r;as(this.stroke)?t.strokeStyle=this.stroke.toLive(t):t.strokeStyle=(r=this.stroke)!==null&&r!==void 0?r:t.fillStyle,this.stroke&&this._renderStroke(t),t.strokeStyle=n}_findCenterFromElement(){return new q((this.x1+this.x2)/2,(this.y1+this.y2)/2)}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return V(V({},super.toObject(t)),this.calcLinePoints())}_getNonTransformedDimensions(){const t=super._getNonTransformedDimensions();return this.strokeLineCap==="butt"&&(this.width===0&&(t.y-=this.strokeWidth),this.height===0&&(t.x-=this.strokeWidth)),t}calcLinePoints(){const{x1:t,x2:e,y1:n,y2:r,width:i,height:o}=this,a=t<=e?-1:1,l=n<=r?-1:1;return{x1:a*i/2,x2:a*-i/2,y1:l*o/2,y2:l*-o/2}}_toSVG(){const{x1:t,x2:e,y1:n,y2:r}=this.calcLinePoints();return["<line ","COMMON_PARTS",'x1="'.concat(t,'" y1="').concat(n,'" x2="').concat(e,'" y2="').concat(r,`" />
`)]}static async fromElement(t,e,n){const r=Fr(t,this.ATTRIBUTE_NAMES,n),{x1:i=0,y1:o=0,x2:a=0,y2:l=0}=r;return new this([i,o,a,l],se(r,yD))}static fromObject(t){let{x1:e,y1:n,x2:r,y2:i}=t,o=se(t,bD);return this._fromObject(V(V({},o),{},{points:[e,n,r,i]}),{extraParam:"points"})}}z(Mi,"type","Line"),z(Mi,"cacheProperties",[...Rr,...Pg]),z(Mi,"ATTRIBUTE_NAMES",xi.concat(Pg)),ut.setClass(Mi),ut.setSVGClass(Mi);class Gi extends an{static getDefaults(){return V(V({},super.getDefaults()),Gi.ownDefaults)}constructor(t){super(),Object.assign(this,Gi.ownDefaults),this.setOptions(t)}_render(t){const e=this.width/2,n=this.height/2;t.beginPath(),t.moveTo(-e,n),t.lineTo(0,-n),t.lineTo(e,n),t.closePath(),this._renderPaintInOrder(t)}_toSVG(){const t=this.width/2,e=this.height/2;return["<polygon ","COMMON_PARTS",'points="',"".concat(-t," ").concat(e,",0 ").concat(-e,",").concat(t," ").concat(e),'" />']}}z(Gi,"type","Triangle"),z(Gi,"ownDefaults",{width:100,height:100}),ut.setClass(Gi),ut.setSVGClass(Gi);const $S=["rx","ry"];class pr extends an{static getDefaults(){return V(V({},super.getDefaults()),pr.ownDefaults)}constructor(t){super(),Object.assign(this,pr.ownDefaults),this.setOptions(t)}_set(t,e){switch(super._set(t,e),t){case"rx":this.rx=e,this.set("width",2*e);break;case"ry":this.ry=e,this.set("height",2*e)}return this}getRx(){return this.get("rx")*this.get(Fn)}getRy(){return this.get("ry")*this.get(us)}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return super.toObject([...$S,...t])}_toSVG(){return["<ellipse ","COMMON_PARTS",'cx="0" cy="0" rx="'.concat(this.rx,'" ry="').concat(this.ry,`" />
`)]}_render(t){t.beginPath(),t.save(),t.transform(1,0,0,this.ry/this.rx,0,0),t.arc(0,0,this.rx,0,Cd,!1),t.restore(),this._renderPaintInOrder(t)}static async fromElement(t,e,n){const r=Fr(t,this.ATTRIBUTE_NAMES,n);return r.left=(r.left||0)-r.rx,r.top=(r.top||0)-r.ry,new this(r)}}function xD(s){if(!s)return[];const t=s.replace(/,/g," ").trim().split(/\s+/),e=[];for(let n=0;n<t.length;n+=2)e.push({x:parseFloat(t[n]),y:parseFloat(t[n+1])});return e}z(pr,"type","Ellipse"),z(pr,"cacheProperties",[...Rr,...$S]),z(pr,"ownDefaults",{rx:0,ry:0}),z(pr,"ATTRIBUTE_NAMES",[...xi,"cx","cy","rx","ry"]),ut.setClass(pr),ut.setSVGClass(pr);const wD=["left","top"],_S={exactBoundingBox:!1};class ws extends an{static getDefaults(){return V(V({},super.getDefaults()),ws.ownDefaults)}constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),z(this,"strokeDiff",void 0),Object.assign(this,ws.ownDefaults),this.setOptions(e),this.points=t;const{left:n,top:r}=e;this.initialized=!0,this.setBoundingBox(!0),typeof n=="number"&&this.set(Vt,n),typeof r=="number"&&this.set(An,r)}isOpen(){return!0}_projectStrokeOnPoints(t){return cE(this.points,t,this.isOpen())}_calcDimensions(t){t=V({scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:this.strokeMiterLimit,strokeUniform:this.strokeUniform,strokeWidth:this.strokeWidth},t||{});const e=this.exactBoundingBox?this._projectStrokeOnPoints(t).map((c=>c.projectedPoint)):this.points;if(e.length===0)return{left:0,top:0,width:0,height:0,pathOffset:new q,strokeOffset:new q,strokeDiff:new q};const n=vr(e),r=pp(V(V({},t),{},{scaleX:1,scaleY:1})),i=vr(this.points.map((c=>Nn(c,r,!0)))),o=new q(this.scaleX,this.scaleY);let a=n.left+n.width/2,l=n.top+n.height/2;return this.exactBoundingBox&&(a-=l*Math.tan(Se(this.skewX)),l-=a*Math.tan(Se(this.skewY))),V(V({},n),{},{pathOffset:new q(a,l),strokeOffset:new q(i.left,i.top).subtract(new q(n.left,n.top)).multiply(o),strokeDiff:new q(n.width,n.height).subtract(new q(i.width,i.height)).multiply(o)})}_findCenterFromElement(){const t=vr(this.points);return new q(t.left+t.width/2,t.top+t.height/2)}setDimensions(){this.setBoundingBox()}setBoundingBox(t){const{left:e,top:n,width:r,height:i,pathOffset:o,strokeOffset:a,strokeDiff:l}=this._calcDimensions();this.set({width:r,height:i,pathOffset:o,strokeOffset:a,strokeDiff:l}),t&&this.setPositionByOrigin(new q(e+r/2,n+i/2),Et,Et)}isStrokeAccountedForInDimensions(){return this.exactBoundingBox}_getNonTransformedDimensions(){return this.exactBoundingBox?new q(this.width,this.height):super._getNonTransformedDimensions()}_getTransformedDimensions(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(this.exactBoundingBox){let o;if(Object.keys(t).some((a=>this.strokeUniform||this.constructor.layoutProperties.includes(a)))){var e,n;const{width:a,height:l}=this._calcDimensions(t);o=new q((e=t.width)!==null&&e!==void 0?e:a,(n=t.height)!==null&&n!==void 0?n:l)}else{var r,i;o=new q((r=t.width)!==null&&r!==void 0?r:this.width,(i=t.height)!==null&&i!==void 0?i:this.height)}return o.multiply(new q(t.scaleX||this.scaleX,t.scaleY||this.scaleY))}return super._getTransformedDimensions(t)}_set(t,e){const n=this.initialized&&this[t]!==e,r=super._set(t,e);return this.exactBoundingBox&&n&&((t===Fn||t===us)&&this.strokeUniform&&this.constructor.layoutProperties.includes("strokeUniform")||this.constructor.layoutProperties.includes(t))&&this.setDimensions(),r}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return V(V({},super.toObject(t)),{},{points:this.points.map((e=>{let{x:n,y:r}=e;return{x:n,y:r}}))})}_toSVG(){const t=[],e=this.pathOffset.x,n=this.pathOffset.y,r=Mt.NUM_FRACTION_DIGITS;for(let i=0,o=this.points.length;i<o;i++)t.push(Qt(this.points[i].x-e,r),",",Qt(this.points[i].y-n,r)," ");return["<".concat(this.constructor.type.toLowerCase()," "),"COMMON_PARTS",'points="'.concat(t.join(""),`" />
`)]}_render(t){const e=this.points.length,n=this.pathOffset.x,r=this.pathOffset.y;if(e&&!isNaN(this.points[e-1].y)){t.beginPath(),t.moveTo(this.points[0].x-n,this.points[0].y-r);for(let i=0;i<e;i++){const o=this.points[i];t.lineTo(o.x-n,o.y-r)}!this.isOpen()&&t.closePath(),this._renderPaintInOrder(t)}}complexity(){return this.points.length}static async fromElement(t,e,n){return new this(xD(t.getAttribute("points")),V(V({},se(Fr(t,this.ATTRIBUTE_NAMES,n),wD)),e))}static fromObject(t){return this._fromObject(t,{extraParam:"points"})}}z(ws,"ownDefaults",_S),z(ws,"type","Polyline"),z(ws,"layoutProperties",[pa,fa,"strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeWidth","strokeUniform","points"]),z(ws,"cacheProperties",[...Rr,"points"]),z(ws,"ATTRIBUTE_NAMES",[...xi]),ut.setClass(ws),ut.setSVGClass(ws);class yh extends ws{isOpen(){return!1}}z(yh,"ownDefaults",_S),z(yh,"type","Polygon"),ut.setClass(yh),ut.setSVGClass(yh);class ES extends an{isEmptyStyles(t){if(!this.styles||t!==void 0&&!this.styles[t])return!0;const e=t===void 0?this.styles:{line:this.styles[t]};for(const n in e)for(const r in e[n])for(const i in e[n][r])return!1;return!0}styleHas(t,e){if(!this.styles||e!==void 0&&!this.styles[e])return!1;const n=e===void 0?this.styles:{0:this.styles[e]};for(const r in n)for(const i in n[r])if(n[r][i][t]!==void 0)return!0;return!1}cleanStyle(t){if(!this.styles)return!1;const e=this.styles;let n,r,i=0,o=!0,a=0;for(const l in e){n=0;for(const c in e[l]){const u=e[l][c]||{};i++,u[t]!==void 0?(r?u[t]!==r&&(o=!1):r=u[t],u[t]===this[t]&&delete u[t]):o=!1,Object.keys(u).length!==0?n++:delete e[l][c]}n===0&&delete e[l]}for(let l=0;l<this._textLines.length;l++)a+=this._textLines[l].length;o&&i===a&&(this[t]=r,this.removeStyle(t))}removeStyle(t){if(!this.styles)return;const e=this.styles;let n,r,i;for(r in e){for(i in n=e[r],n)delete n[i][t],Object.keys(n[i]).length===0&&delete n[i];Object.keys(n).length===0&&delete e[r]}}_extendStyles(t,e){const{lineIndex:n,charIndex:r}=this.get2DCursorLocation(t);this._getLineStyle(n)||this._setLineStyle(n);const i=zy(V(V({},this._getStyleDeclaration(n,r)),e),(o=>o!==void 0));this._setStyleDeclaration(n,r,i)}getSelectionStyles(t,e,n){const r=[];for(let i=t;i<(e||t);i++)r.push(this.getStyleAtPosition(i,n));return r}getStyleAtPosition(t,e){const{lineIndex:n,charIndex:r}=this.get2DCursorLocation(t);return e?this.getCompleteStyleDeclaration(n,r):this._getStyleDeclaration(n,r)}setSelectionStyles(t,e,n){for(let r=e;r<(n||e);r++)this._extendStyles(r,t);this._forceClearCache=!0}_getStyleDeclaration(t,e){var n;const r=this.styles&&this.styles[t];return r&&(n=r[e])!==null&&n!==void 0?n:{}}getCompleteStyleDeclaration(t,e){return V(V({},ga(this,this.constructor._styleProperties)),this._getStyleDeclaration(t,e))}_setStyleDeclaration(t,e,n){this.styles[t][e]=n}_deleteStyleDeclaration(t,e){delete this.styles[t][e]}_getLineStyle(t){return!!this.styles[t]}_setLineStyle(t){this.styles[t]={}}_deleteLineStyle(t){delete this.styles[t]}}z(ES,"_styleProperties",k_);const vD=/  +/g,SD=/"/g;function Km(s,t,e,n,r){return"		".concat((function(i,o){let{left:a,top:l,width:c,height:u}=o,h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:Mt.NUM_FRACTION_DIGITS;const d=tc(Fe,i,!1),[p,f,m,g]=[a,l,c,u].map((y=>Qt(y,h)));return"<rect ".concat(d,' x="').concat(p,'" y="').concat(f,'" width="').concat(m,'" height="').concat(g,'"></rect>')})(s,{left:t,top:e,width:n,height:r}),`
`)}const CD=["textAnchor","textDecoration","dx","dy","top","left","fontSize","strokeWidth"];let Ym;class dn extends ES{static getDefaults(){return V(V({},super.getDefaults()),dn.ownDefaults)}constructor(t,e){super(),z(this,"__charBounds",[]),Object.assign(this,dn.ownDefaults),this.setOptions(e),this.styles||(this.styles={}),this.text=t,this.initialized=!0,this.path&&this.setPathInfo(),this.initDimensions(),this.setCoords()}setPathInfo(){const t=this.path;t&&(t.segmentsInfo=vS(t.path))}_splitText(){const t=this._splitTextIntoLines(this.text);return this.textLines=t.lines,this._textLines=t.graphemeLines,this._unwrappedTextLines=t._unwrappedLines,this._text=t.graphemeText,t}initDimensions(){this._splitText(),this._clearCache(),this.dirty=!0,this.path?(this.width=this.path.width,this.height=this.path.height):(this.width=this.calcTextWidth()||this.cursorWidth||this.MIN_TEXT_WIDTH,this.height=this.calcTextHeight()),this.textAlign.includes(Ws)&&this.enlargeSpaces()}enlargeSpaces(){let t,e,n,r,i,o,a;for(let l=0,c=this._textLines.length;l<c;l++)if((this.textAlign===Ws||l!==c-1&&!this.isEndOfWrapping(l))&&(r=0,i=this._textLines[l],e=this.getLineWidth(l),e<this.width&&(a=this.textLines[l].match(this._reSpacesAndTabs)))){n=a.length,t=(this.width-e)/n;for(let u=0;u<=i.length;u++)o=this.__charBounds[l][u],this._reSpaceAndTab.test(i[u])?(o.width+=t,o.kernedWidth+=t,o.left+=r,r+=t):o.left+=r}}isEndOfWrapping(t){return t===this._textLines.length-1}missingNewlineOffset(t){return 1}get2DCursorLocation(t,e){const n=e?this._unwrappedTextLines:this._textLines;let r;for(r=0;r<n.length;r++){if(t<=n[r].length)return{lineIndex:r,charIndex:t};t-=n[r].length+this.missingNewlineOffset(r,e)}return{lineIndex:r-1,charIndex:n[r-1].length<t?n[r-1].length:t}}toString(){return"#<Text (".concat(this.complexity(),'): { "text": "').concat(this.text,'", "fontFamily": "').concat(this.fontFamily,'" }>')}_getCacheCanvasDimensions(){const t=super._getCacheCanvasDimensions(),e=this.fontSize;return t.width+=e*t.zoomX,t.height+=e*t.zoomY,t}_render(t){const e=this.path;e&&!e.isNotVisible()&&e._render(t),this._setTextStyles(t),this._renderTextLinesBackground(t),this._renderTextDecoration(t,"underline"),this._renderText(t),this._renderTextDecoration(t,"overline"),this._renderTextDecoration(t,"linethrough")}_renderText(t){this.paintFirst===Rn?(this._renderTextStroke(t),this._renderTextFill(t)):(this._renderTextFill(t),this._renderTextStroke(t))}_setTextStyles(t,e,n){if(t.textBaseline="alphabetic",this.path)switch(this.pathAlign){case Et:t.textBaseline="middle";break;case"ascender":t.textBaseline=An;break;case"descender":t.textBaseline=kg}t.font=this._getFontDeclaration(e,n)}calcTextWidth(){let t=this.getLineWidth(0);for(let e=1,n=this._textLines.length;e<n;e++){const r=this.getLineWidth(e);r>t&&(t=r)}return t}_renderTextLine(t,e,n,r,i,o){this._renderChars(t,e,n,r,i,o)}_renderTextLinesBackground(t){if(!this.textBackgroundColor&&!this.styleHas("textBackgroundColor"))return;const e=t.fillStyle,n=this._getLeftOffset();let r=this._getTopOffset();for(let i=0,o=this._textLines.length;i<o;i++){const a=this.getHeightOfLine(i);if(!this.textBackgroundColor&&!this.styleHas("textBackgroundColor",i)){r+=a;continue}const l=this._textLines[i].length,c=this._getLineLeftOffset(i);let u,h,d=0,p=0,f=this.getValueOfPropertyAt(i,0,"textBackgroundColor");const m=this.getHeightOfLineImpl(i);for(let g=0;g<l;g++){const y=this.__charBounds[i][g];h=this.getValueOfPropertyAt(i,g,"textBackgroundColor"),this.path?(t.save(),t.translate(y.renderLeft,y.renderTop),t.rotate(y.angle),t.fillStyle=h,h&&t.fillRect(-y.width/2,-m*(1-this._fontSizeFraction),y.width,m),t.restore()):h!==f?(u=n+c+p,this.direction==="rtl"&&(u=this.width-u-d),t.fillStyle=f,f&&t.fillRect(u,r,d,m),p=y.left,d=y.width,f=h):d+=y.kernedWidth}h&&!this.path&&(u=n+c+p,this.direction==="rtl"&&(u=this.width-u-d),t.fillStyle=h,t.fillRect(u,r,d,m)),r+=a}t.fillStyle=e,this._removeShadow(t)}_measureChar(t,e,n,r){const i=Hl.getFontCache(e),o=this._getFontDeclaration(e),a=n+t,l=n&&o===this._getFontDeclaration(r),c=e.fontSize/this.CACHE_FONT_SIZE;let u,h,d,p;if(n&&i.has(n)&&(d=i.get(n)),i.has(t)&&(p=u=i.get(t)),l&&i.has(a)&&(h=i.get(a),p=h-d),u===void 0||d===void 0||h===void 0){const f=(function(){return Ym||(Ym=hs({width:0,height:0}).getContext("2d")),Ym})();this._setTextStyles(f,e,!0),u===void 0&&(p=u=f.measureText(t).width,i.set(t,u)),d===void 0&&l&&n&&(d=f.measureText(n).width,i.set(n,d)),l&&h===void 0&&(h=f.measureText(a).width,i.set(a,h),p=h-d)}return{width:u*c,kernedWidth:p*c}}getHeightOfChar(t,e){return this.getValueOfPropertyAt(t,e,"fontSize")}measureLine(t){const e=this._measureLine(t);return this.charSpacing!==0&&(e.width-=this._getWidthOfCharSpacing()),e.width<0&&(e.width=0),e}_measureLine(t){let e,n,r=0;const i=this.pathSide===xe,o=this.path,a=this._textLines[t],l=a.length,c=new Array(l);this.__charBounds[t]=c;for(let u=0;u<l;u++){const h=a[u];n=this._getGraphemeBox(h,t,u,e),c[u]=n,r+=n.kernedWidth,e=h}if(c[l]={left:n?n.left+n.width:0,width:0,kernedWidth:0,height:this.fontSize,deltaY:0},o&&o.segmentsInfo){let u=0;const h=o.segmentsInfo[o.segmentsInfo.length-1].length;switch(this.textAlign){case Vt:u=i?h-r:0;break;case Et:u=(h-r)/2;break;case xe:u=i?0:h-r}u+=this.pathStartOffset*(i?-1:1);for(let d=i?l-1:0;i?d>=0:d<l;i?d--:d++)n=c[d],u>h?u%=h:u<0&&(u+=h),this._setGraphemeOnPath(u,n),u+=n.kernedWidth}return{width:r,numOfSpaces:0}}_setGraphemeOnPath(t,e){const n=t+e.kernedWidth/2,r=this.path,i=ZE(r.path,n,r.segmentsInfo);e.renderLeft=i.x-r.pathOffset.x,e.renderTop=i.y-r.pathOffset.y,e.angle=i.angle+(this.pathSide===xe?Math.PI:0)}_getGraphemeBox(t,e,n,r,i){const o=this.getCompleteStyleDeclaration(e,n),a=r?this.getCompleteStyleDeclaration(e,n-1):{},l=this._measureChar(t,o,r,a);let c,u=l.kernedWidth,h=l.width;this.charSpacing!==0&&(c=this._getWidthOfCharSpacing(),h+=c,u+=c);const d={width:h,left:0,height:o.fontSize,kernedWidth:u,deltaY:o.deltaY};if(n>0&&!i){const p=this.__charBounds[e][n-1];d.left=p.left+p.width+l.kernedWidth-l.width}return d}getHeightOfLineImpl(t){const e=this.__lineHeights;if(e[t])return e[t];let n=this.getHeightOfChar(t,0);for(let r=1,i=this._textLines[t].length;r<i;r++)n=Math.max(this.getHeightOfChar(t,r),n);return e[t]=n*this._fontSizeMult}getHeightOfLine(t){return this.getHeightOfLineImpl(t)*this.lineHeight}calcTextHeight(){let t=0;for(let e=0,n=this._textLines.length;e<n;e++)t+=e===n-1?this.getHeightOfLineImpl(e):this.getHeightOfLine(e);return t}_getLeftOffset(){return this.direction==="ltr"?-this.width/2:this.width/2}_getTopOffset(){return-this.height/2}_renderTextCommon(t,e){t.save();let n=0;const r=this._getLeftOffset(),i=this._getTopOffset();for(let o=0,a=this._textLines.length;o<a;o++)this._renderTextLine(e,t,this._textLines[o],r+this._getLineLeftOffset(o),i+n+this.getHeightOfLineImpl(o),o),n+=this.getHeightOfLine(o);t.restore()}_renderTextFill(t){(this.fill||this.styleHas(Fe))&&this._renderTextCommon(t,"fillText")}_renderTextStroke(t){(this.stroke&&this.strokeWidth!==0||!this.isEmptyStyles())&&(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this._setLineDash(t,this.strokeDashArray),t.beginPath(),this._renderTextCommon(t,"strokeText"),t.closePath(),t.restore())}_renderChars(t,e,n,r,i,o){const a=this.textAlign.includes(Ws),l=this.path,c=!a&&this.charSpacing===0&&this.isEmptyStyles(o)&&!l,u=this.direction==="ltr",h=this.direction==="ltr"?1:-1,d=e.direction;let p,f,m,g,y,b="",w=0;if(e.save(),d!==this.direction&&(e.canvas.setAttribute("dir",u?"ltr":"rtl"),e.direction=u?"ltr":"rtl",e.textAlign=u?Vt:xe),i-=this.getHeightOfLineImpl(o)*this._fontSizeFraction,c)return this._renderChar(t,e,o,0,n.join(""),r,i),void e.restore();for(let x=0,v=n.length-1;x<=v;x++)g=x===v||this.charSpacing||l,b+=n[x],m=this.__charBounds[o][x],w===0?(r+=h*(m.kernedWidth-m.width),w+=m.width):w+=m.kernedWidth,a&&!g&&this._reSpaceAndTab.test(n[x])&&(g=!0),g||(p=p||this.getCompleteStyleDeclaration(o,x),f=this.getCompleteStyleDeclaration(o,x+1),g=qy(p,f,!1)),g&&(l?(e.save(),e.translate(m.renderLeft,m.renderTop),e.rotate(m.angle),this._renderChar(t,e,o,x,b,-w/2,0),e.restore()):(y=r,this._renderChar(t,e,o,x,b,y,i)),b="",p=f,r+=h*w,w=0);e.restore()}_applyPatternGradientTransformText(t){const e=this.width+this.strokeWidth,n=this.height+this.strokeWidth,r=hs({width:e,height:n}),i=r.getContext("2d");return r.width=e,r.height=n,i.beginPath(),i.moveTo(0,0),i.lineTo(e,0),i.lineTo(e,n),i.lineTo(0,n),i.closePath(),i.translate(e/2,n/2),i.fillStyle=t.toLive(i),this._applyPatternGradientTransform(i,t),i.fill(),i.createPattern(r,"no-repeat")}handleFiller(t,e,n){let r,i;return as(n)?n.gradientUnits==="percentage"||n.gradientTransform||n.patternTransform?(r=-this.width/2,i=-this.height/2,t.translate(r,i),t[e]=this._applyPatternGradientTransformText(n),{offsetX:r,offsetY:i}):(t[e]=n.toLive(t),this._applyPatternGradientTransform(t,n)):(t[e]=n,{offsetX:0,offsetY:0})}_setStrokeStyles(t,e){let{stroke:n,strokeWidth:r}=e;return t.lineWidth=r,t.lineCap=this.strokeLineCap,t.lineDashOffset=this.strokeDashOffset,t.lineJoin=this.strokeLineJoin,t.miterLimit=this.strokeMiterLimit,this.handleFiller(t,"strokeStyle",n)}_setFillStyles(t,e){let{fill:n}=e;return this.handleFiller(t,"fillStyle",n)}_renderChar(t,e,n,r,i,o,a){const l=this._getStyleDeclaration(n,r),c=this.getCompleteStyleDeclaration(n,r),u=t==="fillText"&&c.fill,h=t==="strokeText"&&c.stroke&&c.strokeWidth;if(h||u){if(e.save(),e.font=this._getFontDeclaration(c),l.textBackgroundColor&&this._removeShadow(e),l.deltaY&&(a+=l.deltaY),u){const d=this._setFillStyles(e,c);e.fillText(i,o-d.offsetX,a-d.offsetY)}if(h){const d=this._setStrokeStyles(e,c);e.strokeText(i,o-d.offsetX,a-d.offsetY)}e.restore()}}setSuperscript(t,e){this._setScript(t,e,this.superscript)}setSubscript(t,e){this._setScript(t,e,this.subscript)}_setScript(t,e,n){const r=this.get2DCursorLocation(t,!0),i=this.getValueOfPropertyAt(r.lineIndex,r.charIndex,"fontSize"),o=this.getValueOfPropertyAt(r.lineIndex,r.charIndex,"deltaY"),a={fontSize:i*n.size,deltaY:o+i*n.baseline};this.setSelectionStyles(a,t,e)}_getLineLeftOffset(t){const e=this.getLineWidth(t),n=this.width-e,r=this.textAlign,i=this.direction,o=this.isEndOfWrapping(t);let a=0;return r===Ws||r===ql&&!o||r===Xl&&!o||r===Dd&&!o?0:(r===Et&&(a=n/2),r===xe&&(a=n),r===ql&&(a=n/2),r===Xl&&(a=n),i==="rtl"&&(r===xe||r===Ws||r===Xl?a=0:r===Vt||r===Dd?a=-n:r!==Et&&r!==ql||(a=-n/2)),a)}_clearCache(){this._forceClearCache=!1,this.__lineWidths=[],this.__lineHeights=[],this.__charBounds=[]}getLineWidth(t){if(this.__lineWidths[t]!==void 0)return this.__lineWidths[t];const{width:e}=this.measureLine(t);return this.__lineWidths[t]=e,e}_getWidthOfCharSpacing(){return this.charSpacing!==0?this.fontSize*this.charSpacing/1e3:0}getValueOfPropertyAt(t,e,n){var r;return(r=this._getStyleDeclaration(t,e)[n])!==null&&r!==void 0?r:this[n]}_renderTextDecoration(t,e){if(!this[e]&&!this.styleHas(e))return;let n=this._getTopOffset();const r=this._getLeftOffset(),i=this.path,o=this._getWidthOfCharSpacing(),a=e==="linethrough"?.5:e==="overline"?1:0,l=this.offsets[e];for(let c=0,u=this._textLines.length;c<u;c++){const h=this.getHeightOfLine(c);if(!this[e]&&!this.styleHas(e,c)){n+=h;continue}const d=this._textLines[c],p=h/this.lineHeight,f=this._getLineLeftOffset(c);let m=0,g=0,y=this.getValueOfPropertyAt(c,0,e),b=this.getValueOfPropertyAt(c,0,Fe),w=this.getValueOfPropertyAt(c,0,eo),x=y,v=b,C=w;const k=n+p*(1-this._fontSizeFraction);let I=this.getHeightOfChar(c,0),N=this.getValueOfPropertyAt(c,0,"deltaY");for(let D=0,R=d.length;D<R;D++){const P=this.__charBounds[c][D];x=this.getValueOfPropertyAt(c,D,e),v=this.getValueOfPropertyAt(c,D,Fe),C=this.getValueOfPropertyAt(c,D,eo);const B=this.getHeightOfChar(c,D),U=this.getValueOfPropertyAt(c,D,"deltaY");if(i&&x&&v){const H=this.fontSize*C/1e3;t.save(),t.fillStyle=b,t.translate(P.renderLeft,P.renderTop),t.rotate(P.angle),t.fillRect(-P.kernedWidth/2,l*B+U-a*H,P.kernedWidth,H),t.restore()}else if((x!==y||v!==b||B!==I||C!==w||U!==N)&&g>0){const H=this.fontSize*w/1e3;let G=r+f+m;this.direction==="rtl"&&(G=this.width-G-g),y&&b&&w&&(t.fillStyle=b,t.fillRect(G,k+l*I+N-a*H,g,H)),m=P.left,g=P.width,y=x,w=C,b=v,I=B,N=U}else g+=P.kernedWidth}let _=r+f+m;this.direction==="rtl"&&(_=this.width-_-g),t.fillStyle=v;const T=this.fontSize*C/1e3;x&&v&&C&&t.fillRect(_,k+l*I+N-a*T,g-o,T),n+=h}this._removeShadow(t)}_getFontDeclaration(){let{fontFamily:t=this.fontFamily,fontStyle:e=this.fontStyle,fontWeight:n=this.fontWeight,fontSize:r=this.fontSize}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},i=arguments.length>1?arguments[1]:void 0;const o=t.includes("'")||t.includes('"')||t.includes(",")||dn.genericFonts.includes(t.toLowerCase())?t:'"'.concat(t,'"');return[e,n,"".concat(i?this.CACHE_FONT_SIZE:r,"px"),o].join(" ")}render(t){this.visible&&(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(this._forceClearCache&&this.initDimensions(),super.render(t)))}graphemeSplit(t){return Xy(t)}_splitTextIntoLines(t){const e=t.split(this._reNewline),n=new Array(e.length),r=[`
`];let i=[];for(let o=0;o<e.length;o++)n[o]=this.graphemeSplit(e[o]),i=i.concat(n[o],r);return i.pop(),{_unwrappedLines:n,lines:e,graphemeText:i,graphemeLines:n}}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return V(V({},super.toObject([...sS,...t])),{},{styles:pE(this.styles,this.text)},this.path?{path:this.path.toObject()}:{})}set(t,e){const{textLayoutProperties:n}=this.constructor;super.set(t,e);let r=!1,i=!1;if(typeof t=="object")for(const o in t)o==="path"&&this.setPathInfo(),r=r||n.includes(o),i=i||o==="path";else r=n.includes(t),i=t==="path";return i&&this.setPathInfo(),r&&this.initialized&&(this.initDimensions(),this.setCoords()),this}complexity(){return 1}static async fromElement(t,e,n){const r=Fr(t,dn.ATTRIBUTE_NAMES,n),i=V(V({},e),r),{textAnchor:o=Vt,textDecoration:a="",dx:l=0,dy:c=0,top:u=0,left:h=0,fontSize:d=Ry,strokeWidth:p=1}=i,f=se(i,CD),m=new this(Ed(t.textContent||"").trim(),V({left:h+l,top:u+c,underline:a.includes("underline"),overline:a.includes("overline"),linethrough:a.includes("line-through"),strokeWidth:0,fontSize:d},f)),g=m.getScaledHeight()/m.height,y=((m.height+m.strokeWidth)*m.lineHeight-m.height)*g,b=m.getScaledHeight()+y;let w=0;return o===Et&&(w=m.getScaledWidth()/2),o===xe&&(w=m.getScaledWidth()),m.set({left:m.left-w,top:m.top-(b-m.fontSize*(.07+m._fontSizeFraction))/m.lineHeight,strokeWidth:p}),m}static fromObject(t){return this._fromObject(V(V({},t),{},{styles:fE(t.styles||{},t.text)}),{extraParam:"text"})}}z(dn,"textLayoutProperties",nS),z(dn,"cacheProperties",[...Rr,...sS]),z(dn,"ownDefaults",I_),z(dn,"type","Text"),z(dn,"genericFonts",["serif","sans-serif","monospace","cursive","fantasy","system-ui","ui-serif","ui-sans-serif","ui-monospace","ui-rounded","math","emoji","fangsong"]),z(dn,"ATTRIBUTE_NAMES",xi.concat("x","y","dx","dy","font-family","font-style","font-weight","font-size","letter-spacing","text-decoration","text-anchor")),dS(dn,[class extends Q1{_toSVG(){const s=this._getSVGLeftTopOffsets(),t=this._getSVGTextAndBg(s.textTop,s.textLeft);return this._wrapSVGTextAndBg(t)}toSVG(s){const t=this._createBaseSVGMarkup(this._toSVG(),{reviver:s,noStyle:!0,withShadow:!0}),e=this.path;return e?t+e._createBaseSVGMarkup(e._toSVG(),{reviver:s,withShadow:!0,additionalTransform:Ql(this.calcOwnMatrix())}):t}_getSVGLeftTopOffsets(){return{textLeft:-this.width/2,textTop:-this.height/2,lineTop:this.getHeightOfLine(0)}}_wrapSVGTextAndBg(s){let{textBgRects:t,textSpans:e}=s;const n=this.getSvgTextDecoration(this);return[t.join(""),'		<text xml:space="preserve" ','font-family="'.concat(this.fontFamily.replace(SD,"'"),'" '),'font-size="'.concat(this.fontSize,'" '),this.fontStyle?'font-style="'.concat(this.fontStyle,'" '):"",this.fontWeight?'font-weight="'.concat(this.fontWeight,'" '):"",n?'text-decoration="'.concat(n,'" '):"",this.direction==="rtl"?'direction="'.concat(this.direction,'" '):"",'style="',this.getSvgStyles(!0),'"',this.addPaintOrder()," >",e.join(""),`</text>
`]}_getSVGTextAndBg(s,t){const e=[],n=[];let r,i=s;this.backgroundColor&&n.push(...Km(this.backgroundColor,-this.width/2,-this.height/2,this.width,this.height));for(let o=0,a=this._textLines.length;o<a;o++)r=this._getLineLeftOffset(o),this.direction==="rtl"&&(r+=this.width),(this.textBackgroundColor||this.styleHas("textBackgroundColor",o))&&this._setSVGTextLineBg(n,o,t+r,i),this._setSVGTextLineText(e,o,t+r,i),i+=this.getHeightOfLine(o);return{textSpans:e,textBgRects:n}}_createTextCharSpan(s,t,e,n,r){const i=Mt.NUM_FRACTION_DIGITS,o=this.getSvgSpanStyles(t,s!==s.trim()||!!s.match(vD)),a=o?'style="'.concat(o,'"'):"",l=t.deltaY,c=l?' dy="'.concat(Qt(l,i),'" '):"",{angle:u,renderLeft:h,renderTop:d,width:p}=r;let f="";if(h!==void 0){const m=p/2;u&&(f=' rotate="'.concat(Qt(Nr(u),i),'"'));const g=ma({angle:Nr(u)});g[4]=h,g[5]=d;const y=new q(-m,0).transform(g);e=y.x,n=y.y}return'<tspan x="'.concat(Qt(e,i),'" y="').concat(Qt(n,i),'" ').concat(c).concat(f).concat(a,">").concat(uE(s),"</tspan>")}_setSVGTextLineText(s,t,e,n){const r=this.getHeightOfLine(t),i=this.textAlign.includes(Ws),o=this._textLines[t];let a,l,c,u,h,d="",p=0;n+=r*(1-this._fontSizeFraction)/this.lineHeight;for(let f=0,m=o.length-1;f<=m;f++)h=f===m||this.charSpacing||this.path,d+=o[f],c=this.__charBounds[t][f],p===0?(e+=c.kernedWidth-c.width,p+=c.width):p+=c.kernedWidth,i&&!h&&this._reSpaceAndTab.test(o[f])&&(h=!0),h||(a=a||this.getCompleteStyleDeclaration(t,f),l=this.getCompleteStyleDeclaration(t,f+1),h=qy(a,l,!0)),h&&(u=this._getStyleDeclaration(t,f),s.push(this._createTextCharSpan(d,u,e,n,c)),d="",a=l,this.direction==="rtl"?e-=p:e+=p,p=0)}_setSVGTextLineBg(s,t,e,n){const r=this._textLines[t],i=this.getHeightOfLine(t)/this.lineHeight;let o,a=0,l=0,c=this.getValueOfPropertyAt(t,0,"textBackgroundColor");for(let u=0;u<r.length;u++){const{left:h,width:d,kernedWidth:p}=this.__charBounds[t][u];o=this.getValueOfPropertyAt(t,u,"textBackgroundColor"),o!==c?(c&&s.push(...Km(c,e+l,n,a,i)),l=h,a=d,c=o):a+=p}o&&s.push(...Km(c,e+l,n,a,i))}_getSVGLineTopOffset(s){let t,e=0;for(t=0;t<s;t++)e+=this.getHeightOfLine(t);const n=this.getHeightOfLine(t);return{lineTop:e,offset:(this._fontSizeMult-this._fontSizeFraction)*n/(this.lineHeight*this._fontSizeMult)}}getSvgStyles(s){return"".concat(super.getSvgStyles(s)," text-decoration-thickness: ").concat(Qt(this.textDecorationThickness*this.getObjectScaling().y/10,Mt.NUM_FRACTION_DIGITS),"%; white-space: pre;")}getSvgSpanStyles(s,t){const{fontFamily:e,strokeWidth:n,stroke:r,fill:i,fontSize:o,fontStyle:a,fontWeight:l,deltaY:c,textDecorationThickness:u,linethrough:h,overline:d,underline:p}=s,f=this.getSvgTextDecoration({underline:p??this.underline,overline:d??this.overline,linethrough:h??this.linethrough}),m=u||this.textDecorationThickness;return[r?tc(Rn,r):"",n?"stroke-width: ".concat(n,"; "):"",e?"font-family: ".concat(e.includes("'")||e.includes('"')?e:"'".concat(e,"'"),"; "):"",o?"font-size: ".concat(o,"px; "):"",a?"font-style: ".concat(a,"; "):"",l?"font-weight: ".concat(l,"; "):"",f?"text-decoration: ".concat(f,"; text-decoration-thickness: ").concat(Qt(m*this.getObjectScaling().y/10,Mt.NUM_FRACTION_DIGITS),"%; "):"",i?tc(Fe,i):"",c?"baseline-shift: ".concat(-c,"; "):"",t?"white-space: pre; ":""].join("")}getSvgTextDecoration(s){return["overline","underline","line-through"].filter((t=>s[t.replace("-","")])).join(" ")}}]),ut.setClass(dn),ut.setSVGClass(dn);class TD{constructor(t){z(this,"target",void 0),z(this,"__mouseDownInPlace",!1),z(this,"__dragStartFired",!1),z(this,"__isDraggingOver",!1),z(this,"__dragStartSelection",void 0),z(this,"__dragImageDisposer",void 0),z(this,"_dispose",void 0),this.target=t;const e=[this.target.on("dragenter",this.dragEnterHandler.bind(this)),this.target.on("dragover",this.dragOverHandler.bind(this)),this.target.on("dragleave",this.dragLeaveHandler.bind(this)),this.target.on("dragend",this.dragEndHandler.bind(this)),this.target.on("drop",this.dropHandler.bind(this))];this._dispose=()=>{e.forEach((n=>n())),this._dispose=void 0}}isPointerOverSelection(t){const e=this.target,n=e.getSelectionStartFromPointer(t);return e.isEditing&&n>=e.selectionStart&&n<=e.selectionEnd&&e.selectionStart<e.selectionEnd}start(t){return this.__mouseDownInPlace=this.isPointerOverSelection(t)}isActive(){return this.__mouseDownInPlace}end(t){const e=this.isActive();return e&&!this.__dragStartFired&&(this.target.setCursorByClick(t),this.target.initDelayedCursor(!0)),this.__mouseDownInPlace=!1,this.__dragStartFired=!1,this.__isDraggingOver=!1,e}getDragStartSelection(){return this.__dragStartSelection}setDragImage(t,e){var n;let{selectionStart:r,selectionEnd:i}=e;const o=this.target,a=o.canvas,l=new q(o.flipX?-1:1,o.flipY?-1:1),c=o._getCursorBoundaries(r),u=new q(c.left+c.leftOffset,c.top+c.topOffset).multiply(l).transform(o.calcTransformMatrix()),h=a.getScenePoint(t).subtract(u),d=o.getCanvasRetinaScaling(),p=o.getBoundingRect(),f=u.subtract(new q(p.left,p.top)),m=a.viewportTransform,g=f.add(h).transform(m,!0),y=o.backgroundColor,b=Hy(o.styles);o.backgroundColor="";const w={stroke:"transparent",fill:"transparent",textBackgroundColor:"transparent"};o.setSelectionStyles(w,0,r),o.setSelectionStyles(w,i,o.text.length),o.dirty=!0;const x=o.toCanvasElement({enableRetinaScaling:a.enableRetinaScaling,viewportTransform:!0});o.backgroundColor=y,o.styles=b,o.dirty=!0,Rg(x,{position:"fixed",left:"".concat(-x.width,"px"),border:On,width:"".concat(x.width/d,"px"),height:"".concat(x.height/d,"px")}),this.__dragImageDisposer&&this.__dragImageDisposer(),this.__dragImageDisposer=()=>{x.remove()},Ts(t.target||this.target.hiddenTextarea).body.appendChild(x),(n=t.dataTransfer)===null||n===void 0||n.setDragImage(x,g.x,g.y)}onDragStart(t){this.__dragStartFired=!0;const e=this.target,n=this.isActive();if(n&&t.dataTransfer){const r=this.__dragStartSelection={selectionStart:e.selectionStart,selectionEnd:e.selectionEnd},i=e._text.slice(r.selectionStart,r.selectionEnd).join(""),o=V({text:e.text,value:i},r);t.dataTransfer.setData("text/plain",i),t.dataTransfer.setData("application/fabric",JSON.stringify({value:i,styles:e.getSelectionStyles(r.selectionStart,r.selectionEnd,!0)})),t.dataTransfer.effectAllowed="copyMove",this.setDragImage(t,o)}return e.abortCursorAnimation(),n}canDrop(t){if(this.target.editable&&!this.target.getActiveControl()&&!t.defaultPrevented){if(this.isActive()&&this.__dragStartSelection){const e=this.target.getSelectionStartFromPointer(t),n=this.__dragStartSelection;return e<n.selectionStart||e>n.selectionEnd}return!0}return!1}targetCanDrop(t){return this.target.canDrop(t)}dragEnterHandler(t){let{e}=t;const n=this.targetCanDrop(e);!this.__isDraggingOver&&n&&(this.__isDraggingOver=!0)}dragOverHandler(t){const{e}=t,n=this.targetCanDrop(e);!this.__isDraggingOver&&n?this.__isDraggingOver=!0:this.__isDraggingOver&&!n&&(this.__isDraggingOver=!1),this.__isDraggingOver&&(e.preventDefault(),t.canDrop=!0,t.dropTarget=this.target)}dragLeaveHandler(){(this.__isDraggingOver||this.isActive())&&(this.__isDraggingOver=!1)}dropHandler(t){var e;const{e:n}=t,r=n.defaultPrevented;this.__isDraggingOver=!1,n.preventDefault();let i=(e=n.dataTransfer)===null||e===void 0?void 0:e.getData("text/plain");if(i&&!r){const o=this.target,a=o.canvas;let l=o.getSelectionStartFromPointer(n);const{styles:c}=n.dataTransfer.types.includes("application/fabric")?JSON.parse(n.dataTransfer.getData("application/fabric")):{},u=i[Math.max(0,i.length-1)],h=0;if(this.__dragStartSelection){const d=this.__dragStartSelection.selectionStart,p=this.__dragStartSelection.selectionEnd;l>d&&l<=p?l=d:l>p&&(l-=p-d),o.removeChars(d,p),delete this.__dragStartSelection}o._reNewline.test(u)&&(o._reNewline.test(o._text[l])||l===o._text.length)&&(i=i.trimEnd()),t.didDrop=!0,t.dropTarget=o,o.insertChars(i,c,l),a.setActiveObject(o),o.enterEditing(n),o.selectionStart=Math.min(l+h,o._text.length),o.selectionEnd=Math.min(o.selectionStart+i.length,o._text.length),o.hiddenTextarea.value=o.text,o._updateTextarea(),o.hiddenTextarea.focus(),o.fire(Td,{index:l+h,action:"drop"}),a.fire("text:changed",{target:o}),a.contextTopDirty=!0,a.requestRenderAll()}}dragEndHandler(t){let{e}=t;if(this.isActive()&&this.__dragStartFired&&this.__dragStartSelection){var n;const r=this.target,i=this.target.canvas,{selectionStart:o,selectionEnd:a}=this.__dragStartSelection,l=((n=e.dataTransfer)===null||n===void 0?void 0:n.dropEffect)||On;l===On?(r.selectionStart=o,r.selectionEnd=a,r._updateTextarea(),r.hiddenTextarea.focus()):(r.clearContextTop(),l==="move"&&(r.removeChars(o,a),r.selectionStart=r.selectionEnd=o,r.hiddenTextarea&&(r.hiddenTextarea.value=r.text),r._updateTextarea(),r.fire(Td,{index:o,action:"dragend"}),i.fire("text:changed",{target:r}),i.requestRenderAll()),r.exitEditing())}this.__dragImageDisposer&&this.__dragImageDisposer(),delete this.__dragImageDisposer,delete this.__dragStartSelection,this.__isDraggingOver=!1}dispose(){this._dispose&&this._dispose()}}const Cw=/[ \n\.,;!\?\-]/;class kD extends dn{constructor(){super(...arguments),z(this,"_currentCursorOpacity",1)}initBehavior(){this._tick=this._tick.bind(this),this._onTickComplete=this._onTickComplete.bind(this),this.updateSelectionOnMouseMove=this.updateSelectionOnMouseMove.bind(this)}onDeselect(t){return this.isEditing&&this.exitEditing(),this.selected=!1,super.onDeselect(t)}_animateCursor(t){let{toValue:e,duration:n,delay:r,onComplete:i}=t;return aS({startValue:this._currentCursorOpacity,endValue:e,duration:n,delay:r,onComplete:i,abort:()=>!this.canvas||this.selectionStart!==this.selectionEnd,onChange:o=>{this._currentCursorOpacity=o,this.renderCursorOrSelection()}})}_tick(t){this._currentTickState=this._animateCursor({toValue:0,duration:this.cursorDuration/2,delay:Math.max(t||0,100),onComplete:this._onTickComplete})}_onTickComplete(){var t;(t=this._currentTickCompleteState)===null||t===void 0||t.abort(),this._currentTickCompleteState=this._animateCursor({toValue:1,duration:this.cursorDuration,onComplete:this._tick})}initDelayedCursor(t){this.abortCursorAnimation(),this._tick(t?0:this.cursorDelay)}abortCursorAnimation(){let t=!1;[this._currentTickState,this._currentTickCompleteState].forEach((e=>{e&&!e.isDone()&&(t=!0,e.abort())})),this._currentCursorOpacity=1,t&&this.clearContextTop()}restartCursorIfNeeded(){[this._currentTickState,this._currentTickCompleteState].some((t=>!t||t.isDone()))&&this.initDelayedCursor()}selectAll(){return this.selectionStart=0,this.selectionEnd=this._text.length,this._fireSelectionChanged(),this._updateTextarea(),this}cmdAll(){this.selectAll(),this.renderCursorOrSelection()}getSelectedText(){return this._text.slice(this.selectionStart,this.selectionEnd).join("")}findWordBoundaryLeft(t){let e=0,n=t-1;if(this._reSpace.test(this._text[n]))for(;this._reSpace.test(this._text[n]);)e++,n--;for(;/\S/.test(this._text[n])&&n>-1;)e++,n--;return t-e}findWordBoundaryRight(t){let e=0,n=t;if(this._reSpace.test(this._text[n]))for(;this._reSpace.test(this._text[n]);)e++,n++;for(;/\S/.test(this._text[n])&&n<this._text.length;)e++,n++;return t+e}findLineBoundaryLeft(t){let e=0,n=t-1;for(;!/\n/.test(this._text[n])&&n>-1;)e++,n--;return t-e}findLineBoundaryRight(t){let e=0,n=t;for(;!/\n/.test(this._text[n])&&n<this._text.length;)e++,n++;return t+e}searchWordBoundary(t,e){const n=this._text;let r=t>0&&this._reSpace.test(n[t])&&(e===-1||!Fy.test(n[t-1]))?t-1:t,i=n[r];for(;r>0&&r<n.length&&!Cw.test(i);)r+=e,i=n[r];return e===-1&&Cw.test(i)&&r++,r}selectWord(t){var e;t=(e=t)!==null&&e!==void 0?e:this.selectionStart;const n=this.searchWordBoundary(t,-1),r=Math.max(n,this.searchWordBoundary(t,1));this.selectionStart=n,this.selectionEnd=r,this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()}selectLine(t){var e;t=(e=t)!==null&&e!==void 0?e:this.selectionStart;const n=this.findLineBoundaryLeft(t),r=this.findLineBoundaryRight(t);this.selectionStart=n,this.selectionEnd=r,this._fireSelectionChanged(),this._updateTextarea()}enterEditing(t){!this.isEditing&&this.editable&&(this.enterEditingImpl(),this.fire("editing:entered",t?{e:t}:void 0),this._fireSelectionChanged(),this.canvas&&(this.canvas.fire("text:editing:entered",{target:this,e:t}),this.canvas.requestRenderAll()))}enterEditingImpl(){this.canvas&&(this.canvas.calcOffset(),this.canvas.textEditingManager.exitTextEditing()),this.isEditing=!0,this.initHiddenTextarea(),this.hiddenTextarea.focus(),this.hiddenTextarea.value=this.text,this._updateTextarea(),this._saveEditingProps(),this._setEditingProps(),this._textBeforeEdit=this.text,this._tick()}updateSelectionOnMouseMove(t){if(this.getActiveControl())return;const e=this.hiddenTextarea;Ts(e).activeElement!==e&&e.focus();const n=this.getSelectionStartFromPointer(t),r=this.selectionStart,i=this.selectionEnd;(n===this.__selectionStartOnMouseDown&&r!==i||r!==n&&i!==n)&&(n>this.__selectionStartOnMouseDown?(this.selectionStart=this.__selectionStartOnMouseDown,this.selectionEnd=n):(this.selectionStart=n,this.selectionEnd=this.__selectionStartOnMouseDown),this.selectionStart===r&&this.selectionEnd===i||(this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()))}_setEditingProps(){this.hoverCursor="text",this.canvas&&(this.canvas.defaultCursor=this.canvas.moveCursor="text"),this.borderColor=this.editingBorderColor,this.hasControls=this.selectable=!1,this.lockMovementX=this.lockMovementY=!0}fromStringToGraphemeSelection(t,e,n){const r=n.slice(0,t),i=this.graphemeSplit(r).length;if(t===e)return{selectionStart:i,selectionEnd:i};const o=n.slice(t,e);return{selectionStart:i,selectionEnd:i+this.graphemeSplit(o).length}}fromGraphemeToStringSelection(t,e,n){const r=n.slice(0,t).join("").length;return t===e?{selectionStart:r,selectionEnd:r}:{selectionStart:r,selectionEnd:r+n.slice(t,e).join("").length}}_updateTextarea(){if(this.cursorOffsetCache={},this.hiddenTextarea){if(!this.inCompositionMode){const t=this.fromGraphemeToStringSelection(this.selectionStart,this.selectionEnd,this._text);this.hiddenTextarea.selectionStart=t.selectionStart,this.hiddenTextarea.selectionEnd=t.selectionEnd}this.updateTextareaPosition()}}updateFromTextArea(){if(!this.hiddenTextarea)return;this.cursorOffsetCache={};const t=this.hiddenTextarea;this.text=t.value,this.set("dirty",!0),this.initDimensions(),this.setCoords();const e=this.fromStringToGraphemeSelection(t.selectionStart,t.selectionEnd,t.value);this.selectionEnd=this.selectionStart=e.selectionEnd,this.inCompositionMode||(this.selectionStart=e.selectionStart),this.updateTextareaPosition()}updateTextareaPosition(){if(this.selectionStart===this.selectionEnd){const t=this._calcTextareaPosition();this.hiddenTextarea.style.left=t.left,this.hiddenTextarea.style.top=t.top}}_calcTextareaPosition(){if(!this.canvas)return{left:"1px",top:"1px"};const t=this.inCompositionMode?this.compositionStart:this.selectionStart,e=this._getCursorBoundaries(t),n=this.get2DCursorLocation(t),r=n.lineIndex,i=n.charIndex,o=this.getValueOfPropertyAt(r,i,"fontSize")*this.lineHeight,a=e.leftOffset,l=this.getCanvasRetinaScaling(),c=this.canvas.upperCanvasEl,u=c.width/l,h=c.height/l,d=u-o,p=h-o,f=new q(e.left+a,e.top+e.topOffset+o).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new q(c.clientWidth/u,c.clientHeight/h));return f.x<0&&(f.x=0),f.x>d&&(f.x=d),f.y<0&&(f.y=0),f.y>p&&(f.y=p),f.x+=this.canvas._offset.left,f.y+=this.canvas._offset.top,{left:"".concat(f.x,"px"),top:"".concat(f.y,"px"),fontSize:"".concat(o,"px"),charHeight:o}}_saveEditingProps(){this._savedProps={hasControls:this.hasControls,borderColor:this.borderColor,lockMovementX:this.lockMovementX,lockMovementY:this.lockMovementY,hoverCursor:this.hoverCursor,selectable:this.selectable,defaultCursor:this.canvas&&this.canvas.defaultCursor,moveCursor:this.canvas&&this.canvas.moveCursor}}_restoreEditingProps(){this._savedProps&&(this.hoverCursor=this._savedProps.hoverCursor,this.hasControls=this._savedProps.hasControls,this.borderColor=this._savedProps.borderColor,this.selectable=this._savedProps.selectable,this.lockMovementX=this._savedProps.lockMovementX,this.lockMovementY=this._savedProps.lockMovementY,this.canvas&&(this.canvas.defaultCursor=this._savedProps.defaultCursor||this.canvas.defaultCursor,this.canvas.moveCursor=this._savedProps.moveCursor||this.canvas.moveCursor),delete this._savedProps)}_exitEditing(){const t=this.hiddenTextarea;this.selected=!1,this.isEditing=!1,t&&(t.blur&&t.blur(),t.parentNode&&t.parentNode.removeChild(t)),this.hiddenTextarea=null,this.abortCursorAnimation(),this.selectionStart!==this.selectionEnd&&this.clearContextTop()}exitEditingImpl(){this._exitEditing(),this.selectionEnd=this.selectionStart,this._restoreEditingProps(),this._forceClearCache&&(this.initDimensions(),this.setCoords())}exitEditing(){const t=this._textBeforeEdit!==this.text;return this.exitEditingImpl(),this.fire("editing:exited"),t&&this.fire(kd),this.canvas&&(this.canvas.fire("text:editing:exited",{target:this}),t&&this.canvas.fire("object:modified",{target:this})),this}_removeExtraneousStyles(){for(const t in this.styles)this._textLines[t]||delete this.styles[t]}removeStyleFromTo(t,e){const{lineIndex:n,charIndex:r}=this.get2DCursorLocation(t,!0),{lineIndex:i,charIndex:o}=this.get2DCursorLocation(e,!0);if(n!==i){if(this.styles[n])for(let a=r;a<this._unwrappedTextLines[n].length;a++)delete this.styles[n][a];if(this.styles[i])for(let a=o;a<this._unwrappedTextLines[i].length;a++){const l=this.styles[i][a];l&&(this.styles[n]||(this.styles[n]={}),this.styles[n][r+a-o]=l)}for(let a=n+1;a<=i;a++)delete this.styles[a];this.shiftLineStyles(i,n-i)}else if(this.styles[n]){const a=this.styles[n],l=o-r;for(let c=r;c<o;c++)delete a[c];for(const c in this.styles[n]){const u=parseInt(c,10);u>=o&&(a[u-l]=a[c],delete a[c])}}}shiftLineStyles(t,e){const n=Object.assign({},this.styles);for(const r in this.styles){const i=parseInt(r,10);i>t&&(this.styles[i+e]=n[i],n[i-e]||delete this.styles[i])}}insertNewlineStyleObject(t,e,n,r){const i={},o=this._unwrappedTextLines[t].length,a=o===e;let l=!1;n||(n=1),this.shiftLineStyles(t,n);const c=this.styles[t]?this.styles[t][e===0?e:e-1]:void 0;for(const h in this.styles[t]){const d=parseInt(h,10);d>=e&&(l=!0,i[d-e]=this.styles[t][h],a&&e===0||delete this.styles[t][h])}let u=!1;for(l&&!a&&(this.styles[t+n]=i,u=!0),(u||o>e)&&n--;n>0;)r&&r[n-1]?this.styles[t+n]={0:V({},r[n-1])}:c?this.styles[t+n]={0:V({},c)}:delete this.styles[t+n],n--;this._forceClearCache=!0}insertCharStyleObject(t,e,n,r){this.styles||(this.styles={});const i=this.styles[t],o=i?V({},i):{};n||(n=1);for(const l in o){const c=parseInt(l,10);c>=e&&(i[c+n]=o[c],o[c-n]||delete i[c])}if(this._forceClearCache=!0,r){for(;n--;)Object.keys(r[n]).length&&(this.styles[t]||(this.styles[t]={}),this.styles[t][e+n]=V({},r[n]));return}if(!i)return;const a=i[e?e-1:1];for(;a&&n--;)this.styles[t][e+n]=V({},a)}insertNewStyleBlock(t,e,n){const r=this.get2DCursorLocation(e,!0),i=[0];let o,a=0;for(let l=0;l<t.length;l++)t[l]===`
`?(a++,i[a]=0):i[a]++;for(i[0]>0&&(this.insertCharStyleObject(r.lineIndex,r.charIndex,i[0],n),n=n&&n.slice(i[0]+1)),a&&this.insertNewlineStyleObject(r.lineIndex,r.charIndex+i[0],a),o=1;o<a;o++)i[o]>0?this.insertCharStyleObject(r.lineIndex+o,0,i[o],n):n&&this.styles[r.lineIndex+o]&&n[0]&&(this.styles[r.lineIndex+o][0]=n[0]),n=n&&n.slice(i[o]+1);i[o]>0&&this.insertCharStyleObject(r.lineIndex+o,0,i[o],n)}removeChars(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:t+1;this.removeStyleFromTo(t,e),this._text.splice(t,e-t),this.text=this._text.join(""),this.set("dirty",!0),this.initDimensions(),this.setCoords(),this._removeExtraneousStyles()}insertChars(t,e,n){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:n;r>n&&this.removeStyleFromTo(n,r);const i=this.graphemeSplit(t);this.insertNewStyleBlock(i,n,e),this._text=[...this._text.slice(0,n),...i,...this._text.slice(r)],this.text=this._text.join(""),this.set("dirty",!0),this.initDimensions(),this.setCoords(),this._removeExtraneousStyles()}setSelectionStartEndWithShift(t,e,n){n<=t?(e===t?this._selectionDirection=Vt:this._selectionDirection===xe&&(this._selectionDirection=Vt,this.selectionEnd=t),this.selectionStart=n):n>t&&n<e?this._selectionDirection===xe?this.selectionEnd=n:this.selectionStart=n:(e===t?this._selectionDirection=xe:this._selectionDirection===Vt&&(this._selectionDirection=xe,this.selectionStart=e),this.selectionEnd=n)}}class ID extends kD{initHiddenTextarea(){const t=this.canvas&&Ts(this.canvas.getElement())||da(),e=t.createElement("textarea");Object.entries({autocapitalize:"off",autocorrect:"off",autocomplete:"off",spellcheck:"false","data-fabric":"textarea",wrap:"off",name:"fabricTextarea"}).map((o=>{let[a,l]=o;return e.setAttribute(a,l)}));const{top:n,left:r,fontSize:i}=this._calcTextareaPosition();e.style.cssText="position: absolute; top: ".concat(n,"; left: ").concat(r,"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(i,";"),(this.hiddenTextareaContainer||t.body).appendChild(e),Object.entries({blur:"blur",keydown:"onKeyDown",keyup:"onKeyUp",input:"onInput",copy:"copy",cut:"copy",paste:"paste",compositionstart:"onCompositionStart",compositionupdate:"onCompositionUpdate",compositionend:"onCompositionEnd"}).map((o=>{let[a,l]=o;return e.addEventListener(a,this[l].bind(this))})),this.hiddenTextarea=e}blur(){this.abortCursorAnimation()}onKeyDown(t){if(!this.isEditing)return;const e=this.direction==="rtl"?this.keysMapRtl:this.keysMap;if(t.keyCode in e)this[e[t.keyCode]](t);else{if(!(t.keyCode in this.ctrlKeysMapDown)||!t.ctrlKey&&!t.metaKey)return;this[this.ctrlKeysMapDown[t.keyCode]](t)}t.stopImmediatePropagation(),t.preventDefault(),t.keyCode>=33&&t.keyCode<=40?(this.inCompositionMode=!1,this.clearContextTop(),this.renderCursorOrSelection()):this.canvas&&this.canvas.requestRenderAll()}onKeyUp(t){!this.isEditing||this._copyDone||this.inCompositionMode?this._copyDone=!1:t.keyCode in this.ctrlKeysMapUp&&(t.ctrlKey||t.metaKey)&&(this[this.ctrlKeysMapUp[t.keyCode]](t),t.stopImmediatePropagation(),t.preventDefault(),this.canvas&&this.canvas.requestRenderAll())}onInput(t){const e=this.fromPaste,{value:n,selectionStart:r,selectionEnd:i}=this.hiddenTextarea;if(this.fromPaste=!1,t&&t.stopPropagation(),!this.isEditing)return;const o=()=>{this.updateFromTextArea(),this.fire(Td),this.canvas&&(this.canvas.fire("text:changed",{target:this}),this.canvas.requestRenderAll())};if(this.hiddenTextarea.value==="")return this.styles={},void o();const a=this._splitTextIntoLines(n).graphemeText,l=this._text.length,c=a.length,u=this.selectionStart,h=this.selectionEnd,d=u!==h;let p,f,m,g,y=c-l;const b=this.fromStringToGraphemeSelection(r,i,n),w=u>b.selectionStart;d?(f=this._text.slice(u,h),y+=h-u):c<l&&(f=w?this._text.slice(h+y,h):this._text.slice(u,u-y));const x=a.slice(b.selectionEnd-y,b.selectionEnd);if(f&&f.length&&(x.length&&(p=this.getSelectionStyles(u,u+1,!1),p=x.map((()=>p[0]))),d?(m=u,g=h):w?(m=h-f.length,g=h):(m=h,g=h+f.length),this.removeStyleFromTo(m,g)),x.length){const{copyPasteData:v}=Qs();e&&x.join("")===v.copiedText&&!Mt.disableStyleCopyPaste&&(p=v.copiedTextStyle),this.insertNewStyleBlock(x,u,p)}o()}onCompositionStart(){this.inCompositionMode=!0}onCompositionEnd(){this.inCompositionMode=!1}onCompositionUpdate(t){let{target:e}=t;const{selectionStart:n,selectionEnd:r}=e;this.compositionStart=n,this.compositionEnd=r,this.updateTextareaPosition()}copy(){if(this.selectionStart===this.selectionEnd)return;const{copyPasteData:t}=Qs();t.copiedText=this.getSelectedText(),Mt.disableStyleCopyPaste?t.copiedTextStyle=void 0:t.copiedTextStyle=this.getSelectionStyles(this.selectionStart,this.selectionEnd,!0),this._copyDone=!0}paste(){this.fromPaste=!0}_getWidthBeforeCursor(t,e){let n,r=this._getLineLeftOffset(t);return e>0&&(n=this.__charBounds[t][e-1],r+=n.left+n.width),r}getDownCursorOffset(t,e){const n=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(n),i=r.lineIndex;if(i===this._textLines.length-1||t.metaKey||t.keyCode===34)return this._text.length-n;const o=r.charIndex,a=this._getWidthBeforeCursor(i,o),l=this._getIndexOnLine(i+1,a);return this._textLines[i].slice(o).length+l+1+this.missingNewlineOffset(i)}_getSelectionForOffset(t,e){return t.shiftKey&&this.selectionStart!==this.selectionEnd&&e?this.selectionEnd:this.selectionStart}getUpCursorOffset(t,e){const n=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(n),i=r.lineIndex;if(i===0||t.metaKey||t.keyCode===33)return-n;const o=r.charIndex,a=this._getWidthBeforeCursor(i,o),l=this._getIndexOnLine(i-1,a),c=this._textLines[i].slice(0,o),u=this.missingNewlineOffset(i-1);return-this._textLines[i-1].length+l-c.length+(1-u)}_getIndexOnLine(t,e){const n=this._textLines[t];let r,i,o=this._getLineLeftOffset(t),a=0;for(let l=0,c=n.length;l<c;l++)if(r=this.__charBounds[t][l].width,o+=r,o>e){i=!0;const u=o-r,h=o,d=Math.abs(u-e);a=Math.abs(h-e)<d?l:l-1;break}return i||(a=n.length-1),a}moveCursorDown(t){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorUpOrDown("Down",t)}moveCursorUp(t){this.selectionStart===0&&this.selectionEnd===0||this._moveCursorUpOrDown("Up",t)}_moveCursorUpOrDown(t,e){const n=this["get".concat(t,"CursorOffset")](e,this._selectionDirection===xe);if(e.shiftKey?this.moveCursorWithShift(n):this.moveCursorWithoutShift(n),n!==0){const r=this.text.length;this.selectionStart=Jo(0,this.selectionStart,r),this.selectionEnd=Jo(0,this.selectionEnd,r),this.abortCursorAnimation(),this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea()}}moveCursorWithShift(t){const e=this._selectionDirection===Vt?this.selectionStart+t:this.selectionEnd+t;return this.setSelectionStartEndWithShift(this.selectionStart,this.selectionEnd,e),t!==0}moveCursorWithoutShift(t){return t<0?(this.selectionStart+=t,this.selectionEnd=this.selectionStart):(this.selectionEnd+=t,this.selectionStart=this.selectionEnd),t!==0}moveCursorLeft(t){this.selectionStart===0&&this.selectionEnd===0||this._moveCursorLeftOrRight("Left",t)}_move(t,e,n){let r;if(t.altKey)r=this["findWordBoundary".concat(n)](this[e]);else{if(!t.metaKey&&t.keyCode!==35&&t.keyCode!==36)return this[e]+=n==="Left"?-1:1,!0;r=this["findLineBoundary".concat(n)](this[e])}return r!==void 0&&this[e]!==r&&(this[e]=r,!0)}_moveLeft(t,e){return this._move(t,e,"Left")}_moveRight(t,e){return this._move(t,e,"Right")}moveCursorLeftWithoutShift(t){let e=!0;return this._selectionDirection=Vt,this.selectionEnd===this.selectionStart&&this.selectionStart!==0&&(e=this._moveLeft(t,"selectionStart")),this.selectionEnd=this.selectionStart,e}moveCursorLeftWithShift(t){return this._selectionDirection===xe&&this.selectionStart!==this.selectionEnd?this._moveLeft(t,"selectionEnd"):this.selectionStart!==0?(this._selectionDirection=Vt,this._moveLeft(t,"selectionStart")):void 0}moveCursorRight(t){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorLeftOrRight("Right",t)}_moveCursorLeftOrRight(t,e){const n="moveCursor".concat(t).concat(e.shiftKey?"WithShift":"WithoutShift");this._currentCursorOpacity=1,this[n](e)&&(this.abortCursorAnimation(),this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())}moveCursorRightWithShift(t){return this._selectionDirection===Vt&&this.selectionStart!==this.selectionEnd?this._moveRight(t,"selectionStart"):this.selectionEnd!==this._text.length?(this._selectionDirection=xe,this._moveRight(t,"selectionEnd")):void 0}moveCursorRightWithoutShift(t){let e=!0;return this._selectionDirection=xe,this.selectionStart===this.selectionEnd?(e=this._moveRight(t,"selectionStart"),this.selectionEnd=this.selectionStart):this.selectionStart=this.selectionEnd,e}}const Tw=s=>!!s.button;class ND extends ID{constructor(){super(...arguments),z(this,"draggableTextDelegate",void 0)}initBehavior(){this.on("mousedown",this._mouseDownHandler),this.on("mouseup",this.mouseUpHandler),this.on("mousedblclick",this.doubleClickHandler),this.on("mousetripleclick",this.tripleClickHandler),this.draggableTextDelegate=new TD(this),super.initBehavior()}shouldStartDragging(){return this.draggableTextDelegate.isActive()}onDragStart(t){return this.draggableTextDelegate.onDragStart(t)}canDrop(t){return this.draggableTextDelegate.canDrop(t)}doubleClickHandler(t){this.isEditing&&(this.selectWord(this.getSelectionStartFromPointer(t.e)),this.renderCursorOrSelection())}tripleClickHandler(t){this.isEditing&&(this.selectLine(this.getSelectionStartFromPointer(t.e)),this.renderCursorOrSelection())}_mouseDownHandler(t){let{e,alreadySelected:n}=t;this.canvas&&this.editable&&!Tw(e)&&!this.getActiveControl()&&(this.draggableTextDelegate.start(e)||(this.canvas.textEditingManager.register(this),n&&(this.inCompositionMode=!1,this.setCursorByClick(e)),this.isEditing&&(this.__selectionStartOnMouseDown=this.selectionStart,this.selectionStart===this.selectionEnd&&this.abortCursorAnimation(),this.renderCursorOrSelection()),this.selected||(this.selected=n||this.isEditing)))}mouseUpHandler(t){let{e,transform:n}=t;const r=this.draggableTextDelegate.end(e);if(this.canvas){this.canvas.textEditingManager.unregister(this);const i=this.canvas._activeObject;if(i&&i!==this)return}!this.editable||this.group&&!this.group.interactive||n&&n.actionPerformed||Tw(e)||r||this.selected&&!this.getActiveControl()&&(this.enterEditing(e),this.selectionStart===this.selectionEnd?this.initDelayedCursor(!0):this.renderCursorOrSelection())}setCursorByClick(t){const e=this.getSelectionStartFromPointer(t),n=this.selectionStart,r=this.selectionEnd;t.shiftKey?this.setSelectionStartEndWithShift(n,r,e):(this.selectionStart=e,this.selectionEnd=e),this.isEditing&&(this._fireSelectionChanged(),this._updateTextarea())}getSelectionStartFromPointer(t){const e=this.canvas.getScenePoint(t).transform(ks(this.calcTransformMatrix())).add(new q(-this._getLeftOffset(),-this._getTopOffset()));let n=0,r=0,i=0;for(let c=0;c<this._textLines.length&&n<=e.y;c++)n+=this.getHeightOfLine(c),i=c,c>0&&(r+=this._textLines[c-1].length+this.missingNewlineOffset(c-1));let o=Math.abs(this._getLineLeftOffset(i));const a=this._textLines[i].length,l=this.__charBounds[i];for(let c=0;c<a;c++){const u=o+l[c].kernedWidth;if(e.x<=u){Math.abs(e.x-u)<=Math.abs(e.x-o)&&r++;break}o=u,r++}return Math.min(this.flipX?a-r:r,this._text.length)}}const bh="moveCursorUp",xh="moveCursorDown",wh="moveCursorLeft",vh="moveCursorRight",Sh="exitEditing",kw=(s,t)=>{const e=t.getRetinaScaling();s.setTransform(e,0,0,e,0,0);const n=t.viewportTransform;s.transform(n[0],n[1],n[2],n[3],n[4],n[5])},$D=V({selectionStart:0,selectionEnd:0,selectionColor:"rgba(17,119,255,0.3)",isEditing:!1,editable:!0,editingBorderColor:"rgba(102,153,255,0.25)",cursorWidth:2,cursorColor:"",cursorDelay:1e3,cursorDuration:600,caching:!0,hiddenTextareaContainer:null,keysMap:{9:Sh,27:Sh,33:bh,34:xh,35:vh,36:wh,37:wh,38:bh,39:vh,40:xh},keysMapRtl:{9:Sh,27:Sh,33:bh,34:xh,35:wh,36:vh,37:vh,38:bh,39:wh,40:xh},ctrlKeysMapDown:{65:"cmdAll"},ctrlKeysMapUp:{67:"copy",88:"cut"}},{_selectionDirection:null,_reSpace:/\s|\r?\n/,inCompositionMode:!1});class wr extends ND{static getDefaults(){return V(V({},super.getDefaults()),wr.ownDefaults)}get type(){const t=super.type;return t==="itext"?"i-text":t}constructor(t,e){super(t,V(V({},wr.ownDefaults),e)),this.initBehavior()}_set(t,e){return this.isEditing&&this._savedProps&&t in this._savedProps?(this._savedProps[t]=e,this):(t==="canvas"&&(this.canvas instanceof Fg&&this.canvas.textEditingManager.remove(this),e instanceof Fg&&e.textEditingManager.add(this)),super._set(t,e))}setSelectionStart(t){t=Math.max(t,0),this._updateAndFire("selectionStart",t)}setSelectionEnd(t){t=Math.min(t,this.text.length),this._updateAndFire("selectionEnd",t)}_updateAndFire(t,e){this[t]!==e&&(this._fireSelectionChanged(),this[t]=e),this._updateTextarea()}_fireSelectionChanged(){this.fire("selection:changed"),this.canvas&&this.canvas.fire("text:selection:changed",{target:this})}initDimensions(){this.isEditing&&this.initDelayedCursor(),super.initDimensions()}getSelectionStyles(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.selectionStart||0,e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.selectionEnd,n=arguments.length>2?arguments[2]:void 0;return super.getSelectionStyles(t,e,n)}setSelectionStyles(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.selectionStart||0,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:this.selectionEnd;return super.setSelectionStyles(t,e,n)}get2DCursorLocation(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.selectionStart,e=arguments.length>1?arguments[1]:void 0;return super.get2DCursorLocation(t,e)}render(t){super.render(t),this.cursorOffsetCache={},this.renderCursorOrSelection()}toCanvasElement(t){const e=this.isEditing;this.isEditing=!1;const n=super.toCanvasElement(t);return this.isEditing=e,n}renderCursorOrSelection(){if(!this.isEditing||!this.canvas)return;const t=this.clearContextTop(!0);if(!t)return;const e=this._getCursorBoundaries(),n=this.findAncestorsWithClipPath(),r=n.length>0;let i,o=t;if(r){i=hs(t.canvas),o=i.getContext("2d"),kw(o,this.canvas);const a=this.calcTransformMatrix();o.transform(a[0],a[1],a[2],a[3],a[4],a[5])}if(this.selectionStart!==this.selectionEnd||this.inCompositionMode?this.renderSelection(o,e):this.renderCursor(o,e),r)for(const a of n){const l=a.clipPath,c=hs(t.canvas),u=c.getContext("2d");if(kw(u,this.canvas),!l.absolutePositioned){const h=a.calcTransformMatrix();u.transform(h[0],h[1],h[2],h[3],h[4],h[5])}l.transform(u),l.drawObject(u,!0,{}),this.drawClipPathOnCache(o,l,c)}r&&(t.setTransform(1,0,0,1,0,0),t.drawImage(i,0,0)),this.canvas.contextTopDirty=!0,t.restore()}findAncestorsWithClipPath(){const t=[];let e=this;for(;e;)e.clipPath&&t.push(e),e=e.parent;return t}_getCursorBoundaries(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.selectionStart,e=arguments.length>1?arguments[1]:void 0;const n=this._getLeftOffset(),r=this._getTopOffset(),i=this._getCursorBoundariesOffsets(t,e);return{left:n,top:r,leftOffset:i.left,topOffset:i.top}}_getCursorBoundariesOffsets(t,e){return e?this.__getCursorBoundariesOffsets(t):this.cursorOffsetCache&&"top"in this.cursorOffsetCache?this.cursorOffsetCache:this.cursorOffsetCache=this.__getCursorBoundariesOffsets(t)}__getCursorBoundariesOffsets(t){let e=0,n=0;const{charIndex:r,lineIndex:i}=this.get2DCursorLocation(t);for(let c=0;c<i;c++)e+=this.getHeightOfLine(c);const o=this._getLineLeftOffset(i),a=this.__charBounds[i][r];a&&(n=a.left),this.charSpacing!==0&&r===this._textLines[i].length&&(n-=this._getWidthOfCharSpacing());const l={top:e,left:o+(n>0?n:0)};return this.direction==="rtl"&&(this.textAlign===xe||this.textAlign===Ws||this.textAlign===Xl?l.left*=-1:this.textAlign===Vt||this.textAlign===Dd?l.left=o-(n>0?n:0):this.textAlign!==Et&&this.textAlign!==ql||(l.left=o-(n>0?n:0))),l}renderCursorAt(t){this._renderCursor(this.canvas.contextTop,this._getCursorBoundaries(t,!0),t)}renderCursor(t,e){this._renderCursor(t,e,this.selectionStart)}getCursorRenderingData(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.selectionStart,e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this._getCursorBoundaries(t);const n=this.get2DCursorLocation(t),r=n.lineIndex,i=n.charIndex>0?n.charIndex-1:0,o=this.getValueOfPropertyAt(r,i,"fontSize"),a=this.getObjectScaling().x*this.canvas.getZoom(),l=this.cursorWidth/a,c=this.getValueOfPropertyAt(r,i,"deltaY"),u=e.topOffset+(1-this._fontSizeFraction)*this.getHeightOfLine(r)/this.lineHeight-o*(1-this._fontSizeFraction);return{color:this.cursorColor||this.getValueOfPropertyAt(r,i,"fill"),opacity:this._currentCursorOpacity,left:e.left+e.leftOffset-l/2,top:u+e.top+c,width:l,height:o}}_renderCursor(t,e,n){const{color:r,opacity:i,left:o,top:a,width:l,height:c}=this.getCursorRenderingData(n,e);t.fillStyle=r,t.globalAlpha=i,t.fillRect(o,a,l,c)}renderSelection(t,e){const n={selectionStart:this.inCompositionMode?this.hiddenTextarea.selectionStart:this.selectionStart,selectionEnd:this.inCompositionMode?this.hiddenTextarea.selectionEnd:this.selectionEnd};this._renderSelection(t,n,e)}renderDragSourceEffect(){const t=this.draggableTextDelegate.getDragStartSelection();this._renderSelection(this.canvas.contextTop,t,this._getCursorBoundaries(t.selectionStart,!0))}renderDropTargetEffect(t){const e=this.getSelectionStartFromPointer(t);this.renderCursorAt(e)}_renderSelection(t,e,n){const r=e.selectionStart,i=e.selectionEnd,o=this.textAlign.includes(Ws),a=this.get2DCursorLocation(r),l=this.get2DCursorLocation(i),c=a.lineIndex,u=l.lineIndex,h=a.charIndex<0?0:a.charIndex,d=l.charIndex<0?0:l.charIndex;for(let p=c;p<=u;p++){const f=this._getLineLeftOffset(p)||0;let m=this.getHeightOfLine(p),g=0,y=0,b=0;if(p===c&&(y=this.__charBounds[c][h].left),p>=c&&p<u)b=o&&!this.isEndOfWrapping(p)?this.width:this.getLineWidth(p)||5;else if(p===u)if(d===0)b=this.__charBounds[u][d].left;else{const k=this._getWidthOfCharSpacing();b=this.__charBounds[u][d-1].left+this.__charBounds[u][d-1].width-k}g=m,(this.lineHeight<1||p===u&&this.lineHeight>1)&&(m/=this.lineHeight);let w=n.left+f+y,x=m,v=0;const C=b-y;this.inCompositionMode?(t.fillStyle=this.compositionColor||"black",x=1,v=m):t.fillStyle=this.selectionColor,this.direction==="rtl"&&(this.textAlign===xe||this.textAlign===Ws||this.textAlign===Xl?w=this.width-w-C:this.textAlign===Vt||this.textAlign===Dd?w=n.left+f-b:this.textAlign!==Et&&this.textAlign!==ql||(w=n.left+f-b)),t.fillRect(w,n.top+n.topOffset+v,C,x),n.topOffset+=g}}getCurrentCharFontSize(){const t=this._getCurrentCharIndex();return this.getValueOfPropertyAt(t.l,t.c,"fontSize")}getCurrentCharColor(){const t=this._getCurrentCharIndex();return this.getValueOfPropertyAt(t.l,t.c,Fe)}_getCurrentCharIndex(){const t=this.get2DCursorLocation(this.selectionStart,!0),e=t.charIndex>0?t.charIndex-1:0;return{l:t.lineIndex,c:e}}dispose(){this.exitEditingImpl(),this.draggableTextDelegate.dispose(),super.dispose()}}z(wr,"ownDefaults",$D),z(wr,"type","IText"),ut.setClass(wr),ut.setClass(wr,"i-text");class ji extends wr{static getDefaults(){return V(V({},super.getDefaults()),ji.ownDefaults)}constructor(t,e){super(t,V(V({},ji.ownDefaults),e))}static createControls(){return{controls:oE()}}initDimensions(){this.initialized&&(this.isEditing&&this.initDelayedCursor(),this._clearCache(),this.dynamicMinWidth=0,this._styleMap=this._generateStyleMap(this._splitText()),this.dynamicMinWidth>this.width&&this._set("width",this.dynamicMinWidth),this.textAlign.includes(Ws)&&this.enlargeSpaces(),this.height=this.calcTextHeight())}_generateStyleMap(t){let e=0,n=0,r=0;const i={};for(let o=0;o<t.graphemeLines.length;o++)t.graphemeText[r]===`
`&&o>0?(n=0,r++,e++):!this.splitByGrapheme&&this._reSpaceAndTab.test(t.graphemeText[r])&&o>0&&(n++,r++),i[o]={line:e,offset:n},r+=t.graphemeLines[o].length,n+=t.graphemeLines[o].length;return i}styleHas(t,e){if(this._styleMap&&!this.isWrapping){const n=this._styleMap[e];n&&(e=n.line)}return super.styleHas(t,e)}isEmptyStyles(t){if(!this.styles)return!0;let e,n=0,r=t+1,i=!1;const o=this._styleMap[t],a=this._styleMap[t+1];o&&(t=o.line,n=o.offset),a&&(r=a.line,i=r===t,e=a.offset);const l=t===void 0?this.styles:{line:this.styles[t]};for(const c in l)for(const u in l[c]){const h=parseInt(u,10);if(h>=n&&(!i||h<e))for(const d in l[c][u])return!1}return!0}_getStyleDeclaration(t,e){if(this._styleMap&&!this.isWrapping){const n=this._styleMap[t];if(!n)return{};t=n.line,e=n.offset+e}return super._getStyleDeclaration(t,e)}_setStyleDeclaration(t,e,n){const r=this._styleMap[t];super._setStyleDeclaration(r.line,r.offset+e,n)}_deleteStyleDeclaration(t,e){const n=this._styleMap[t];super._deleteStyleDeclaration(n.line,n.offset+e)}_getLineStyle(t){const e=this._styleMap[t];return!!this.styles[e.line]}_setLineStyle(t){const e=this._styleMap[t];super._setLineStyle(e.line)}_wrapText(t,e){this.isWrapping=!0;const n=this.getGraphemeDataForRender(t),r=[];for(let i=0;i<n.wordsData.length;i++)r.push(...this._wrapLine(i,e,n));return this.isWrapping=!1,r}getGraphemeDataForRender(t){const e=this.splitByGrapheme,n=e?"":" ";let r=0;return{wordsData:t.map(((i,o)=>{let a=0;const l=e?this.graphemeSplit(i):this.wordSplit(i);return l.length===0?[{word:[],width:0}]:l.map((c=>{const u=e?[c]:this.graphemeSplit(c),h=this._measureWord(u,o,a);return r=Math.max(h,r),a+=u.length+n.length,{word:u,width:h}}))})),largestWordWidth:r}}_measureWord(t,e){let n,r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,i=0;for(let o=0,a=t.length;o<a;o++)i+=this._getGraphemeBox(t[o],e,o+r,n,!0).kernedWidth,n=t[o];return i}wordSplit(t){return t.split(this._wordJoiners)}_wrapLine(t,e,n){let{largestWordWidth:r,wordsData:i}=n,o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:0;const a=this._getWidthOfCharSpacing(),l=this.splitByGrapheme,c=[],u=l?"":" ";let h=0,d=[],p=0,f=0,m=!0;e-=o;const g=Math.max(e,r,this.dynamicMinWidth),y=i[t];let b;for(p=0,b=0;b<y.length;b++){const{word:w,width:x}=y[b];p+=w.length,h+=f+x-a,h>g&&!m?(c.push(d),d=[],h=x,m=!0):h+=a,m||l||d.push(u),d=d.concat(w),f=l?0:this._measureWord([u],t,p),p++,m=!1}return b&&c.push(d),r+o>this.dynamicMinWidth&&(this.dynamicMinWidth=r-a+o),c}isEndOfWrapping(t){return!this._styleMap[t+1]||this._styleMap[t+1].line!==this._styleMap[t].line}missingNewlineOffset(t,e){return this.splitByGrapheme&&!e?this.isEndOfWrapping(t)?1:0:1}_splitTextIntoLines(t){const e=super._splitTextIntoLines(t),n=this._wrapText(e.lines,this.width),r=new Array(n.length);for(let i=0;i<n.length;i++)r[i]=n[i].join("");return e.lines=r,e.graphemeLines=n,e}getMinWidth(){return Math.max(this.minWidth,this.dynamicMinWidth)}_removeExtraneousStyles(){const t=new Map;for(const e in this._styleMap){const n=parseInt(e,10);if(this._textLines[n]){const r=this._styleMap[e].line;t.set("".concat(r),!0)}}for(const e in this.styles)t.has(e)||delete this.styles[e]}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];return super.toObject(["minWidth","splitByGrapheme",...t])}}z(ji,"type","Textbox"),z(ji,"textLayoutProperties",[...wr.textLayoutProperties,"width"]),z(ji,"ownDefaults",{minWidth:20,dynamicMinWidth:2,lockScalingFlip:!0,noScaleCache:!1,_wordJoiners:/[ \t\r]/,splitByGrapheme:!1}),ut.setClass(ji);class Iw extends bp{shouldPerformLayout(t){return!!t.target.clipPath&&super.shouldPerformLayout(t)}shouldLayoutClipPath(){return!1}calcLayoutResult(t,e){const{target:n}=t,{clipPath:r,group:i}=n;if(!r||!this.shouldPerformLayout(t))return;const{width:o,height:a}=vr(mS(n,r)),l=new q(o,a);if(r.absolutePositioned)return{center:Go(r.getRelativeCenterPoint(),void 0,i?i.calcTransformMatrix():void 0),size:l};{const c=r.getRelativeCenterPoint().transform(n.calcOwnMatrix(),!0);if(this.shouldPerformLayout(t)){const{center:u=new q,correction:h=new q}=this.calcBoundingBox(e,t)||{};return{center:u.add(c),correction:h.subtract(c),size:l}}return{center:n.getRelativeCenterPoint().add(c),size:l}}}}z(Iw,"type","clip-path"),ut.setClass(Iw);class Nw extends bp{getInitialSize(t,e){let{target:n}=t,{size:r}=e;return new q(n.width||r.x,n.height||r.y)}}z(Nw,"type","fixed"),ut.setClass(Nw);class _D extends nc{subscribeTargets(t){const e=t.target;t.targets.reduce(((n,r)=>(r.parent&&n.add(r.parent),n)),new Set).forEach((n=>{n.layoutManager.subscribeTargets({target:n,targets:[e]})}))}unsubscribeTargets(t){const e=t.target,n=e.getObjects();t.targets.reduce(((r,i)=>(i.parent&&r.add(i.parent),r)),new Set).forEach((r=>{!n.some((i=>i.parent===r))&&r.layoutManager.unsubscribeTargets({target:r,targets:[e]})}))}}class Hi extends Ki{static getDefaults(){return V(V({},super.getDefaults()),Hi.ownDefaults)}constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),Object.assign(this,Hi.ownDefaults),this.setOptions(e);const{left:n,top:r,layoutManager:i}=e;this.groupInit(t,{left:n,top:r,layoutManager:i??new _D})}_shouldSetNestedCoords(){return!0}__objectSelectionMonitor(){}multiSelectAdd(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];this.multiSelectionStacking==="selection-order"?this.add(...e):e.forEach((r=>{const i=this._objects.findIndex((a=>a.isInFrontOf(r))),o=i===-1?this.size():i;this.insertAt(o,r)}))}canEnterGroup(t){return this.getObjects().some((e=>e.isDescendantOf(t)||t.isDescendantOf(e)))?(ri("error","ActiveSelection: circular object trees are not supported, this call has no effect"),!1):super.canEnterGroup(t)}enterGroup(t,e){t.parent&&t.parent===t.group?t.parent._exitGroup(t):t.group&&t.parent!==t.group&&t.group.remove(t),this._enterGroup(t,e)}exitGroup(t,e){this._exitGroup(t,e),t.parent&&t.parent._enterGroup(t,!0)}_onAfterObjectsChange(t,e){super._onAfterObjectsChange(t,e);const n=new Set;e.forEach((r=>{const{parent:i}=r;i&&n.add(i)})),t===Yy?n.forEach((r=>{r._onAfterObjectsChange(Ad,e)})):n.forEach((r=>{r._set("dirty",!0)}))}onDeselect(){return this.removeAll(),!1}toString(){return"#<ActiveSelection: (".concat(this.complexity(),")>")}shouldCache(){return!1}isOnACache(){return!1}_renderControls(t,e,n){t.save(),t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1;const r=V(V({hasControls:!1},n),{},{forActiveSelection:!0});for(let i=0;i<this._objects.length;i++)this._objects[i]._renderControls(t,r);super._renderControls(t,e),t.restore()}}z(Hi,"type","ActiveSelection"),z(Hi,"ownDefaults",{multiSelectionStacking:"canvas-stacking"}),ut.setClass(Hi),ut.setClass(Hi,"activeSelection");class ED{constructor(){z(this,"resources",{})}applyFilters(t,e,n,r,i){const o=i.getContext("2d");if(!o)return;o.drawImage(e,0,0,n,r);const a={sourceWidth:n,sourceHeight:r,imageData:o.getImageData(0,0,n,r),originalEl:e,originalImageData:o.getImageData(0,0,n,r),canvasEl:i,ctx:o,filterBackend:this};t.forEach((c=>{c.applyTo(a)}));const{imageData:l}=a;return l.width===n&&l.height===r||(i.width=l.width,i.height=l.height),o.putImageData(l,0,0),a}}class DS{constructor(){let{tileSize:t=Mt.textureSize}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};z(this,"aPosition",new Float32Array([0,0,0,1,1,0,1,1])),z(this,"resources",{}),this.tileSize=t,this.setupGLContext(t,t),this.captureGPUInfo()}setupGLContext(t,e){this.dispose(),this.createWebGLCanvas(t,e)}createWebGLCanvas(t,e){const n=hs({width:t,height:e}),r=n.getContext("webgl",{alpha:!0,premultipliedAlpha:!1,depth:!1,stencil:!1,antialias:!1});r&&(r.clearColor(0,0,0,0),this.canvas=n,this.gl=r)}applyFilters(t,e,n,r,i,o){const a=this.gl,l=i.getContext("2d");if(!a||!l)return;let c;o&&(c=this.getCachedTexture(o,e));const u={originalWidth:e.width||e.naturalWidth||0,originalHeight:e.height||e.naturalHeight||0,sourceWidth:n,sourceHeight:r,destinationWidth:n,destinationHeight:r,context:a,sourceTexture:this.createTexture(a,n,r,c?void 0:e),targetTexture:this.createTexture(a,n,r),originalTexture:c||this.createTexture(a,n,r,c?void 0:e),passes:t.length,webgl:!0,aPosition:this.aPosition,programCache:this.programCache,pass:0,filterBackend:this,targetCanvas:i},h=a.createFramebuffer();return a.bindFramebuffer(a.FRAMEBUFFER,h),t.forEach((d=>{d&&d.applyTo(u)})),(function(d){const p=d.targetCanvas,f=p.width,m=p.height,g=d.destinationWidth,y=d.destinationHeight;f===g&&m===y||(p.width=g,p.height=y)})(u),this.copyGLTo2D(a,u),a.bindTexture(a.TEXTURE_2D,null),a.deleteTexture(u.sourceTexture),a.deleteTexture(u.targetTexture),a.deleteFramebuffer(h),l.setTransform(1,0,0,1,0,0),u}dispose(){this.canvas&&(this.canvas=null,this.gl=null),this.clearWebGLCaches()}clearWebGLCaches(){this.programCache={},this.textureCache={}}createTexture(t,e,n,r,i){const{NEAREST:o,TEXTURE_2D:a,RGBA:l,UNSIGNED_BYTE:c,CLAMP_TO_EDGE:u,TEXTURE_MAG_FILTER:h,TEXTURE_MIN_FILTER:d,TEXTURE_WRAP_S:p,TEXTURE_WRAP_T:f}=t,m=t.createTexture();return t.bindTexture(a,m),t.texParameteri(a,h,i||o),t.texParameteri(a,d,i||o),t.texParameteri(a,p,u),t.texParameteri(a,f,u),r?t.texImage2D(a,0,l,l,c,r):t.texImage2D(a,0,l,e,n,0,l,c,null),m}getCachedTexture(t,e,n){const{textureCache:r}=this;if(r[t])return r[t];{const i=this.createTexture(this.gl,e.width,e.height,e,n);return i&&(r[t]=i),i}}evictCachesForKey(t){this.textureCache[t]&&(this.gl.deleteTexture(this.textureCache[t]),delete this.textureCache[t])}copyGLTo2D(t,e){const n=t.canvas,r=e.targetCanvas,i=r.getContext("2d");if(!i)return;i.translate(0,r.height),i.scale(1,-1);const o=n.height-r.height;i.drawImage(n,0,o,r.width,r.height,0,0,r.width,r.height)}copyGLTo2DPutImageData(t,e){const n=e.targetCanvas.getContext("2d"),r=e.destinationWidth,i=e.destinationHeight,o=r*i*4;if(!n)return;const a=new Uint8Array(this.imageBuffer,0,o),l=new Uint8ClampedArray(this.imageBuffer,0,o);t.readPixels(0,0,r,i,t.RGBA,t.UNSIGNED_BYTE,a);const c=new ImageData(l,r,i);n.putImageData(c,0,0)}captureGPUInfo(){if(this.gpuInfo)return this.gpuInfo;const t=this.gl,e={renderer:"",vendor:""};if(!t)return e;const n=t.getExtension("WEBGL_debug_renderer_info");if(n){const r=t.getParameter(n.UNMASKED_RENDERER_WEBGL),i=t.getParameter(n.UNMASKED_VENDOR_WEBGL);r&&(e.renderer=r.toLowerCase()),i&&(e.vendor=i.toLowerCase())}return this.gpuInfo=e,e}}let Zm;function DD(){const{WebGLProbe:s}=Qs();return s.queryWebGL(Ir()),Mt.enableGLFiltering&&s.isSupported(Mt.textureSize)?new DS({tileSize:Mt.textureSize}):new ED}function Jm(){return!Zm&&(!(arguments.length>0&&arguments[0]!==void 0)||arguments[0])&&(Zm=DD()),Zm}const AD=["filters","resizeFilter","src","crossOrigin","type"],AS=["cropX","cropY"];class $n extends an{static getDefaults(){return V(V({},super.getDefaults()),$n.ownDefaults)}constructor(t,e){super(),z(this,"_lastScaleX",1),z(this,"_lastScaleY",1),z(this,"_filterScalingX",1),z(this,"_filterScalingY",1),this.filters=[],Object.assign(this,$n.ownDefaults),this.setOptions(e),this.cacheKey="texture".concat(ii()),this.setElement(typeof t=="string"?(this.canvas&&Ts(this.canvas.getElement())||da()).getElementById(t):t,e)}getElement(){return this._element}setElement(t){var e;let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.removeTexture(this.cacheKey),this.removeTexture("".concat(this.cacheKey,"_filtered")),this._element=t,this._originalElement=t,this._setWidthHeight(n),(e=t.classList)===null||e===void 0||e.add($n.CSS_CANVAS),this.filters.length!==0&&this.applyFilters(),this.resizeFilter&&this.applyResizeFilters()}removeTexture(t){const e=Jm(!1);e instanceof DS&&e.evictCachesForKey(t)}dispose(){super.dispose(),this.removeTexture(this.cacheKey),this.removeTexture("".concat(this.cacheKey,"_filtered")),this._cacheContext=null,["_originalElement","_element","_filteredEl","_cacheCanvas"].forEach((t=>{const e=this[t];e&&Qs().dispose(e),this[t]=void 0}))}getCrossOrigin(){return this._originalElement&&(this._originalElement.crossOrigin||null)}getOriginalSize(){const t=this.getElement();return t?{width:t.naturalWidth||t.width,height:t.naturalHeight||t.height}:{width:0,height:0}}_stroke(t){if(!this.stroke||this.strokeWidth===0)return;const e=this.width/2,n=this.height/2;t.beginPath(),t.moveTo(-e,-n),t.lineTo(e,-n),t.lineTo(e,n),t.lineTo(-e,n),t.lineTo(-e,-n),t.closePath()}toObject(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];const e=[];return this.filters.forEach((n=>{n&&e.push(n.toObject())})),V(V({},super.toObject([...AS,...t])),{},{src:this.getSrc(),crossOrigin:this.getCrossOrigin(),filters:e},this.resizeFilter?{resizeFilter:this.resizeFilter.toObject()}:{})}hasCrop(){return!!this.cropX||!!this.cropY||this.width<this._element.width||this.height<this._element.height}_toSVG(){const t=[],e=this._element,n=-this.width/2,r=-this.height/2;let i=[],o=[],a="",l="";if(!e)return[];if(this.hasCrop()){const c=ii();i.push('<clipPath id="imageCrop_'+c+`">
`,'	<rect x="'+n+'" y="'+r+'" width="'+this.width+'" height="'+this.height+`" />
`,`</clipPath>
`),a=' clip-path="url(#imageCrop_'+c+')" '}if(this.imageSmoothing||(l=' image-rendering="optimizeSpeed"'),t.push("	<image ","COMMON_PARTS",'xlink:href="'.concat(this.getSvgSrc(!0),'" x="').concat(n-this.cropX,'" y="').concat(r-this.cropY,'" width="').concat(e.width||e.naturalWidth,'" height="').concat(e.height||e.naturalHeight,'"').concat(l).concat(a,`></image>
`)),this.stroke||this.strokeDashArray){const c=this.fill;this.fill=null,o=['	<rect x="'.concat(n,'" y="').concat(r,'" width="').concat(this.width,'" height="').concat(this.height,'" style="').concat(this.getSvgStyles(),`" />
`)],this.fill=c}return i=this.paintFirst!==Fe?i.concat(o,t):i.concat(t,o),i}getSrc(t){const e=t?this._element:this._originalElement;return e?e.toDataURL?e.toDataURL():this.srcFromAttribute?e.getAttribute("src")||"":e.src:this.src||""}getSvgSrc(t){return this.getSrc(t)}setSrc(t){let{crossOrigin:e,signal:n}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return ud(t,{crossOrigin:e,signal:n}).then((r=>{e!==void 0&&this.set({crossOrigin:e}),this.setElement(r)}))}toString(){return'#<Image: { src: "'.concat(this.getSrc(),'" }>')}applyResizeFilters(){const t=this.resizeFilter,e=this.minimumScaleTrigger,n=this.getTotalObjectScaling(),r=n.x,i=n.y,o=this._filteredEl||this._originalElement;if(this.group&&this.set("dirty",!0),!t||r>e&&i>e)return this._element=o,this._filterScalingX=1,this._filterScalingY=1,this._lastScaleX=r,void(this._lastScaleY=i);const a=hs(o),{width:l,height:c}=o;this._element=a,this._lastScaleX=t.scaleX=r,this._lastScaleY=t.scaleY=i,Jm().applyFilters([t],o,l,c,this._element),this._filterScalingX=a.width/this._originalElement.width,this._filterScalingY=a.height/this._originalElement.height}applyFilters(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.filters||[];if(t=t.filter((i=>i&&!i.isNeutralState())),this.set("dirty",!0),this.removeTexture("".concat(this.cacheKey,"_filtered")),t.length===0)return this._element=this._originalElement,this._filteredEl=void 0,this._filterScalingX=1,void(this._filterScalingY=1);const e=this._originalElement,n=e.naturalWidth||e.width,r=e.naturalHeight||e.height;if(this._element===this._originalElement){const i=hs({width:n,height:r});this._element=i,this._filteredEl=i}else this._filteredEl&&(this._element=this._filteredEl,this._filteredEl.getContext("2d").clearRect(0,0,n,r),this._lastScaleX=1,this._lastScaleY=1);Jm().applyFilters(t,this._originalElement,n,r,this._element,this.cacheKey),this._originalElement.width===this._element.width&&this._originalElement.height===this._element.height||(this._filterScalingX=this._element.width/this._originalElement.width,this._filterScalingY=this._element.height/this._originalElement.height)}_render(t){t.imageSmoothingEnabled=this.imageSmoothing,this.isMoving!==!0&&this.resizeFilter&&this._needsResize()&&this.applyResizeFilters(),this._stroke(t),this._renderPaintInOrder(t)}drawCacheOnCanvas(t){t.imageSmoothingEnabled=this.imageSmoothing,super.drawCacheOnCanvas(t)}shouldCache(){return this.needsItsOwnCache()}_renderFill(t){const e=this._element;if(!e)return;const n=this._filterScalingX,r=this._filterScalingY,i=this.width,o=this.height,a=Math.max(this.cropX,0),l=Math.max(this.cropY,0),c=e.naturalWidth||e.width,u=e.naturalHeight||e.height,h=a*n,d=l*r,p=Math.min(i*n,c-h),f=Math.min(o*r,u-d),m=-i/2,g=-o/2,y=Math.min(i,c/n-a),b=Math.min(o,u/r-l);e&&t.drawImage(e,h,d,p,f,m,g,y,b)}_needsResize(){const t=this.getTotalObjectScaling();return t.x!==this._lastScaleX||t.y!==this._lastScaleY}_resetWidthHeight(){this.set(this.getOriginalSize())}_setWidthHeight(){let{width:t,height:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const n=this.getOriginalSize();this.width=t||n.width,this.height=e||n.height}parsePreserveAspectRatioAttribute(){const t=T_(this.preserveAspectRatio||""),e=this.width,n=this.height,r={width:e,height:n};let i,o=this._element.width,a=this._element.height,l=1,c=1,u=0,h=0,d=0,p=0;return!t||t.alignX===On&&t.alignY===On?(l=e/o,c=n/a):(t.meetOrSlice==="meet"&&(l=c=zE(this._element,r),i=(e-o*l)/2,t.alignX==="Min"&&(u=-i),t.alignX==="Max"&&(u=i),i=(n-a*c)/2,t.alignY==="Min"&&(h=-i),t.alignY==="Max"&&(h=i)),t.meetOrSlice==="slice"&&(l=c=VE(this._element,r),i=o-e/l,t.alignX==="Mid"&&(d=i/2),t.alignX==="Max"&&(d=i),i=a-n/c,t.alignY==="Mid"&&(p=i/2),t.alignY==="Max"&&(p=i),o=e/l,a=n/c)),{width:o,height:a,scaleX:l,scaleY:c,offsetLeft:u,offsetTop:h,cropX:d,cropY:p}}static fromObject(t,e){let{filters:n,resizeFilter:r,src:i,crossOrigin:o,type:a}=t,l=se(t,AD);return Promise.all([ud(i,V(V({},e),{},{crossOrigin:o})),n&&Jl(n,e),r&&Jl([r],e),fp(l,e)]).then((c=>{let[u,h=[],[d]=[],p={}]=c;return new this(u,V(V({},l),{},{src:i,filters:h,resizeFilter:d},p))}))}static fromURL(t){let{crossOrigin:e=null,signal:n}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;return ud(t,{crossOrigin:e,signal:n}).then((i=>new this(i,r)))}static async fromElement(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;const r=Fr(t,this.ATTRIBUTE_NAMES,n);return this.fromURL(r["xlink:href"]||r.href,e,r).catch((i=>(ri("log","Unable to parse Image",i),null)))}}z($n,"type","Image"),z($n,"cacheProperties",[...Rr,...AS]),z($n,"ownDefaults",{strokeWidth:0,srcFromAttribute:!1,minimumScaleTrigger:.5,cropX:0,cropY:0,imageSmoothing:!0}),z($n,"CSS_CANVAS","canvas-img"),z($n,"ATTRIBUTE_NAMES",[...xi,"x","y","width","height","preserveAspectRatio","xlink:href","href","crossOrigin","image-rendering"]),ut.setClass($n),ut.setSVGClass($n);gp(["pattern","defs","symbol","metadata","clipPath","mask","desc"]);const wp=s=>s.webgl!==void 0,Zy="precision highp float",OD=`
    `.concat(Zy,`;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`),RD=["type"],FD=["type"],PD=new RegExp(Zy,"g");class Pe{get type(){return this.constructor.type}constructor(){let t=se(arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},RD);Object.assign(this,this.constructor.defaults,t)}getFragmentSource(){return OD}getVertexSource(){return`
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`}createProgram(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.getFragmentSource(),n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:this.getVertexSource();const{WebGLProbe:{GLPrecision:r="highp"}}=Qs();r!=="highp"&&(e=e.replace(PD,Zy.replace("highp",r)));const i=t.createShader(t.VERTEX_SHADER),o=t.createShader(t.FRAGMENT_SHADER),a=t.createProgram();if(!i||!o||!a)throw new Us("Vertex, fragment shader or program creation error");if(t.shaderSource(i,n),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS))throw new Us("Vertex shader compile error for ".concat(this.type,": ").concat(t.getShaderInfoLog(i)));if(t.shaderSource(o,e),t.compileShader(o),!t.getShaderParameter(o,t.COMPILE_STATUS))throw new Us("Fragment shader compile error for ".concat(this.type,": ").concat(t.getShaderInfoLog(o)));if(t.attachShader(a,i),t.attachShader(a,o),t.linkProgram(a),!t.getProgramParameter(a,t.LINK_STATUS))throw new Us('Shader link error for "'.concat(this.type,'" ').concat(t.getProgramInfoLog(a)));const l=this.getUniformLocations(t,a)||{};return l.uStepW=t.getUniformLocation(a,"uStepW"),l.uStepH=t.getUniformLocation(a,"uStepH"),{program:a,attributeLocations:this.getAttributeLocations(t,a),uniformLocations:l}}getAttributeLocations(t,e){return{aPosition:t.getAttribLocation(e,"aPosition")}}getUniformLocations(t,e){const n=this.constructor.uniformLocations,r={};for(let i=0;i<n.length;i++)r[n[i]]=t.getUniformLocation(e,n[i]);return r}sendAttributeData(t,e,n){const r=e.aPosition,i=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,i),t.enableVertexAttribArray(r),t.vertexAttribPointer(r,2,t.FLOAT,!1,0,0),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)}_setupFrameBuffer(t){const e=t.context;if(t.passes>1){const n=t.destinationWidth,r=t.destinationHeight;t.sourceWidth===n&&t.sourceHeight===r||(e.deleteTexture(t.targetTexture),t.targetTexture=t.filterBackend.createTexture(e,n,r)),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t.targetTexture,0)}else e.bindFramebuffer(e.FRAMEBUFFER,null),e.finish()}_swapTextures(t){t.passes--,t.pass++;const e=t.targetTexture;t.targetTexture=t.sourceTexture,t.sourceTexture=e}isNeutralState(t){return!1}applyTo(t){wp(t)?(this._setupFrameBuffer(t),this.applyToWebGL(t),this._swapTextures(t)):this.applyTo2d(t)}applyTo2d(t){}getCacheKey(){return this.type}retrieveShader(t){const e=this.getCacheKey();return t.programCache[e]||(t.programCache[e]=this.createProgram(t.context)),t.programCache[e]}applyToWebGL(t){const e=t.context,n=this.retrieveShader(t);t.pass===0&&t.originalTexture?e.bindTexture(e.TEXTURE_2D,t.originalTexture):e.bindTexture(e.TEXTURE_2D,t.sourceTexture),e.useProgram(n.program),this.sendAttributeData(e,n.attributeLocations,t.aPosition),e.uniform1f(n.uniformLocations.uStepW,1/t.sourceWidth),e.uniform1f(n.uniformLocations.uStepH,1/t.sourceHeight),this.sendUniformData(e,n.uniformLocations),e.viewport(0,0,t.destinationWidth,t.destinationHeight),e.drawArrays(e.TRIANGLE_STRIP,0,4)}bindAdditionalTexture(t,e,n){t.activeTexture(n),t.bindTexture(t.TEXTURE_2D,e),t.activeTexture(t.TEXTURE0)}unbindAdditionalTexture(t,e){t.activeTexture(e),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE0)}sendUniformData(t,e){}createHelpLayer(t){if(!t.helpLayer){const{sourceWidth:e,sourceHeight:n}=t,r=hs({width:e,height:n});t.helpLayer=r}}toObject(){const t=Object.keys(this.constructor.defaults||{});return V({type:this.type},t.reduce(((e,n)=>(e[n]=this[n],e)),{}))}toJSON(){return this.toObject()}static async fromObject(t,e){return new this(se(t,FD))}}z(Pe,"type","BaseFilter"),z(Pe,"uniformLocations",[]);const LD={multiply:`gl_FragColor.rgb *= uColor.rgb;
`,screen:`gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`,add:`gl_FragColor.rgb += uColor.rgb;
`,difference:`gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`,subtract:`gl_FragColor.rgb -= uColor.rgb;
`,lighten:`gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`,darken:`gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`,exclusion:`gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`,overlay:`
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `,tint:`
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    `};class Ch extends Pe{getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return`
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(LD[this.mode],`
        }
      }
      `)}applyTo2d(t){let{imageData:{data:e}}=t;const n=new Gt(this.color).getSource(),r=this.alpha,i=n[0]*r,o=n[1]*r,a=n[2]*r,l=1-r;for(let c=0;c<e.length;c+=4){const u=e[c],h=e[c+1],d=e[c+2];let p,f,m;switch(this.mode){case"multiply":p=u*i/255,f=h*o/255,m=d*a/255;break;case"screen":p=255-(255-u)*(255-i)/255,f=255-(255-h)*(255-o)/255,m=255-(255-d)*(255-a)/255;break;case"add":p=u+i,f=h+o,m=d+a;break;case"difference":p=Math.abs(u-i),f=Math.abs(h-o),m=Math.abs(d-a);break;case"subtract":p=u-i,f=h-o,m=d-a;break;case"darken":p=Math.min(u,i),f=Math.min(h,o),m=Math.min(d,a);break;case"lighten":p=Math.max(u,i),f=Math.max(h,o),m=Math.max(d,a);break;case"overlay":p=i<128?2*u*i/255:255-2*(255-u)*(255-i)/255,f=o<128?2*h*o/255:255-2*(255-h)*(255-o)/255,m=a<128?2*d*a/255:255-2*(255-d)*(255-a)/255;break;case"exclusion":p=i+u-2*i*u/255,f=o+h-2*o*h/255,m=a+d-2*a*d/255;break;case"tint":p=i+u*l,f=o+h*l,m=a+d*l}e[c]=p,e[c+1]=f,e[c+2]=m}}sendUniformData(t,e){const n=new Gt(this.color).getSource();n[0]=this.alpha*n[0]/255,n[1]=this.alpha*n[1]/255,n[2]=this.alpha*n[2]/255,n[3]=this.alpha,t.uniform4fv(e.uColor,n)}}z(Ch,"defaults",{color:"#F95C63",mode:"multiply",alpha:1}),z(Ch,"type","BlendColor"),z(Ch,"uniformLocations",["uColor"]),ut.setClass(Ch);const MD={multiply:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `,mask:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    `},BD=["type","image"];class Th extends Pe{getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return MD[this.mode]}getVertexSource(){return`
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `}applyToWebGL(t){const e=t.context,n=this.createTexture(t.filterBackend,this.image);this.bindAdditionalTexture(e,n,e.TEXTURE1),super.applyToWebGL(t),this.unbindAdditionalTexture(e,e.TEXTURE1)}createTexture(t,e){return t.getCachedTexture(e.cacheKey,e.getElement())}calculateMatrix(){const t=this.image,{width:e,height:n}=t.getElement();return[1/t.scaleX,0,0,0,1/t.scaleY,0,-t.left/e,-t.top/n,1]}applyTo2d(t){let{imageData:{data:e,width:n,height:r},filterBackend:{resources:i}}=t;const o=this.image;i.blendImage||(i.blendImage=Ir());const a=i.blendImage,l=a.getContext("2d");a.width!==n||a.height!==r?(a.width=n,a.height=r):l.clearRect(0,0,n,r),l.setTransform(o.scaleX,0,0,o.scaleY,o.left,o.top),l.drawImage(o.getElement(),0,0,n,r);const c=l.getImageData(0,0,n,r).data;for(let u=0;u<e.length;u+=4){const h=e[u],d=e[u+1],p=e[u+2],f=e[u+3],m=c[u],g=c[u+1],y=c[u+2],b=c[u+3];switch(this.mode){case"multiply":e[u]=h*m/255,e[u+1]=d*g/255,e[u+2]=p*y/255,e[u+3]=f*b/255;break;case"mask":e[u+3]=b}}}sendUniformData(t,e){const n=this.calculateMatrix();t.uniform1i(e.uImage,1),t.uniformMatrix3fv(e.uTransformMatrix,!1,n)}toObject(){return V(V({},super.toObject()),{},{image:this.image&&this.image.toObject()})}static async fromObject(t,e){let{type:n,image:r}=t,i=se(t,BD);return $n.fromObject(r,e).then((o=>new this(V(V({},i),{},{image:o}))))}}z(Th,"type","BlendImage"),z(Th,"defaults",{mode:"multiply",alpha:1}),z(Th,"uniformLocations",["uTransformMatrix","uImage"]),ut.setClass(Th);class kh extends Pe{getFragmentSource(){return`
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float totalC = 0.0;
      float totalA = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);
        float weight = 1.0 - abs(percent);
        float alpha = weight * sample.a;
        color.rgb += sample.rgb * alpha;
        color.a += alpha;
        totalA += weight;
        totalC += alpha;
      }
      gl_FragColor.rgb = color.rgb / totalC;
      gl_FragColor.a = color.a / totalA;
    }
  `}applyTo(t){wp(t)?(this.aspectRatio=t.sourceWidth/t.sourceHeight,t.passes++,this._setupFrameBuffer(t),this.horizontal=!0,this.applyToWebGL(t),this._swapTextures(t),this._setupFrameBuffer(t),this.horizontal=!1,this.applyToWebGL(t),this._swapTextures(t)):this.applyTo2d(t)}applyTo2d(t){let{imageData:{data:e,width:n,height:r}}=t;this.aspectRatio=n/r,this.horizontal=!0;let i=this.getBlurValue()*n;const o=new Uint8ClampedArray(e),a=15,l=4*n;for(let c=0;c<e.length;c+=4){let u=0,h=0,d=0,p=0,f=0;const m=c-c%l,g=m+l;for(let y=-14;y<a;y++){const b=y/a,w=4*Math.floor(i*b),x=1-Math.abs(b);let v=c+w;v<m?v=m:v>g&&(v=g);const C=e[v+3]*x;u+=e[v]*C,h+=e[v+1]*C,d+=e[v+2]*C,p+=C,f+=x}o[c]=u/p,o[c+1]=h/p,o[c+2]=d/p,o[c+3]=p/f}this.horizontal=!1,i=this.getBlurValue()*r;for(let c=0;c<o.length;c+=4){let u=0,h=0,d=0,p=0,f=0;const m=c%l,g=o.length-l+m;for(let y=-14;y<a;y++){const b=y/a,w=Math.floor(i*b)*l,x=1-Math.abs(b);let v=c+w;v<m?v=m:v>g&&(v=g);const C=o[v+3]*x;u+=o[v]*C,h+=o[v+1]*C,d+=o[v+2]*C,p+=C,f+=x}e[c]=u/p,e[c+1]=h/p,e[c+2]=d/p,e[c+3]=p/f}}sendUniformData(t,e){const n=this.chooseRightDelta();t.uniform2fv(e.uDelta,n)}isNeutralState(){return this.blur===0}getBlurValue(){let t=1;const{horizontal:e,aspectRatio:n}=this;return e?n>1&&(t=1/n):n<1&&(t=n),t*this.blur*.12}chooseRightDelta(){const t=this.getBlurValue();return this.horizontal?[t,0]:[0,t]}}z(kh,"type","Blur"),z(kh,"defaults",{blur:0}),z(kh,"uniformLocations",["uDelta"]),ut.setClass(kh);class Ih extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`}applyTo2d(t){let{imageData:{data:e}}=t;const n=Math.round(255*this.brightness);for(let r=0;r<e.length;r+=4)e[r]+=n,e[r+1]+=n,e[r+2]+=n}isNeutralState(){return this.brightness===0}sendUniformData(t,e){t.uniform1f(e.uBrightness,this.brightness)}}z(Ih,"type","Brightness"),z(Ih,"defaults",{brightness:0}),z(Ih,"uniformLocations",["uBrightness"]),ut.setClass(Ih);const OS={matrix:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],colorsOnly:!0};class Uo extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`}applyTo2d(t){const e=t.imageData.data,n=this.matrix,r=this.colorsOnly;for(let i=0;i<e.length;i+=4){const o=e[i],a=e[i+1],l=e[i+2];if(e[i]=o*n[0]+a*n[1]+l*n[2]+255*n[4],e[i+1]=o*n[5]+a*n[6]+l*n[7]+255*n[9],e[i+2]=o*n[10]+a*n[11]+l*n[12]+255*n[14],!r){const c=e[i+3];e[i]+=c*n[3],e[i+1]+=c*n[8],e[i+2]+=c*n[13],e[i+3]=o*n[15]+a*n[16]+l*n[17]+c*n[18]+255*n[19]}}}sendUniformData(t,e){const n=this.matrix,r=[n[0],n[1],n[2],n[3],n[5],n[6],n[7],n[8],n[10],n[11],n[12],n[13],n[15],n[16],n[17],n[18]],i=[n[4],n[9],n[14],n[19]];t.uniformMatrix4fv(e.uColorMatrix,!1,r),t.uniform4fv(e.uConstants,i)}toObject(){return V(V({},super.toObject()),{},{matrix:[...this.matrix]})}}function yo(s,t){var e;const n=(z(e=class extends Uo{toObject(){return{type:this.type,colorsOnly:this.colorsOnly}}},"type",s),z(e,"defaults",{colorsOnly:!1,matrix:t}),e);return ut.setClass(n,s),n}z(Uo,"type","ColorMatrix"),z(Uo,"defaults",OS),z(Uo,"uniformLocations",["uColorMatrix","uConstants"]),ut.setClass(Uo);yo("Brownie",[.5997,.34553,-.27082,0,.186,-.0377,.86095,.15059,0,-.1449,.24113,-.07441,.44972,0,-.02965,0,0,0,1,0]);yo("Vintage",[.62793,.32021,-.03965,0,.03784,.02578,.64411,.03259,0,.02926,.0466,-.08512,.52416,0,.02023,0,0,0,1,0]);yo("Kodachrome",[1.12855,-.39673,-.03992,0,.24991,-.16404,1.08352,-.05498,0,.09698,-.16786,-.56034,1.60148,0,.13972,0,0,0,1,0]);yo("Technicolor",[1.91252,-.85453,-.09155,0,.04624,-.30878,1.76589,-.10601,0,-.27589,-.2311,-.75018,1.84759,0,.12137,0,0,0,1,0]);yo("Polaroid",[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0]);yo("Sepia",[.393,.769,.189,0,0,.349,.686,.168,0,0,.272,.534,.131,0,0,0,0,0,1,0]);yo("BlackWhite",[1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,0,0,0,1,0]);class $w extends Pe{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};super(t),this.subFilters=t.subFilters||[]}applyTo(t){wp(t)&&(t.passes+=this.subFilters.length-1),this.subFilters.forEach((e=>{e.applyTo(t)}))}toObject(){return{type:this.type,subFilters:this.subFilters.map((t=>t.toObject()))}}isNeutralState(){return!this.subFilters.some((t=>!t.isNeutralState()))}static fromObject(t,e){return Promise.all((t.subFilters||[]).map((n=>ut.getClass(n.type).fromObject(n,e)))).then((n=>new this({subFilters:n})))}}z($w,"type","Composed"),ut.setClass($w);class Nh extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`}isNeutralState(){return this.contrast===0}applyTo2d(t){let{imageData:{data:e}}=t;const n=Math.floor(255*this.contrast),r=259*(n+255)/(255*(259-n));for(let i=0;i<e.length;i+=4)e[i]=r*(e[i]-128)+128,e[i+1]=r*(e[i+1]-128)+128,e[i+2]=r*(e[i+2]-128)+128}sendUniformData(t,e){t.uniform1f(e.uContrast,this.contrast)}}z(Nh,"type","Contrast"),z(Nh,"defaults",{contrast:0}),z(Nh,"uniformLocations",["uContrast"]),ut.setClass(Nh);const zD={Convolute_3_1:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `,Convolute_3_0:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `,Convolute_5_1:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `,Convolute_5_0:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `,Convolute_7_1:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `,Convolute_7_0:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `,Convolute_9_1:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `,Convolute_9_0:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `};class $h extends Pe{getCacheKey(){return"".concat(this.type,"_").concat(Math.sqrt(this.matrix.length),"_").concat(this.opaque?1:0)}getFragmentSource(){return zD[this.getCacheKey()]}applyTo2d(t){const e=t.imageData,n=e.data,r=this.matrix,i=Math.round(Math.sqrt(r.length)),o=Math.floor(i/2),a=e.width,l=e.height,c=t.ctx.createImageData(a,l),u=c.data,h=this.opaque?1:0;let d,p,f,m,g,y,b,w,x,v,C,k,I;for(C=0;C<l;C++)for(v=0;v<a;v++){for(g=4*(C*a+v),d=0,p=0,f=0,m=0,I=0;I<i;I++)for(k=0;k<i;k++)b=C+I-o,y=v+k-o,b<0||b>=l||y<0||y>=a||(w=4*(b*a+y),x=r[I*i+k],d+=n[w]*x,p+=n[w+1]*x,f+=n[w+2]*x,h||(m+=n[w+3]*x));u[g]=d,u[g+1]=p,u[g+2]=f,u[g+3]=h?n[g+3]:m}t.imageData=c}sendUniformData(t,e){t.uniform1fv(e.uMatrix,this.matrix)}toObject(){return V(V({},super.toObject()),{},{opaque:this.opaque,matrix:[...this.matrix]})}}z($h,"type","Convolute"),z($h,"defaults",{opaque:!1,matrix:[0,0,0,0,1,0,0,0,0]}),z($h,"uniformLocations",["uMatrix","uOpaque","uHalfSize","uSize"]),ut.setClass($h);const RS="Gamma";class _h extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`}constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};super(t),this.gamma=t.gamma||this.constructor.defaults.gamma.concat()}applyTo2d(t){let{imageData:{data:e}}=t;const n=this.gamma,r=1/n[0],i=1/n[1],o=1/n[2];this.rgbValues||(this.rgbValues={r:new Uint8Array(256),g:new Uint8Array(256),b:new Uint8Array(256)});const a=this.rgbValues;for(let l=0;l<256;l++)a.r[l]=255*Math.pow(l/255,r),a.g[l]=255*Math.pow(l/255,i),a.b[l]=255*Math.pow(l/255,o);for(let l=0;l<e.length;l+=4)e[l]=a.r[e[l]],e[l+1]=a.g[e[l+1]],e[l+2]=a.b[e[l+2]]}sendUniformData(t,e){t.uniform3fv(e.uGamma,this.gamma)}isNeutralState(){const{gamma:t}=this;return t[0]===1&&t[1]===1&&t[2]===1}toObject(){return{type:RS,gamma:this.gamma.concat()}}}z(_h,"type",RS),z(_h,"defaults",{gamma:[1,1,1]}),z(_h,"uniformLocations",["uGamma"]),ut.setClass(_h);const VD={average:`
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `,lightness:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `,luminosity:`
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `};class Eh extends Pe{applyTo2d(t){let{imageData:{data:e}}=t;for(let n,r=0;r<e.length;r+=4){const i=e[r],o=e[r+1],a=e[r+2];switch(this.mode){case"average":n=(i+o+a)/3;break;case"lightness":n=(Math.min(i,o,a)+Math.max(i,o,a))/2;break;case"luminosity":n=.21*i+.72*o+.07*a}e[r+2]=e[r+1]=e[r]=n}}getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return VD[this.mode]}sendUniformData(t,e){t.uniform1i(e.uMode,1)}isNeutralState(){return!1}}z(Eh,"type","Grayscale"),z(Eh,"defaults",{mode:"average"}),z(Eh,"uniformLocations",["uMode"]),ut.setClass(Eh);const WD=V(V({},OS),{},{rotation:0});class Qm extends Uo{calculateMatrix(){const t=this.rotation*Math.PI,e=Tr(t),n=kr(t),r=1/3,i=Math.sqrt(r)*n,o=1-e;this.matrix=[e+o/3,r*o-i,r*o+i,0,0,r*o+i,e+r*o,r*o-i,0,0,r*o-i,r*o+i,e+r*o,0,0,0,0,0,1,0]}isNeutralState(){return this.rotation===0}applyTo(t){this.calculateMatrix(),super.applyTo(t)}toObject(){return{type:this.type,rotation:this.rotation}}}z(Qm,"type","HueRotation"),z(Qm,"defaults",WD),ut.setClass(Qm);class Dh extends Pe{applyTo2d(t){let{imageData:{data:e}}=t;for(let n=0;n<e.length;n+=4)e[n]=255-e[n],e[n+1]=255-e[n+1],e[n+2]=255-e[n+2],this.alpha&&(e[n+3]=255-e[n+3])}getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`}isNeutralState(){return!this.invert}sendUniformData(t,e){t.uniform1i(e.uInvert,Number(this.invert)),t.uniform1i(e.uAlpha,Number(this.alpha))}}z(Dh,"type","Invert"),z(Dh,"defaults",{alpha:!1,invert:!0}),z(Dh,"uniformLocations",["uInvert","uAlpha"]),ut.setClass(Dh);class Ah extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`}applyTo2d(t){let{imageData:{data:e}}=t;const n=this.noise;for(let r=0;r<e.length;r+=4){const i=(.5-Math.random())*n;e[r]+=i,e[r+1]+=i,e[r+2]+=i}}sendUniformData(t,e){t.uniform1f(e.uNoise,this.noise/255),t.uniform1f(e.uSeed,Math.random())}isNeutralState(){return this.noise===0}}z(Ah,"type","Noise"),z(Ah,"defaults",{noise:0}),z(Ah,"uniformLocations",["uNoise","uSeed"]),ut.setClass(Ah);class Oh extends Pe{applyTo2d(t){let{imageData:{data:e,width:n,height:r}}=t;for(let i=0;i<r;i+=this.blocksize)for(let o=0;o<n;o+=this.blocksize){const a=4*i*n+4*o,l=e[a],c=e[a+1],u=e[a+2],h=e[a+3];for(let d=i;d<Math.min(i+this.blocksize,r);d++)for(let p=o;p<Math.min(o+this.blocksize,n);p++){const f=4*d*n+4*p;e[f]=l,e[f+1]=c,e[f+2]=u,e[f+3]=h}}}isNeutralState(){return this.blocksize===1}getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`}sendUniformData(t,e){t.uniform1f(e.uBlocksize,this.blocksize)}}z(Oh,"type","Pixelate"),z(Oh,"defaults",{blocksize:4}),z(Oh,"uniformLocations",["uBlocksize"]),ut.setClass(Oh);class Rh extends Pe{getFragmentSource(){return`
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`}applyTo2d(t){let{imageData:{data:e}}=t;const n=255*this.distance,r=new Gt(this.color).getSource(),i=[r[0]-n,r[1]-n,r[2]-n],o=[r[0]+n,r[1]+n,r[2]+n];for(let a=0;a<e.length;a+=4){const l=e[a],c=e[a+1],u=e[a+2];l>i[0]&&c>i[1]&&u>i[2]&&l<o[0]&&c<o[1]&&u<o[2]&&(e[a+3]=0)}}sendUniformData(t,e){const n=new Gt(this.color).getSource(),r=this.distance,i=[0+n[0]/255-r,0+n[1]/255-r,0+n[2]/255-r,1],o=[n[0]/255+r,n[1]/255+r,n[2]/255+r,1];t.uniform4fv(e.uLow,i),t.uniform4fv(e.uHigh,o)}}z(Rh,"type","RemoveColor"),z(Rh,"defaults",{color:"#FFFFFF",distance:.02,useAlpha:!1}),z(Rh,"uniformLocations",["uLow","uHigh"]),ut.setClass(Rh);class Fh extends Pe{sendUniformData(t,e){t.uniform2fv(e.uDelta,this.horizontal?[1/this.width,0]:[0,1/this.height]),t.uniform1fv(e.uTaps,this.taps)}getFilterWindow(){const t=this.tempScale;return Math.ceil(this.lanczosLobes/t)}getCacheKey(){const t=this.getFilterWindow();return"".concat(this.type,"_").concat(t)}getFragmentSource(){const t=this.getFilterWindow();return this.generateShader(t)}getTaps(){const t=this.lanczosCreate(this.lanczosLobes),e=this.tempScale,n=this.getFilterWindow(),r=new Array(n);for(let i=1;i<=n;i++)r[i-1]=t(i*e);return r}generateShader(t){const e=new Array(t);for(let n=1;n<=t;n++)e[n-1]="".concat(n,".0 * uDelta");return`
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(t,`];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(e.map(((n,r)=>`
              color += texture2D(uTexture, vTexCoord + `.concat(n,") * uTaps[").concat(r,"] + texture2D(uTexture, vTexCoord - ").concat(n,") * uTaps[").concat(r,`];
              sum += 2.0 * uTaps[`).concat(r,`];
            `))).join(`
`),`
        gl_FragColor = color / sum;
      }
    `)}applyToForWebgl(t){t.passes++,this.width=t.sourceWidth,this.horizontal=!0,this.dW=Math.round(this.width*this.scaleX),this.dH=t.sourceHeight,this.tempScale=this.dW/this.width,this.taps=this.getTaps(),t.destinationWidth=this.dW,super.applyTo(t),t.sourceWidth=t.destinationWidth,this.height=t.sourceHeight,this.horizontal=!1,this.dH=Math.round(this.height*this.scaleY),this.tempScale=this.dH/this.height,this.taps=this.getTaps(),t.destinationHeight=this.dH,super.applyTo(t),t.sourceHeight=t.destinationHeight}applyTo(t){wp(t)?this.applyToForWebgl(t):this.applyTo2d(t)}isNeutralState(){return this.scaleX===1&&this.scaleY===1}lanczosCreate(t){return e=>{if(e>=t||e<=-t)return 0;if(e<11920929e-14&&e>-11920929e-14)return 1;const n=(e*=Math.PI)/t;return Math.sin(e)/e*Math.sin(n)/n}}applyTo2d(t){const e=t.imageData,n=this.scaleX,r=this.scaleY;this.rcpScaleX=1/n,this.rcpScaleY=1/r;const i=e.width,o=e.height,a=Math.round(i*n),l=Math.round(o*r);let c;c=this.resizeType==="sliceHack"?this.sliceByTwo(t,i,o,a,l):this.resizeType==="hermite"?this.hermiteFastResize(t,i,o,a,l):this.resizeType==="bilinear"?this.bilinearFiltering(t,i,o,a,l):this.resizeType==="lanczos"?this.lanczosResize(t,i,o,a,l):new ImageData(a,l),t.imageData=c}sliceByTwo(t,e,n,r,i){const o=t.imageData,a=.5;let l=!1,c=!1,u=e*a,h=n*a;const d=t.filterBackend.resources;let p=0,f=0;const m=e;let g=0;d.sliceByTwo||(d.sliceByTwo=Ir());const y=d.sliceByTwo;(y.width<1.5*e||y.height<n)&&(y.width=1.5*e,y.height=n);const b=y.getContext("2d");for(b.clearRect(0,0,1.5*e,n),b.putImageData(o,0,0),r=Math.floor(r),i=Math.floor(i);!l||!c;)e=u,n=h,r<Math.floor(u*a)?u=Math.floor(u*a):(u=r,l=!0),i<Math.floor(h*a)?h=Math.floor(h*a):(h=i,c=!0),b.drawImage(y,p,f,e,n,m,g,u,h),p=m,f=g,g+=h;return b.getImageData(p,f,r,i)}lanczosResize(t,e,n,r,i){const o=t.imageData.data,a=t.ctx.createImageData(r,i),l=a.data,c=this.lanczosCreate(this.lanczosLobes),u=this.rcpScaleX,h=this.rcpScaleY,d=2/this.rcpScaleX,p=2/this.rcpScaleY,f=Math.ceil(u*this.lanczosLobes/2),m=Math.ceil(h*this.lanczosLobes/2),g={},y={x:0,y:0},b={x:0,y:0};return(function w(x){let v,C,k,I,N,_,T,D,R,P,B;for(y.x=(x+.5)*u,b.x=Math.floor(y.x),v=0;v<i;v++){for(y.y=(v+.5)*h,b.y=Math.floor(y.y),N=0,_=0,T=0,D=0,R=0,C=b.x-f;C<=b.x+f;C++)if(!(C<0||C>=e)){P=Math.floor(1e3*Math.abs(C-y.x)),g[P]||(g[P]={});for(let U=b.y-m;U<=b.y+m;U++)U<0||U>=n||(B=Math.floor(1e3*Math.abs(U-y.y)),g[P][B]||(g[P][B]=c(Math.sqrt(Math.pow(P*d,2)+Math.pow(B*p,2))/1e3)),k=g[P][B],k>0&&(I=4*(U*e+C),N+=k,_+=k*o[I],T+=k*o[I+1],D+=k*o[I+2],R+=k*o[I+3]))}I=4*(v*r+x),l[I]=_/N,l[I+1]=T/N,l[I+2]=D/N,l[I+3]=R/N}return++x<r?w(x):a})(0)}bilinearFiltering(t,e,n,r,i){let o,a,l,c,u,h,d,p,f,m,g,y,b,w=0;const x=this.rcpScaleX,v=this.rcpScaleY,C=4*(e-1),k=t.imageData.data,I=t.ctx.createImageData(r,i),N=I.data;for(d=0;d<i;d++)for(p=0;p<r;p++)for(u=Math.floor(x*p),h=Math.floor(v*d),f=x*p-u,m=v*d-h,b=4*(h*e+u),g=0;g<4;g++)o=k[b+g],a=k[b+4+g],l=k[b+C+g],c=k[b+C+4+g],y=o*(1-f)*(1-m)+a*f*(1-m)+l*m*(1-f)+c*f*m,N[w++]=y;return I}hermiteFastResize(t,e,n,r,i){const o=this.rcpScaleX,a=this.rcpScaleY,l=Math.ceil(o/2),c=Math.ceil(a/2),u=t.imageData.data,h=t.ctx.createImageData(r,i),d=h.data;for(let p=0;p<i;p++)for(let f=0;f<r;f++){const m=4*(f+p*r);let g=0,y=0,b=0,w=0,x=0,v=0,C=0;const k=(p+.5)*a;for(let I=Math.floor(p*a);I<(p+1)*a;I++){const N=Math.abs(k-(I+.5))/c,_=(f+.5)*o,T=N*N;for(let D=Math.floor(f*o);D<(f+1)*o;D++){let R=Math.abs(_-(D+.5))/l;const P=Math.sqrt(T+R*R);P>1&&P<-1||(g=2*P*P*P-3*P*P+1,g>0&&(R=4*(D+I*e),C+=g*u[R+3],b+=g,u[R+3]<255&&(g=g*u[R+3]/250),w+=g*u[R],x+=g*u[R+1],v+=g*u[R+2],y+=g))}}d[m]=w/y,d[m+1]=x/y,d[m+2]=v/y,d[m+3]=C/b}return h}}z(Fh,"type","Resize"),z(Fh,"defaults",{resizeType:"hermite",scaleX:1,scaleY:1,lanczosLobes:3}),z(Fh,"uniformLocations",["uDelta","uTaps"]),ut.setClass(Fh);class Ph extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`}applyTo2d(t){let{imageData:{data:e}}=t;const n=-this.saturation;for(let r=0;r<e.length;r+=4){const i=e[r],o=e[r+1],a=e[r+2],l=Math.max(i,o,a);e[r]+=l!==i?(l-i)*n:0,e[r+1]+=l!==o?(l-o)*n:0,e[r+2]+=l!==a?(l-a)*n:0}}sendUniformData(t,e){t.uniform1f(e.uSaturation,-this.saturation)}isNeutralState(){return this.saturation===0}}z(Ph,"type","Saturation"),z(Ph,"defaults",{saturation:0}),z(Ph,"uniformLocations",["uSaturation"]),ut.setClass(Ph);class Lh extends Pe{getFragmentSource(){return`
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`}applyTo2d(t){let{imageData:{data:e}}=t;const n=-this.vibrance;for(let r=0;r<e.length;r+=4){const i=e[r],o=e[r+1],a=e[r+2],l=Math.max(i,o,a),c=(i+o+a)/3,u=2*Math.abs(l-c)/255*n;e[r]+=l!==i?(l-i)*u:0,e[r+1]+=l!==o?(l-o)*u:0,e[r+2]+=l!==a?(l-a)*u:0}}sendUniformData(t,e){t.uniform1f(e.uVibrance,-this.vibrance)}isNeutralState(){return this.vibrance===0}}z(Lh,"type","Vibrance"),z(Lh,"defaults",{vibrance:0}),z(Lh,"uniformLocations",["uVibrance"]),ut.setClass(Lh);const UD=1e-7,GD=1e-4;class Jy{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class vp{refCount(t){return Tn("refCount")}incRef(t){return Tn("incRef")}timerAvailable(){return!0}time(t){return Tn("time")}read(t){return Tn("read")}readSync(t){return Tn("readSync")}readToGPU(t,e){return Tn("readToGPU")}numDataIds(){return Tn("numDataIds")}disposeData(t,e){return Tn("disposeData")}write(t,e,n){return Tn("write")}move(t,e,n,r,i){return Tn("move")}createTensorFromGPUData(t,e,n){return Tn("createTensorFromGPUData")}memory(){return Tn("memory")}floatPrecision(){return Tn("floatPrecision")}epsilon(){return this.floatPrecision()===32?UD:GD}dispose(){return Tn("dispose")}}function Tn(s){throw new Error(`'${s}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Qy(s){let t=s.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,yr(s,t,e)}function jD(s,t){if(s.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${s.length}Second array length was ${t.length}`);let e=s.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,yr(s,e,n),yr(t,e,n)}function oi(s,t,e){return Math.max(s,Math.min(t,e))}function Sp(s){return s%2===0?s:s+1}function yr(s,t,e){const n=s[t];s[t]=s[e],s[e]=n}function FS(s){let t=0;for(let e=0;e<s.length;e++)t+=s[e];return t}function HD(s,t){const e=Math.random();return t*e+(1-e)*s}function XD(s,t){let e=0;for(let n=0;n<s.length;n++){const r=Number(s[n])-Number(t[n]);e+=r*r}return e}function $(s,t){if(!s)throw new Error(typeof t=="string"?t:t())}function He(s,t,e=""){$(Dt(s,t),()=>e+` Shapes ${s} and ${t} must match`)}function bo(s){$(s!=null,()=>"The input to the tensor constructor must be a non-null value.")}function K(s){if(s.length===0)return 1;let t=s[0];for(let e=1;e<s.length;e++)t*=s[e];return t}function qD(s){return s.length===0}function PS(s,t){if(s===t)return!0;if(s==null||t==null||s.length!==t.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==null&&t[e]!==null&&s[e]!==t[e])return!1;return!0}function Dt(s,t){if(s===t)return!0;if(s==null||t==null||s.length!==t.length)return!1;for(let e=0;e<s.length;e++)if(s[e]!==t[e])return!1;return!0}function no(s){return s%1===0}function KD(s){if(Math.tanh!=null)return Math.tanh(s);if(s===1/0)return 1;if(s===-1/0)return-1;{const t=Math.exp(2*s);return(t-1)/(t+1)}}function Fd(s){const t=Math.ceil(Math.sqrt(s));return[t,Math.ceil(s/t)]}function YD(s){const t=new Uint32Array(s);for(let e=0;e<s;++e)t[e]=e;return Qy(t),t}function Yi(s,t){return t<=s.length?s:s+" ".repeat(t-s.length)}function Lg(s,t=r=>0,e,n){return new Promise((r,i)=>{let o=0;const a=()=>{if(s()){r();return}o++;const l=t(o);if(e!=null&&o>=e){i();return}n!=null?n(a,l):setTimeout(a,l)};a()})}function t0(s,t){let e=1,n=-1;for(let i=0;i<s.length;++i)if(s[i]>=0)e*=s[i];else if(s[i]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${i}`);n=i}else if(s[i]<0)throw Error(`Shapes can not be < 0. Found ${s[i]} at dim ${i}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${s}`);return s}if(e===0)throw Error(`Cannot infer the missing size in [${s}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=s.slice();return r[n]=t/e,r}function $t(s,t){const e=t.length;return s=s==null?t.map((n,r)=>r):[].concat(s),$(s.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${s}`),$(s.every(n=>no(n)),()=>`All values in axis param must be integers but got axis ${s}`),s.map(n=>n<0?e+n:n)}function Pr(s,t){const e=[],n=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:$t(t,s).sort();let o=0;for(let a=0;a<s.length;++a){if(i!=null){if(i[o]===a&&s[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${s[a]}' is not 1`);(i[o]==null||i[o]>a)&&s[a]===1&&(e.push(s[a]),n.push(a)),i[o]<=a&&o++}s[a]!==1&&(e.push(s[a]),n.push(a))}return{newShape:e,keptDims:n}}function Le(s,t){return de(s,t)}function de(s,t){let e=null;if(s==null||s==="float32")e=new Float32Array(t);else if(s==="int32")e=new Int32Array(t);else if(s==="bool")e=new Uint8Array(t);else if(s==="string")e=new Array(t);else throw new Error(`Unknown data type ${s}`);return e}function LS(s,t){for(let e=0;e<s.length;e++){const n=s[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function MS(s){return s==="bool"||s==="complex64"||s==="float32"||s==="int32"||s==="string"}function e0(s,t){return!(t==="complex64"||t==="float32"&&s!=="complex64"||t==="int32"&&s!=="float32"&&s!=="complex64"||t==="bool"&&s==="bool")}function sc(s){if(s==="float32"||s==="int32")return 4;if(s==="complex64")return 8;if(s==="bool")return 1;throw new Error(`Unknown dtype ${s}`)}function BS(s){if(s==null)return 0;let t=0;return s.forEach(e=>t+=e.length),t}function Gs(s){return typeof s=="string"||s instanceof String}function zS(s){return typeof s=="boolean"}function Pd(s){return typeof s=="number"}function xo(s){return Array.isArray(s)?xo(s[0]):s instanceof Float32Array?"float32":s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray?"int32":Pd(s)?"float32":Gs(s)?"string":zS(s)?"bool":"float32"}function ai(s){return!!(s&&s.constructor&&s.call&&s.apply)}function Ld(s,t){for(let e=t;e<s;++e)if(s%e===0)return e;return s}function yt(s){const t=s.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=s[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*s[n+1];return e}function VS(s,t,e,n=!1){const r=new Array;if(t.length===1){const i=t[0]*(n?2:1);for(let o=0;o<i;o++)r[o]=e[s+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(n?2:1);for(let l=0;l<i;l++)r[l]=VS(s+l*a,o,e,n)}return r}function Kn(s,t,e=!1){if(s.length===0)return t[0];const n=s.reduce((r,i)=>r*i)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${s}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return VS(0,s,t,e)}function WS(s,t){if(Array.isArray(s))return s;if(t==="float32")return s instanceof Float32Array?s:new Float32Array(s);if(t==="int32")return s instanceof Int32Array?s:new Int32Array(s);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(s));throw new Error(`Unknown dtype ${t}`)}function Cp(s,t){const e=je(s,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function je(s,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(s);if(t==="int32")return new Int32Array(s);if(t==="bool")return new Uint8Array(s);throw new Error(`Unknown data type ${t}`)}function n0(s,t){const e=s.reduce((n,r)=>n*r,1);if(t==null||t==="float32")return Kn(s,new Float32Array(e));if(t==="int32")return Kn(s,new Int32Array(e));if(t==="bool")return Kn(s,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Vn(s){s.forEach(t=>{$(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${s}].`)})}function $s(s,t,e){if(t===0)return 0;if(t===1)return s[0];let n=s[s.length-1];for(let r=0;r<s.length-1;++r)n+=e[r]*s[r];return n}function wo(s,t,e){if(t===0)return[];if(t===1)return[s];const n=new Array(t);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(s/e[r]),s-=n[r]*e[r];return n[n.length-1]=s,n}function li(s){return s&&s.then&&typeof s.then=="function"}const _w="tfjsflags";class US{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ZD,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){const r=this.urlFlags[t];j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(li(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);_w in t&&t[_w].split(",").forEach(n=>{const[r,i]=n.split(":");this.urlFlags[r]=QD(r,i)})}}function ZD(s){const t={};return s.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(JD(t,n[0],n[1]),n.join("="))),t}function JD(s,t,e){s[decodeURIComponent(t)]=decodeURIComponent(e||"")}function QD(s,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function j(){return s0}let s0=null;function tA(s){s0=s}let tg;function GS(){if(tg==null){let s;if(typeof window<"u")s=window;else if(typeof global<"u")s=global;else if(typeof process<"u")s=process;else if(typeof self<"u")s=self;else throw new Error("Could not find a global object");tg=s}return tg}function eA(){const s=GS();return s._tfGlobals==null&&(s._tfGlobals=new Map),s._tfGlobals}function r0(s,t){const e=eA();if(e.has(s))return e.get(s);{const n=t();return e.set(s,n),e.get(s)}}const Ic="Abs",xa="Acos",wa="Acosh",vo="Add",Nc="AddN",Tp="All",kp="Any",$c="ArgMax",_c="ArgMin",va="Asin",Sa="Asinh",Ca="Atan",Ta="Atanh",ka="Atan2",Ec="AvgPool",Ip="AvgPoolGrad",Dc="AvgPool3D",Np="AvgPool3DGrad",Ac="BatchMatMul",Oc="BatchToSpaceND",$p="Bincount",Rc="BitwiseAnd",jS="BroadcastTo",_p="BroadcastArgs",Ia="Cast",Na="Ceil",$a="ClipByValue",Ep="Complex",Fc="ComplexAbs",Pc="Concat",Lc="Conv2D",Dp="Conv2DBackpropFilter",Mc="Conv2DBackpropInput",Bc="Conv3D",Ap="Conv3DBackpropFilterV2",Op="Conv3DBackpropInputV2",_a="Cos",Ea="Cosh",Rp="Cumprod",zc="Cumsum",Fp="CropAndResize",Pp="DenseBincount",Lp="DepthToSpace",Vc="DepthwiseConv2dNative",Mp="DepthwiseConv2dNativeBackpropFilter",Bp="DepthwiseConv2dNativeBackpropInput",zp="Diag",Wc="Dilation2D",Md="Dilation2DBackpropInput",Bd="Dilation2DBackpropFilter",Vp="Draw",Da="RealDiv",Wp="Einsum",Aa="Elu",Up="EluGrad",Oa="Erf",Uc="Equal",Ra="Exp",Gc="ExpandDims",Fa="Expm1",Gp="FFT",jp="Fill",Hp="FlipLeftRight",Pa="Floor",La="FloorDiv",jc="FusedBatchNorm",Hc="GatherV2",Xp="GatherNd",Xc="Greater",Ma="GreaterEqual",Ba="Identity",qp="IFFT",Kp="Imag",za="IsFinite",Va="IsInf",Wa="IsNan",qc="LeakyRelu",Kc="Less",Yc="LessEqual",Yp="LinSpace",Ua="Log",Ga="Log1p",Zc="LogicalAnd",Jc="LogicalNot",Qc="LogicalOr",nA="LogicalXor",HS="LogSoftmax",sA="LowerBound",tu="LRN",Zp="LRNGrad",rA="MatrixBandPart",eu="Max",ja="Maximum",nu="MaxPool",Jp="MaxPoolGrad",su="MaxPool3D",Qp="MaxPool3DGrad",tf="MaxPoolWithArgmax",ru="Mean",iu="Min",Ha="Minimum",ou="MirrorPad",Xa="Mod",ef="Multinomial",qa="Multiply",au="Neg",lu="NotEqual",nf="NonMaxSuppressionV3",sf="NonMaxSuppressionV4",rf="NonMaxSuppressionV5",cu="OnesLike",uu="OneHot",hu="Pack",du="PadV2",iA="Pool",Ka="Pow",pu="Prelu",fu="Prod",of="RaggedGather",af="RaggedRange",lf="RaggedTensorToTensor",cf="Range",uf="Real",Ya="Reciprocal",Za="Relu",mu="Reshape",gu="ResizeNearestNeighbor",hf="ResizeNearestNeighborGrad",yu="ResizeBilinear",df="ResizeBilinearGrad",Ja="Relu6",bu="Reverse",Qa="Round",tl="Rsqrt",pf="ScatterNd",ff="TensorScatterUpdate",mf="SearchSorted",xu="Select",el="Selu",wu="Slice",nl="Sin",sl="Sinh",rl="Sign",il="Sigmoid",ol="Softplus",al="Sqrt",vu="Sum",Su="SpaceToBatchND",Cu="SplitV",Tu="Softmax",gf="SparseFillEmptyRows",yf="SparseReshape",bf="SparseSegmentMean",xf="SparseSegmentSum",wf="SparseToDense",ll="SquaredDifference",vf="Square",ku="StaticRegexReplace",Sf="StridedSlice",Cf="StringNGrams",Tf="StringSplit",kf="StringToHashBucketFast",cl="Sub",ul="Tan",hl="Tanh",dl="Tile",If="TopK",Nf="Transform",Zi="Transpose",$f="Unique",Iu="Unpack",Nu="UnsortedSegmentSum",oA="UpperBound",$u="ZerosLike",pl="Step",zd="FromPixels",_f="RotateWithOffset",rc="_FusedMatMul",ic="FusedConv2D",oc="FusedDepthwiseConv2D";function jn(...s){j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(...s)}function aA(...s){j().getBool("IS_TEST")||j().getBool("PROD")||console.log(...s)}const Qo=r0("kernelRegistry",()=>new Map),ac=r0("gradRegistry",()=>new Map);function lc(s,t){const e=i0(s,t);return Qo.get(e)}function Mg(s){return ac.get(s)}function Vd(s){const t=Qo.entries(),e=[];for(;;){const{done:n,value:r}=t.next();if(n)break;const[i,o]=r,[a]=i.split("_");a===s&&e.push(o)}return e}function Ef(s){const{kernelName:t,backendName:e}=s,n=i0(t,e);Qo.has(n)&&jn(`The kernel '${t}' for backend '${e}' is already registered`),Qo.set(n,s)}function XS(s){const{kernelName:t}=s;ac.has(t)&&j().getBool("DEBUG")&&jn(`Overriding the gradient for '${t}'`),ac.set(t,s)}function lA(s,t){const e=i0(s,t);if(!Qo.has(e))throw new Error(`The kernel '${s}' for backend '${t}' is not registered`);Qo.delete(e)}function cA(s){if(!ac.has(s))throw new Error(`The gradient '${s}' for backend is not registered`);ac.delete(s)}function uA(s,t){Vd(s).forEach(n=>{const r=Object.assign({},n,{backendName:t});Ef(r)})}function i0(s,t){return`${t}_${s}`}function qS(s){return s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray}function hA(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}function dA(s){if(Object.prototype.hasOwnProperty.call(s,"__esModule"))return s;var t=s.default;if(typeof t=="function"){var e=function n(){var r=!1;try{r=this instanceof n}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(s).forEach(function(n){var r=Object.getOwnPropertyDescriptor(s,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return s[n]}})}),e}var eg,Ew;function pA(){if(Ew)return eg;Ew=1,eg=t;var s=null;try{s=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(_,T,D){this.low=_|0,this.high=T|0,this.unsigned=!!D}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(_){return(_&&_.__isLong__)===!0}t.isLong=e;var n={},r={};function i(_,T){var D,R,P;return T?(_>>>=0,(P=0<=_&&_<256)&&(R=r[_],R)?R:(D=a(_,(_|0)<0?-1:0,!0),P&&(r[_]=D),D)):(_|=0,(P=-128<=_&&_<128)&&(R=n[_],R)?R:(D=a(_,_<0?-1:0,!1),P&&(n[_]=D),D))}t.fromInt=i;function o(_,T){if(isNaN(_))return T?b:y;if(T){if(_<0)return b;if(_>=f)return k}else{if(_<=-m)return I;if(_+1>=m)return C}return _<0?o(-_,T).neg():a(_%p|0,_/p|0,T)}t.fromNumber=o;function a(_,T,D){return new t(_,T,D)}t.fromBits=a;var l=Math.pow;function c(_,T,D){if(_.length===0)throw Error("empty string");if(_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return y;if(typeof T=="number"?(D=T,T=!1):T=!!T,D=D||10,D<2||36<D)throw RangeError("radix");var R;if((R=_.indexOf("-"))>0)throw Error("interior hyphen");if(R===0)return c(_.substring(1),T,D).neg();for(var P=o(l(D,8)),B=y,U=0;U<_.length;U+=8){var H=Math.min(8,_.length-U),G=parseInt(_.substring(U,U+H),D);if(H<8){var X=o(l(D,H));B=B.mul(X).add(o(G))}else B=B.mul(P),B=B.add(o(G))}return B.unsigned=T,B}t.fromString=c;function u(_,T){return typeof _=="number"?o(_,T):typeof _=="string"?c(_,T):a(_.low,_.high,typeof T=="boolean"?T:_.unsigned)}t.fromValue=u;var h=65536,d=1<<24,p=h*h,f=p*p,m=f/2,g=i(d),y=i(0);t.ZERO=y;var b=i(0,!0);t.UZERO=b;var w=i(1);t.ONE=w;var x=i(1,!0);t.UONE=x;var v=i(-1);t.NEG_ONE=v;var C=a(-1,2147483647,!1);t.MAX_VALUE=C;var k=a(-1,-1,!0);t.MAX_UNSIGNED_VALUE=k;var I=a(0,-2147483648,!1);t.MIN_VALUE=I;var N=t.prototype;return N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},N.toString=function(T){if(T=T||10,T<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(I)){var D=o(T),R=this.div(D),P=R.mul(D).sub(this);return R.toString(T)+P.toInt().toString(T)}else return"-"+this.neg().toString(T);for(var B=o(l(T,6),this.unsigned),U=this,H="";;){var G=U.div(B),X=U.sub(G.mul(B)).toInt()>>>0,Z=X.toString(T);if(U=G,U.isZero())return Z+H;for(;Z.length<6;)Z="0"+Z;H=""+Z+H}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,D=31;D>0&&(T&1<<D)==0;D--);return this.high!=0?D+33:D+1},N.isZero=function(){return this.high===0&&this.low===0},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return(this.low&1)===1},N.isEven=function(){return(this.low&1)===0},N.equals=function(T){return e(T)||(T=u(T)),this.unsigned!==T.unsigned&&this.high>>>31===1&&T.high>>>31===1?!1:this.high===T.high&&this.low===T.low},N.eq=N.equals,N.notEquals=function(T){return!this.eq(T)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(T){return this.comp(T)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(T){return this.comp(T)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(T){return this.comp(T)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(T){return this.comp(T)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(T){if(e(T)||(T=u(T)),this.eq(T))return 0;var D=this.isNegative(),R=T.isNegative();return D&&!R?-1:!D&&R?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(w)},N.neg=N.negate,N.add=function(T){e(T)||(T=u(T));var D=this.high>>>16,R=this.high&65535,P=this.low>>>16,B=this.low&65535,U=T.high>>>16,H=T.high&65535,G=T.low>>>16,X=T.low&65535,Z=0,J=0,et=0,Q=0;return Q+=B+X,et+=Q>>>16,Q&=65535,et+=P+G,J+=et>>>16,et&=65535,J+=R+H,Z+=J>>>16,J&=65535,Z+=D+U,Z&=65535,a(et<<16|Q,Z<<16|J,this.unsigned)},N.subtract=function(T){return e(T)||(T=u(T)),this.add(T.neg())},N.sub=N.subtract,N.multiply=function(T){if(this.isZero())return y;if(e(T)||(T=u(T)),s){var D=s.mul(this.low,this.high,T.low,T.high);return a(D,s.get_high(),this.unsigned)}if(T.isZero())return y;if(this.eq(I))return T.isOdd()?I:y;if(T.eq(I))return this.isOdd()?I:y;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(g)&&T.lt(g))return o(this.toNumber()*T.toNumber(),this.unsigned);var R=this.high>>>16,P=this.high&65535,B=this.low>>>16,U=this.low&65535,H=T.high>>>16,G=T.high&65535,X=T.low>>>16,Z=T.low&65535,J=0,et=0,Q=0,st=0;return st+=U*Z,Q+=st>>>16,st&=65535,Q+=B*Z,et+=Q>>>16,Q&=65535,Q+=U*X,et+=Q>>>16,Q&=65535,et+=P*Z,J+=et>>>16,et&=65535,et+=B*X,J+=et>>>16,et&=65535,et+=U*G,J+=et>>>16,et&=65535,J+=R*Z+P*X+B*G+U*H,J&=65535,a(Q<<16|st,J<<16|et,this.unsigned)},N.mul=N.multiply,N.divide=function(T){if(e(T)||(T=u(T)),T.isZero())throw Error("division by zero");if(s){if(!this.unsigned&&this.high===-2147483648&&T.low===-1&&T.high===-1)return this;var D=(this.unsigned?s.div_u:s.div_s)(this.low,this.high,T.low,T.high);return a(D,s.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?b:y;var R,P,B;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return b;if(T.gt(this.shru(1)))return x;B=b}else{if(this.eq(I)){if(T.eq(w)||T.eq(v))return I;if(T.eq(I))return w;var U=this.shr(1);return R=U.div(T).shl(1),R.eq(y)?T.isNegative()?w:v:(P=this.sub(T.mul(R)),B=R.add(P.div(T)),B)}else if(T.eq(I))return this.unsigned?b:y;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();B=y}for(P=this;P.gte(T);){R=Math.max(1,Math.floor(P.toNumber()/T.toNumber()));for(var H=Math.ceil(Math.log(R)/Math.LN2),G=H<=48?1:l(2,H-48),X=o(R),Z=X.mul(T);Z.isNegative()||Z.gt(P);)R-=G,X=o(R,this.unsigned),Z=X.mul(T);X.isZero()&&(X=w),B=B.add(X),P=P.sub(Z)}return B},N.div=N.divide,N.modulo=function(T){if(e(T)||(T=u(T)),s){var D=(this.unsigned?s.rem_u:s.rem_s)(this.low,this.high,T.low,T.high);return a(D,s.get_high(),this.unsigned)}return this.sub(this.div(T).mul(T))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return a(~this.low,~this.high,this.unsigned)},N.and=function(T){return e(T)||(T=u(T)),a(this.low&T.low,this.high&T.high,this.unsigned)},N.or=function(T){return e(T)||(T=u(T)),a(this.low|T.low,this.high|T.high,this.unsigned)},N.xor=function(T){return e(T)||(T=u(T)),a(this.low^T.low,this.high^T.high,this.unsigned)},N.shiftLeft=function(T){return e(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?a(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):a(0,this.low<<T-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(T){return e(T)&&(T=T.toInt()),(T&=63)===0?this:T<32?a(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):a(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(T){if(e(T)&&(T=T.toInt()),T&=63,T===0)return this;var D=this.high;if(T<32){var R=this.low;return a(R>>>T|D<<32-T,D>>>T,this.unsigned)}else return T===32?a(D,0,this.unsigned):a(D>>>T-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},N.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var T=this.high,D=this.low;return[D&255,D>>>8&255,D>>>16&255,D>>>24,T&255,T>>>8&255,T>>>16&255,T>>>24]},N.toBytesBE=function(){var T=this.high,D=this.low;return[T>>>24,T>>>16&255,T>>>8&255,T&255,D>>>24,D>>>16&255,D>>>8&255,D&255]},t.fromBytes=function(T,D,R){return R?t.fromBytesLE(T,D):t.fromBytesBE(T,D)},t.fromBytesLE=function(T,D){return new t(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,D)},t.fromBytesBE=function(T,D){return new t(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],D)},eg}var KS=pA();const YS=hA(KS),fA=t_({__proto__:null,default:YS},[KS]);const Bi=YS||fA;function _u(s){return Bi.fromString(s,!0,16)}const ZS=_u("c3a5c85c97cb3127"),Ri=_u("b492b66fbe98f273"),sn=_u("9ae16a3b2f90404f");function Bg(s){return s.xor(s.shru(47))}function JS(s,t,e){const n=s.slice(t,t+e);return Bi.fromBytes(Array.from(n),!0,!0)}function Yt(s,t){return JS(s,t,8)}function Dw(s,t){return JS(s,t,4)}function Ae(s,t){return t===0?s:s.shru(t).or(s.shl(64-t))}function ei(s,t,e=_u("9ddfea08eb382d69")){let n=s.xor(t).mul(e);n=n.xor(n.shru(47));let r=t.xor(n).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function mA(s,t,e,n,r,i){r=r.add(s),i=Ae(i.add(r).add(n),21);const o=r;return r=r.add(t),r=r.add(e),i=i.add(Ae(r,44)),[r.add(n),i.add(o)]}function Mh(s,t,e,n){return mA(Yt(s,t),Yt(s,t+8),Yt(s,t+16),Yt(s,t+24),e,n)}function gA(s,t=s.length){if(t>=8){const e=sn.add(t*2),n=Yt(s,0).add(sn),r=Yt(s,t-8),i=Ae(r,37).mul(e).add(n),o=Ae(n,25).add(r).mul(e);return ei(i,o,e)}if(t>=4){const e=sn.add(t*2),n=Dw(s,0);return ei(n.shl(3).add(t),Dw(s,t-4),e)}if(t>0){const e=s[0],n=s[t>>1],r=s[t-1],i=e+(n<<8),o=t+(r<<2);return Bg(sn.mul(i).xor(ZS.mul(o))).mul(sn)}return sn}function yA(s,t=s.length){const e=sn.add(t*2),n=Yt(s,0).mul(Ri),r=Yt(s,8),i=Yt(s,t-8).mul(e),o=Yt(s,t-16).mul(sn);return ei(Ae(n.add(r),43).add(Ae(i,30)).add(o),n.add(Ae(r.add(sn),18)).add(i),e)}function bA(s,t=s.length){const e=sn.add(t*2),n=Yt(s,0).mul(sn),r=Yt(s,8),i=Yt(s,t-8).mul(e),o=Yt(s,t-16).mul(sn),a=Ae(n.add(r),43).add(Ae(i,30)).add(o),l=ei(a,n.add(Ae(r.add(sn),18)).add(i),e),c=Yt(s,16).mul(e),u=Yt(s,24),h=a.add(Yt(s,t-32)).mul(e),d=l.add(Yt(s,t-24)).mul(e);return ei(Ae(c.add(u),43).add(Ae(h,30)).add(d),c.add(Ae(u.add(n),18)).add(h),e)}function QS(s,t=s.length){const e=Bi.fromNumber(81,!0);if(t<=32)return t<=16?gA(s,t):yA(s,t);if(t<=64)return bA(s,t);let n=e,r=e.mul(Ri).add(113),i=Bg(r.mul(sn).add(113)).mul(sn),o=[Bi.UZERO,Bi.UZERO],a=[Bi.UZERO,Bi.UZERO];n=n.mul(sn).add(Yt(s,0));let l=0;const c=(t-1>>6)*64,u=c+(t-1&63)-63;do n=Ae(n.add(r).add(o[0]).add(Yt(s,l+8)),37).mul(Ri),r=Ae(r.add(o[1]).add(Yt(s,l+48)),42).mul(Ri),n=n.xor(a[1]),r=r.add(o[0]).add(Yt(s,l+40)),i=Ae(i.add(a[0]),33).mul(Ri),o=Mh(s,l,o[1].mul(Ri),n.add(a[0])),a=Mh(s,l+32,i.add(a[1]),r.add(Yt(s,l+16))),[i,n]=[n,i],l+=64;while(l!==c);const h=Ri.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),n=Ae(n.add(r).add(o[0]).add(Yt(s,l+8)),37).mul(h),r=Ae(r.add(o[1]).add(Yt(s,l+48)),42).mul(h),n=n.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Yt(s,l+40))),i=Ae(i.add(a[0]),33).mul(h),o=Mh(s,l,o[1].mul(h),n.add(a[0])),a=Mh(s,l+32,i.add(a[1]),r.add(Yt(s,l+16))),[i,n]=[n,i],ei(ei(o[0],a[0],h).add(Bg(r).mul(ZS)).add(i),ei(o[1],a[1],h).add(n),h)}function Lr(s,t){return t==="string"?qs(s):wi([s],t)}function xA(s,t){return s instanceof Float32Array&&t==="float32"||s instanceof Int32Array&&t==="int32"||s instanceof Uint8Array&&t==="bool"}function wi(s,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(s)&&(s=tr(s)),j().getBool("DEBUG")&&LS(s,t),xA(s,t))return s;if(t==null||t==="float32"||t==="complex64")return new Float32Array(s);if(t==="int32")return new Int32Array(s);if(t==="bool"){const e=new Uint8Array(s.length);for(let n=0;n<e.length;++n)Math.round(s[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function en(){return j().platform.now()}function wA(s,t){return j().platform.fetch(s,t)}function qs(s,t="utf-8"){return t=t||"utf-8",j().platform.encode(s,t)}function $r(s,t="utf-8"){return t=t||"utf-8",j().platform.decode(s,t)}function Oe(s){return j().platform.isTypedArray!=null?j().platform.isTypedArray(s):qS(s)}function tr(s,t=[],e=!1){if(t==null&&(t=[]),typeof s=="boolean"||typeof s=="number"||typeof s=="string"||li(s)||s==null||Oe(s)&&e)t.push(s);else if(Array.isArray(s)||Oe(s))for(let n=0;n<s.length;++n)tr(s[n],t,e);else{let n=-1;for(const r of Object.keys(s))/^([1-9]+[0-9]*|0)$/.test(r)&&(n=Math.max(n,Number(r)));for(let r=0;r<=n;r++)tr(s[r],t,e)}return t}const vA=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Dt,arraysEqualWithNull:PS,assert:$,assertNonNegativeIntegerDimensions:Vn,assertNonNull:bo,assertShapesMatch:He,bytesFromStringArray:BS,bytesPerElement:sc,checkConversionForErrors:LS,clamp:oi,computeStrides:yt,convertBackendValuesAndArrayBuffer:WS,createScalarValue:Lr,createShuffledIndices:YD,decodeString:$r,distSquared:XD,encodeString:qs,fetch:wA,fingerPrint64:QS,flatten:tr,getArrayFromDType:de,getTypedArrayFromDType:Le,hasEncodingLoss:e0,hexToLong:_u,indexToLoc:wo,inferDtype:xo,inferFromImplicitShape:t0,isBoolean:zS,isFunction:ai,isInt:no,isNumber:Pd,isPromise:li,isScalarShape:qD,isString:Gs,isTypedArray:Oe,isValidDtype:MS,locToIndex:$s,makeOnesTypedArray:Cp,makeZerosNestedTypedArray:n0,makeZerosTypedArray:je,nearestDivisor:Ld,nearestLargerEven:Sp,now:en,parseAxisParam:$t,randUniform:HD,repeatedTry:Lg,rightPad:Yi,shuffle:Qy,shuffleCombo:jD,sizeFromShape:K,sizeToSquarishShape:Fd,squeezeShape:Pr,sum:FS,swap:yr,tanh:KD,toNestedArray:Kn,toTypedArray:wi},Symbol.toStringTag,{value:"Module"}));class SA{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new TA)}profileKernel(t,e,n){let r;const i=()=>{r=n()};let o;const a=en();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:en()-a})}if(j().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const u=r[c];u.data().then(h=>{CA(h,u.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:o}=t;n.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function CA(s,t,e){if(t!=="float32")return!1;for(let n=0;n<s.length;n++){const r=s[n];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class TA{logKernelProfile(t,e,n,r,i,o){const a=typeof r=="number"?Yi(`${r}ms`,9):r.error,l=Yi(t,25),c=e.rank,u=e.size,h=Yi(e.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const m=f.shape||e.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function kA(s,t,e){const n={},r={};for(let l=0;l<t.length;l++)n[t[l].id]=!0;for(let l=0;l<s.length;l++){const c=s[l],u=c.inputs;for(const h in u){const d=u[h];let p=!1;for(let f=0;f<t.length;f++)if(n[d.id]){c.outputs.forEach(m=>n[m.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const i={};i[e.id]=!0;const o={};for(let l=s.length-1;l>=0;l--){const c=s[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const d in u)i[u[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<s.length;l++){const c=s[l];if(r[c.id]&&o[c.id]){const u={};for(const d in c.inputs){const p=c.inputs[d];n[p.id]&&(u[d]=p)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function IA(s,t,e,n){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const c=s[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Dt(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(s[u.id]==null)s[u.id]=c;else{const h=s[u.id];s[u.id]=n(h,c),h.dispose()}}}}const Aw=20,Ol=3,ng=7;function NA(s,t,e,n){const r=yt(t),i=$A(s,t,e,r),o=t.length,a=dd(s,t,e,r,i),l=["Tensor"];return n&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function $A(s,t,e,n){const r=K(t),i=n[n.length-1],o=new Array(i).fill(0),a=t.length,l=e==="complex64"?Bl(s):s;if(a>1)for(let c=0;c<r/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],Ml(l[u+h],0,e).length)}return o}function Ml(s,t,e){let n;return Array.isArray(s)?n=`${parseFloat(s[0].toFixed(ng))} + ${parseFloat(s[1].toFixed(ng))}j`:Gs(s)?n=`'${s}'`:e==="bool"?n=tC(s):n=parseFloat(s.toFixed(ng)).toString(),Yi(n,t)}function tC(s){return s===0?"false":"true"}function dd(s,t,e,n,r,i=!0){const o=e==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(e==="complex64"){const m=Bl(s);return[Ml(m[0],0,e)]}return e==="bool"?[tC(s[0])]:[s[0].toString()]}if(l===1){if(a>Aw){const g=Ol*o;let y=Array.from(s.slice(0,g)),b=Array.from(s.slice((a-Ol)*o,a*o));return e==="complex64"&&(y=Bl(y),b=Bl(b)),["["+y.map((w,x)=>Ml(w,r[x],e)).join(", ")+", ..., "+b.map((w,x)=>Ml(w,r[a-Ol+x],e)).join(", ")+"]"]}return["["+(e==="complex64"?Bl(s):Array.from(s)).map((g,y)=>Ml(g,r[y],e)).join(", ")+"]"]}const c=t.slice(1),u=n.slice(1),h=n[0]*o,d=[];if(a>Aw){for(let m=0;m<Ol;m++){const g=m*h,y=g+h;d.push(...dd(s.slice(g,y),c,e,u,r,!1))}d.push("...");for(let m=a-Ol;m<a;m++){const g=m*h,y=g+h;d.push(...dd(s.slice(g,y),c,e,u,r,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;d.push(...dd(s.slice(g,y),c,e,u,r,m===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Bl(s){const t=[];for(let e=0;e<s.length;e+=2)t.push([s[e],s[e+1]]);return t}class Ce{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=K(t),n!=null){const r=n.length;$(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||de(e,this.size),this.strides=yt(t)}set(t,...e){e.length===0&&(e=[0]),$(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return vs().makeTensor(this.values,this.shape,this.dtype)}}let vs=null,Bo=null;function _A(s){vs=s}function EA(s){Bo=s}class Lt{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=K(t),this.strides=yt(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Bo.buffer(this.shape,this.dtype,t)}bufferSync(){return Bo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Kn(this.shape,t,this.dtype==="complex64")}arraySync(){return Kn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=vs().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(n=>$r(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),vs().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=vs().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>$r(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await vs().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),vs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Bo.print(this,t)}clone(){return this.throwIfDisposed(),Bo.clone(this)}toString(t=!1){const e=this.dataSync();return NA(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Bo.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),vs().makeVariable(this,t,e,n)}}Object.defineProperty(Lt,Symbol.hasInstance,{value:s=>!!s&&s.data!=null&&s.dataSync!=null&&s.throwIfDisposed!=null});function Y(){return r0("Tensor",()=>Lt)}Y();class cc extends Lt{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Dt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);vs().disposeTensor(this),this.dataId=t.dataId,vs().incRef(this,null)}dispose(){vs().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(cc,Symbol.hasInstance,{value:s=>s instanceof Lt&&s.assign!=null&&s.assign instanceof Function});var zg;(function(s){s.R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6"})(zg||(zg={}));var Vg;(function(s){s.float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64"})(Vg||(Vg={}));var Wg;(function(s){s.float32="float32",s.int32="int32",s.bool="bool",s.complex64="complex64"})(Wg||(Wg={}));var Ug;(function(s){s.float32="float32",s.int32="float32",s.bool="float32",s.complex64="complex64"})(Ug||(Ug={}));var Gg;(function(s){s.float32="complex64",s.int32="complex64",s.bool="complex64",s.complex64="complex64"})(Gg||(Gg={}));const DA={float32:Ug,int32:Vg,bool:Wg,complex64:Gg};function bn(s,t){if(s==="string"||t==="string"){if(s==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${s} with ${t}`)}return DA[s][t]}function Df(s){return bn(s,"int32")}function eC(s){return s!=null&&typeof s=="object"&&"texture"in s&&s.texture instanceof WebGLTexture}function nC(s){return typeof GPUBuffer<"u"&&s!=null&&typeof s=="object"&&"buffer"in s&&s.buffer instanceof GPUBuffer}function le(s,t){if(s.dtype===t.dtype)return[s,t];const e=bn(s.dtype,t.dtype);return[s.cast(e),t.cast(e)]}function sC(s,t){$(s.dtype===t.dtype,()=>`The dtypes of the first(${s.dtype}) and second(${t.dtype}) input must match`)}function AA(s,t){return t.some(e=>e.id===s.id)}function o0(s){const t=[];return rC(s,t,new Set),t}function rC(s,t,e){if(s==null)return;if(s instanceof Lt){t.push(s);return}if(!OA(s))return;const n=s;for(const r in n){const i=n[r];e.has(i)||(e.add(i),rC(i,t,e))}}function OA(s){return Array.isArray(s)||typeof s=="object"}const RA=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:sC,getTensorsInContainer:o0,isTensorInList:AA,makeTypesMatch:le},Symbol.toStringTag,{value:"Module"}));function sg(s){return s.kernelName!=null}class Ow{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ta{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ow}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(jn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new SA(this.backendInstance),!0}setupRegisteredKernels(){Vd(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Vd(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(n&&!(n instanceof vp)&&typeof n.then=="function"){const r=++this.pendingBackendInitId,i=n.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,jn(`Initialization of backend ${t} failed`),jn(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return jn(`Initialization of backend ${t} failed`),jn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,i=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,i,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,n){t();try{const r=n();return e(),r}catch(r){throw e(),r}}nextTensorId(){return ta.nextTensorId++}nextVariableId(){return ta.nextVariableId++}clone(t){const e=A.runKernel(Ba,{x:t}),n={x:t},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return A.runKernel(Ia,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,n,[e],r,i,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(lc(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let i=0;n.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=sg(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(sg(t)){const{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;const y=lc(f,this.backendName);$(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,w);const x=w.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(r){const v=this.getTensorsForGradient(f,m,x);n=this.saveTensorsForBackwardMode(v)}return x}}else{const{forwardFunc:f}=t,m=g=>{r&&(n=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=t,d=sg(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(p=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),e=p.outputs)}),r&&this.addTapeNode(c,u,e,d,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:e.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){const r=Mg(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?($(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(c=>e[c])):a=i.map(c=>e[c]);const l=n.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(t,e,n,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=t;n==="string"&&Gs(t[0])&&(i=t.map(l=>qs(l)));const o=r.write(i,e,n),a=new Lt(e,n,o,this.nextTensorId());if(this.trackTensor(a,r),n==="string"){const l=this.state.tensorInfo.get(o),c=BS(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(t,e,n,r){n=n||"float32";const i={dataId:t,shape:e,dtype:n};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:i}=t,o=new Lt(r,i,n,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new cc(t,e,n,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*sc(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof cc||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const n=t.size*sc(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:i},l=Mg(t);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=n[h],p=je(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=o0(t),n=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!n.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,n,r=!1){if($(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));$(i instanceof Lt,()=>"The result y returned by f() must be a tensor.");const o=kA(this.state.activeTape,e,i);if(!r&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=n??FA(i.shape),IA(a,o,c=>this.tidy(c),PA);const l=e.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return $(ai(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{$(e.every(a=>a instanceof Lt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const r={};e.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(n=t(...e,l),$(n.value instanceof Lt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(ai(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),o=(a,l)=>{const c=n.gradFunc(a,l),u=Array.isArray(c)?c:[c];$(u.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(u.every(d=>d instanceof Lt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=en(),n=await this.backend.time(t);return n.wallMs=en()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ow;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ta.nextTensorId=0;ta.nextVariableId=0;function FA(s){const t=Cp(K(s),"float32");return A.makeTensor(t,s,"float32")}function iC(){const s=GS();if(s._tfengine==null){const t=new US(s);s._tfengine=new ta(t)}return tA(s._tfengine.ENV),_A(()=>s._tfengine),s._tfengine}const A=iC();function PA(s,t){const e={a:s,b:t};return A.runKernel(vo,e)}function LA(){return typeof navigator<"u"&&navigator!=null}let jg;function MA(s){jg=s}function a0(s){if(jg!==void 0)return jg;if(s||LA()){if(s||(s=navigator),s.product==="ReactNative")return!0;const t=s.userAgent||s.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=s;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function l0(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const BA=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:l0,isMobile:a0,mockIsMobile:MA},Symbol.toStringTag,{value:"Module"}));const xn=j();xn.registerFlag("DEBUG",()=>!1,s=>{s&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});xn.registerFlag("IS_BROWSER",()=>l0());xn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");xn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));xn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));xn.registerFlag("PROD",()=>!1);xn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>xn.getBool("DEBUG"));xn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);xn.registerFlag("IS_TEST",()=>!1);xn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>xn.getBool("DEBUG"));xn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);xn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);xn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function er(s,t){let e=s;if(Oe(s))return t==="string"?[]:[s.length];if(eC(s)){const r=s.channels||"RGBA";return[s.height,s.width*r.length]}else if(nC(s))return[s.buffer.size/(t==null?4:sc(t))];if(!Array.isArray(s))return[];const n=[];for(;Array.isArray(e)||Oe(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(s)&&j().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&oC(s,n,[]),n}function oC(s,t,e){if(e=e||[],!Array.isArray(s)&&!Oe(s)){$(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}$(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${s.length} elements`),$(s.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${s.length} elements`);const n=t.slice(1);for(let r=0;r<s.length;++r)oC(s[r],n,e.concat(r))}function Rw(s,t,e,n){if(s!=="string_or_numeric"){if(s==null)throw new Error("Expected dtype cannot be null.");if(s!=="numeric"&&s!==t||s==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${s} tensor, but got ${t} tensor`)}}function E(s,t,e,n="numeric"){if(s instanceof Y())return Rw(n,s.dtype,t,e),s;let r=xo(s);if(r!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(r=n),Rw(n,r,t,e),s==null||!Oe(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string"){const l=s==null?"null":s.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}const i=er(s,r);!Oe(s)&&!Array.isArray(s)&&(s=[s]);const a=r!=="string"?wi(s,r):tr(s,[],!0);return A.makeTensor(a,i,r)}function uc(s,t,e,n="numeric"){if(!Array.isArray(s))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return s.map((i,o)=>E(i,`${t}[${o}]`,e,n))}const c0="__op";function O(s){const t=Object.keys(s);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const n=s[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+c0;const r=(...i)=>{A.startScope(e);try{const o=n(...i);return li(o)&&console.error("Cannot return a Promise inside of tidy."),A.endScope(o),o}catch(o){throw A.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function zA(s,t){const e=E(s,"real","complex"),n=E(t,"imag","complex");He(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);const r={real:e,imag:n};return A.runKernel(Ep,r)}const _r=O({complex_:zA});function vi(s,t,e,n){if(n==null)n=xo(s);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(nC(s)||eC(s)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return A.backend.createTensorFromGPUData(s,t||e,n)}if(!Oe(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Vn(t);const r=K(t),i=K(e);$(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o===e.length-1?a!==K(t.slice(o)):!0;$(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Oe(s)&&!Array.isArray(s)&&(s=[s]),t=t||e,s=n!=="string"?wi(s,n):tr(s,[],!0),A.makeTensor(s,t,n)}function Yn(s,t,e){const n=er(s,e);return vi(s,t,n,e)}const so={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Rs{static join(t){return new Rs(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(n=>Oe(n)?n.buffer:n),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let n=0;n<t.length;n++){const r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const n=this.findShardForByte(t);if(n===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=e-t,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let l=n;l<this.shards.length;l++){const c=this.shards[l],h=t+a-c.start,d=a,f=Math.min(e,c.end)-c.start,m=new Uint8Array(c.buffer,h,f-h);if(o.set(m,d),a+=m.length,e<c.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const n=VA(this.shards,e);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function VA(s,t){let e=0,n=s.length;for(;e<=n;){const r=Math.floor((n-e)/2)+e,i=t(s[r]);if(i===0)return r;i<0?n=r:e=r+1}return-1}function WA(){j().set("PROD",!0)}function UA(){j().set("DEBUG",!0)}function GA(){j().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function jA(s){j().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(s+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function HA(){A.disposeVariables()}function Gn(){return A}function Hg(){return A.memory()}function XA(s){return A.profile(s)}function W(s,t){return A.tidy(s,t)}function Nt(s){o0(s).forEach(e=>e.dispose())}function Ie(s){return A.keep(s)}function qA(s){return A.time(s)}function KA(s){return A.setBackend(s)}function aC(){return A.ready()}function u0(){return A.backendName}function YA(s){A.removeBackend(s)}function ZA(s){return A.findBackend(s)}function JA(s){return A.findBackendFactory(s)}function h0(s,t,e=1){return A.registerBackend(s,t,e)}function Af(){return A.backend}function QA(s,t){j().setPlatform(s,t)}const ci=4;async function Xg(s,t){const e=[],n=[],r=Array.isArray(s)?s.map(o=>o.name):Object.keys(s);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(s)?s[o].tensor:s[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((g,y)=>g+y.length,0)+ci*d.length,f=new Uint8Array(p);let m=0;for(let g=0;g<d.length;g++){const y=d[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=ci,f.set(y,m),m+=y.length}h(f)});n.push(u)}else n.push(l.data());t!=null&&(c.group=t),e.push(c)}const i=await Promise.all(n);return{data:nO(i),specs:e}}function lC(s,t){const e=new Rs(s),n={};let r=0;for(const i of t){const o=tO(i,(a,l)=>e.slice(r+a,r+l));n[i.name]=cC(i,e.slice(r,r+o)),r+=o}return n}function tO(s,t){const e=K(s.shape);let n;if("quantization"in s){const r=s.quantization;n=so[r.dtype]}else if(s.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=ci+new Uint32Array(t(r,r+ci))[0];return r}else n=so[s.dtype];return e*n}async function eO(s,t){const e=K(s.shape);let n;if("quantization"in s){const r=s.quantization;n=so[r.dtype]}else if(s.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=ci+new Uint32Array(await t(r,r+ci))[0];return r}else n=so[s.dtype];return e*n}function cC(s,t){const e=s.name,n=s.dtype,r=s.shape,i=K(r);let o,a=0;if("quantization"in s){const l=s.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${s.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(n!=="float32")throw new Error(`Weight ${s.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${n}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=so[l.dtype],u=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(n==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(u.length);for(let h=0;h<u.length;h++){const d=u[h];o[h]=d*l.scale+l.min}}else if(l.dtype==="float16")o=lO()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(n==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(u.length);for(let h=0;h<u.length;h++){const d=u[h];o[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${n}`);a+=i*c}else if(n==="string"){const l=K(s.shape);o=[];for(let c=0;c<l;c++){const u=new Uint32Array(t.slice(a,a+ci))[0];a+=ci;const h=new Uint8Array(t.slice(a,a+u));o.push(h),a+=u}}else{const l=so[n];if(n==="float32")o=new Float32Array(t);else if(n==="int32")o=new Int32Array(t);else if(n==="bool")o=new Uint8Array(t);else if(n==="complex64"){o=new Float32Array(t);const c=new Float32Array(o.length/2),u=new Float32Array(o.length/2);for(let f=0;f<c.length;f++)c[f]=o[f*2],u[f]=o[f*2+1];const h=Yn(c,r,"float32"),d=Yn(u,r,"float32"),p=_r(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${e}': ${n}`);a+=i*l}return Yn(o,r,n)}async function Fw(s,t,e){let n=new Uint8Array(t);for(;n.byteLength<e;){const{done:r,value:i}=await s.read();if(r&&i==null){const a=e-n.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const o=new Uint8Array(n.length+i.byteLength);o.set(n,0),o.set(new Uint8Array(i),n.length),n=o}return n.buffer}async function uC(s,t){const e={},n=s.getReader();let r=new ArrayBuffer(0);for(const i of t){const o=await eO(i,async(c,u)=>(r=await Fw(n,r,u),r.slice(c,u)));r=await Fw(n,r,o);const a=r.slice(0,o);r=r.slice(o);const l=cC(i,a);if(e[i.name]=l,u0()==="webgpu"){const c=Af();"uploadToGPU"in c&&K(l.shape)>=j().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return e}function nO(s){if(s===null)throw new Error(`Invalid input value: ${JSON.stringify(s)}`);let t=0;const e=[];s.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const n=new Uint8Array(t);let r=0;return e.forEach(i=>{n.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),n.buffer}const d0=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Pw(s){return d0?Buffer.byteLength(s,"utf8"):new Blob([s]).size}function sO(s){if(d0)return Buffer.from(s).toString("base64");const t=new Uint8Array(s);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function rO(s){if(d0){const n=Buffer.from(s,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const t=atob(s),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function hC(s){return Rs.join(s)}function Lw(s){for(s=s.trim();s.endsWith("/");)s=s.slice(0,s.length-1);const e=s.split("/");return e[e.length-1]}function dC(s,t){const e={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy,weightsManifest:t};return s.signature!=null&&(e.signature=s.signature),s.userDefinedMetadata!=null&&(e.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(e.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(e.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(e.trainingConfig=s.trainingConfig),e}function pC(s,t,e){const n={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy};if(s.trainingConfig!=null&&(n.trainingConfig=s.trainingConfig),s.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=e}return s.signature!=null&&(n.signature=s.signature),s.userDefinedMetadata!=null&&(n.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(n.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(n.initializerSignature=s.initializerSignature),n}async function p0(s,t){let e,n;return s.weightsManifest!=null&&([e,n]=await t(s.weightsManifest)),pC(s,e,n)}function Eu(s){if(s.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:s.modelTopology==null?0:Pw(JSON.stringify(s.modelTopology)),weightSpecsBytes:s.weightSpecs==null?0:Pw(JSON.stringify(s.weightSpecs)),weightDataBytes:s.weightData==null?0:new Rs(s.weightData).byteLength}}function qg(s){const t=[];for(const e of s)t.push(...e.weights);return t}function iO(){const s=e=>{let n=e<<13,r=0;for(;(n&8388608)===0;)r-=8388608,n<<=1;return n&=-8388609,r+=947912704,n|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=s(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function oO(){const s=new Uint32Array(64);s[0]=0,s[31]=1199570944,s[32]=2147483648,s[63]=3347054592;for(let t=1;t<31;t++)s[t]=t<<23;for(let t=33;t<63;t++)s[t]=2147483648+(t-32<<23);return s}function aO(){const s=new Uint32Array(64);for(let t=0;t<64;t++)s[t]=1024;return s[0]=s[32]=0,s}function lO(){const s=iO(),t=oO(),e=aO();return n=>{const r=new ArrayBuffer(4*n.length),i=new Uint32Array(r);for(let o=0;o<n.length;o++){const a=n[o],l=s[e[a>>10]+(a&1023)]+t[a>>10];i[o]=l}return new Float32Array(r)}}class ie{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ie.instance==null&&(ie.instance=new ie),ie.instance}static registerSaveRouter(t){ie.getInstance().saveRouters.push(t)}static registerLoadRouter(t){ie.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return ie.getHandlers(t,"save")}static getLoadHandlers(t,e){return ie.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return(e==="load"?ie.getInstance().loadRouters:ie.getInstance().saveRouters).forEach(o=>{const a=o(t,n);a!==null&&r.push(a)}),r}}const cO=s=>ie.registerSaveRouter(s),uO=s=>ie.registerLoadRouter(s),fC=s=>ie.getSaveHandlers(s),hO=(s,t)=>ie.getLoadHandlers(s,t);const Kg="tensorflowjs",Yg=1,Xi="models_store",Jr="model_info_store";function mC(){if(!j().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window>"u"?self:window,t=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Zg(s){const t=s.result;t.createObjectStore(Xi,{keyPath:"modelPath"}),t.createObjectStore(Jr,{keyPath:"modelPath"})}class ro{constructor(t){if(this.indexedDB=mC(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,r)=>{const i=this.indexedDB.open(Kg,Yg);i.onupgradeneeded=()=>Zg(i),i.onsuccess=()=>{const o=i.result;if(e==null){const a=o.transaction(Xi,"readonly"),c=a.objectStore(Xi).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(c.result.modelArtifacts)},c.onerror=u=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{e.weightData=Rs.join(e.weightData);const a=Eu(e),l=o.transaction(Jr,"readwrite");let c=l.objectStore(Jr),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let h;u.onsuccess=()=>{h=o.transaction(Xi,"readwrite");const d=h.objectStore(Xi);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a})}catch(f){return r(f)}p.onsuccess=()=>n({modelArtifactsInfo:a}),p.onerror=f=>{c=l.objectStore(Jr);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),r(p.error)),m.onerror=g=>(o.close(),r(p.error))}},u.onerror=d=>(o.close(),r(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}ro.URL_SCHEME="indexeddb://";const gC=s=>j().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(ro.URL_SCHEME)?dO(s.slice(ro.URL_SCHEME.length)):null;ie.registerSaveRouter(gC);ie.registerLoadRouter(gC);function dO(s){return new ro(s)}function pO(s){return s.startsWith(ro.URL_SCHEME)?s.slice(ro.URL_SCHEME.length):s}class fO{constructor(){this.indexedDB=mC()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open(Kg,Yg);n.onupgradeneeded=()=>Zg(n),n.onsuccess=()=>{const r=n.result,i=r.transaction(Jr,"readonly"),a=i.objectStore(Jr).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},a.onerror=l=>(r.close(),e(a.error)),i.oncomplete=()=>r.close()},n.onerror=r=>e(n.error)})}async removeModel(t){return t=pO(t),new Promise((e,n)=>{const r=this.indexedDB.open(Kg,Yg);r.onupgradeneeded=()=>Zg(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Jr,"readwrite"),a=o.objectStore(Jr),l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const u=a.delete(t),h=()=>{c=i.transaction(Xi,"readwrite");const p=c.objectStore(Xi).delete(t);p.onsuccess=()=>e(l.result.modelArtifactsInfo),p.onerror=f=>n(l.error)};u.onsuccess=h,u.onerror=d=>(h(),i.close(),n(l.error))}},l.onerror=u=>(i.close(),n(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>n(r.error)})}}const br="/",zo="tensorflowjs_models",yC="info",mO="model_topology",gO="weight_specs",yO="weight_data",bO="model_metadata";function bC(s){return{info:[zo,s,yC].join(br),topology:[zo,s,mO].join(br),weightSpecs:[zo,s,gO].join(br),weightData:[zo,s,yO].join(br),modelMetadata:[zo,s,bO].join(br)}}function xC(s){for(const t of Object.values(s))window.localStorage.removeItem(t)}function xO(s){const t=s.split(br);if(t.length<3)throw new Error(`Invalid key format: ${s}`);return t.slice(1,t.length-1).join(br)}function wO(s){return s.startsWith(io.URL_SCHEME)?s.slice(io.URL_SCHEME.length):s}class io{constructor(t){if(!j().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=bC(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Eu(t),i=Rs.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,sO(i));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw xC(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(e.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=rO(o),e}}io.URL_SCHEME="localstorage://";const wC=s=>j().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(io.URL_SCHEME)?vO(s.slice(io.URL_SCHEME.length)):null;ie.registerSaveRouter(wC);ie.registerLoadRouter(wC);function vO(s){return new io(s)}class SO{constructor(){$(j().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=zo+br,n=br+yC;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(n)){const o=xO(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=wO(t);const e=bC(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const n=JSON.parse(this.LS.getItem(e.info));return xC(e),n}}const Xo="://";class nn{constructor(){this.managers={}}static getInstance(){return nn.instance==null&&(nn.instance=new nn),nn.instance}static registerManager(t,e){$(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Xo)&&(t=t.slice(0,t.indexOf(Xo))),$(t.length>0,()=>"scheme must not be an empty string.");const n=nn.getInstance();$(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=nn.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(nn.getInstance().managers)}}function pd(s){if(s.indexOf(Xo)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${nn.getSchemes().join(",")}`);return{scheme:s.split(Xo)[0],path:s.split(Xo)[1]}}async function vC(s,t,e=!1){$(s!==t,()=>`Old path and new path are the same: '${s}'`);const n=ie.getLoadHandlers(s);$(n.length>0,()=>`Copying failed because no load handler is found for source URL ${s}.`),$(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${s}.`);const r=n[0],i=ie.getSaveHandlers(t);$(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),$(i.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);const o=i[0],a=pd(s).scheme,l=pd(s).path,c=a===pd(s).scheme,u=await r.load();e&&c&&await nn.getManager(a).removeModel(l);const h=await o.save(u);return e&&!c&&await nn.getManager(a).removeModel(l),h.modelArtifactsInfo}async function CO(){const s=nn.getSchemes(),t={};for(const e of s){const n=await nn.getManager(e).listModels();for(const r in n){const i=e+Xo+r;t[i]=n[r]}}return t}async function TO(s){const t=pd(s);return nn.getManager(t.scheme).removeModel(t.path)}async function kO(s,t){return vC(s,t,!1)}async function IO(s,t){return vC(s,t,!0)}class NO{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!j().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();const r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return qS(t)}}if(j().get("IS_BROWSER")){j().setPlatform("browser",new NO);try{nn.registerManager(io.URL_SCHEME,new SO)}catch{}try{nn.registerManager(ro.URL_SCHEME,new fO)}catch{}}const $O={importFetch:()=>require("node-fetch")};let rg;class _O{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return j().global.fetch!=null?j().global.fetch(t,e):(rg==null&&(rg=$O.importFetch()),rg(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}j().get("IS_NODE")&&!j().get("IS_BROWSER")&&j().setPlatform("node",new _O);function Tt(s,t="float32",e){return t=t||"float32",Vn(s),new Ce(s,t,e)}function EO(s,t){const e=E(s,"x","cast");if(!MS(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:e},r={dtype:t};return A.runKernel(Ia,n,r)}const rt=O({cast_:EO});function DO(s){const e={x:E(s,"x","clone","string_or_numeric")};return A.runKernel(Ba,e)}const Ks=O({clone_:DO});function f0(s,t=!1){console.log(s.toString(t))}iC();const AO={buffer:Tt,cast:rt,clone:Ks,print:f0};EA(AO);function OO(s,t){let e=E(s,"a","add"),n=E(t,"b","add");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(vo,r)}const tt=O({add_:OO});function RO(s,t){let e=E(s,"a","floorDiv"),n=E(t,"b","floorDiv");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(La,r)}const Of=O({floorDiv_:RO});function FO(s,t){let e=E(s,"a","div"),n=E(t,"b","div");if([e,n]=le(e,n),e.dtype==="int32"&&n.dtype==="int32")return Of(e,n);const r={a:e,b:n},i={};return A.runKernel(Da,r,i)}const ft=O({div_:FO});function PO(s,t){let e=E(s,"a","mul"),n=E(t,"b","mul");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(qa,r)}const F=O({mul_:PO});function LO(s){const t=E(s,"x","abs");if(t.dtype==="complex64"){const e={x:t};return A.runKernel(Fc,e)}else{const e={x:t};return A.runKernel(Ic,e)}}const be=O({abs_:LO});function MO(s){const e={x:E(s,"x","acos")};return A.runKernel(xa,e)}const m0=O({acos_:MO});function BO(s){const e={x:E(s,"x","acosh")};return A.runKernel(wa,e)}const g0=O({acosh_:BO});function zO(s){$(Array.isArray(s),()=>"The argument passed to tf.addN() must be a list of tensors"),$(s.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${s.length}`);const t=s.map((r,i)=>E(r,`tensors${i}`,"addN")),e=t[0];t.forEach(r=>{if(r.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Dt(r.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=t;return A.runKernel(Nc,n)}const SC=O({addN_:zO});function VO(s,t=null,e=!1){const r={x:E(s,"x","all","bool")},i={axis:t,keepDims:e};return A.runKernel(Tp,r,i)}const Rf=O({all_:VO});function WO(s,t=null,e=!1){const r={x:E(s,"x","any","bool")},i={axis:t,keepDims:e};return A.runKernel(kp,r,i)}const hc=O({any_:WO});function UO(s,t=0){const n={x:E(s,"x","argMax")},r={axis:t};return A.runKernel($c,n,r)}const ui=O({argMax_:UO});function GO(s,t=0){const n={x:E(s,"x","argMin")},r={axis:t};return A.runKernel(_c,n,r)}const y0=O({argMin_:GO});function jO(s){const e={x:E(s,"x","asin")};return A.runKernel(va,e)}const b0=O({asin_:jO});function HO(s){const e={x:E(s,"x","asinh")};return A.runKernel(Sa,e)}const x0=O({asinh_:HO});function XO(s){const e={x:E(s,"x","atan")};return A.runKernel(Ca,e)}const w0=O({atan_:XO});function qO(s,t){let e=E(s,"a","atan2"),n=E(t,"b","atan2");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(ka,r)}const v0=O({atan2_:qO});function KO(s){const e={x:E(s,"x","atanh")};return A.runKernel(Ta,e)}const S0=O({atanh_:KO});function Du(s,t,e,n,r="NHWC",i){const o=s[3],a=[...t,o],l=Br(r);return Be(s,a,e,i,n,null,null,l)}function ds(s,t,e,n,r,i,o="channelsLast"){const[a,l]=dc(t);let c;if(o==="channelsLast")c=[a,l,s[3],s[3]];else if(o==="channelsFirst")c=[a,l,s[1],s[1]];else throw new Error(`Unknown dataFormat ${o}`);return Be(s,c,e,n,r,i,!1,o)}function Mr(s,t,e,n,r,i,o="NDHWC"){const[a,l,c]=Jg(t);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,s[4],s[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,s[1],s[1]];else throw new Error(`Unknown dataFormat ${o}`);return Si(s,u,e,n,r,!1,h,i)}function Be(s,t,e,n,r,i,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=s;else if(a==="channelsFirst")[l,h,c,u]=s;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=t,[m,g]=dc(e),[y,b]=dc(n),w=qo(d,y),x=qo(p,b),{padInfo:v,outHeight:C,outWidth:k}=JO(r,c,u,m,g,w,x,i,a),I=o?f*h:f;let N;return a==="channelsFirst"?N=[l,I,C,k]:a==="channelsLast"&&(N=[l,C,k,I]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:C,outWidth:k,outChannels:I,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:s,outShape:N,filterShape:t}}function Si(s,t,e,n,r,i=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,d]=s;else if(o==="channelsFirst")[l,d,c,u,h]=s;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,m,,g]=t,[y,b,w]=Jg(e),[x,v,C]=Jg(n),k=qo(p,x),I=qo(f,v),N=qo(m,C),{padInfo:_,outDepth:T,outHeight:D,outWidth:R}=QO(r,c,u,h,y,b,w,k,I,N,a),P=i?g*d:g;let B;return o==="channelsFirst"?B=[l,P,T,D,R]:o==="channelsLast"&&(B=[l,T,D,R,P]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:T,outHeight:D,outWidth:R,outChannels:P,padInfo:_,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:x,dilationHeight:v,dilationWidth:C,inShape:s,outShape:B,filterShape:t}}function YO(s,t,e,n,r){n==null&&(n=C0(s,t,e));const i=s[0],o=s[1],a=pc((i-t+2*n)/e+1,r),l=pc((o-t+2*n)/e+1,r);return[a,l]}function ZO(s,t,e,n,r,i){r==null&&(r=C0(s,t[0],n[0]));const o=[0,0,0,e];for(let a=0;a<3;a++)s[a]+2*r>=t[a]&&(o[a]=pc((s[a]-t[a]+2*r)/n[a]+1,i));return o}function C0(s,t,e,n=1){const r=qo(t,n);return Math.floor((s[0]*(e-1)-e+r)/2)}function dc(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function Jg(s){return typeof s=="number"?[s,s,s]:s}function qo(s,t){return t<=1?s:s+(s-1)*(t-1)}function JO(s,t,e,n,r,i,o,a,l){let c,u,h;if(typeof s=="number"){c={top:s,bottom:s,left:s,right:s,type:s===0?"VALID":"NUMBER"};const p=YO([t,e],i,n,s,a);u=p[0],h=p[1]}else if(s==="same"){u=Math.ceil(t/n),h=Math.ceil(e/r);const d=Math.max(0,(u-1)*n+i-t),p=Math.max(0,(h-1)*r+o-e),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2),y=p-g;c={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(s==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-i+1)/n),h=Math.ceil((e-o+1)/r);else if(typeof s=="object"){const d=l==="channelsLast"?s[1][0]:s[2][0],p=l==="channelsLast"?s[1][1]:s[2][1],f=l==="channelsLast"?s[2][0]:s[3][0],m=l==="channelsLast"?s[2][1]:s[3][1];c={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=pc((t-i+d+p)/n+1,a),h=pc((e-o+f+m)/r+1,a)}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:c,outHeight:u,outWidth:h}}function QO(s,t,e,n,r,i,o,a,l,c,u){let h,d,p,f;if(s==="valid"&&(s=0),typeof s=="number"){h={top:s,bottom:s,left:s,right:s,front:s,back:s,type:s===0?"VALID":"NUMBER"};const g=ZO([t,e,n,1],[a,l,c],1,[r,i,o],s,u);d=g[0],p=g[1],f=g[2]}else if(s==="same"){d=Math.ceil(t/r),p=Math.ceil(e/i),f=Math.ceil(n/o);const m=(d-1)*r+a-t,g=(p-1)*i+l-e,y=(f-1)*o+c-n,b=Math.floor(m/2),w=m-b,x=Math.floor(g/2),v=g-x,C=Math.floor(y/2),k=y-C;h={top:x,bottom:v,left:C,right:k,front:b,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function pc(s,t){if(!t)return Math.trunc(s);switch(t){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error(`Unknown roundingMode ${t}`)}}function hi(s){const[t,e,n]=dc(s);return t===1&&e===1&&n===1}function Xe(s,t){return hi(s)||hi(t)}function oo(s){return dc(s).every(t=>t>0)}function Br(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${s}`)}function cn(s,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${s}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")$(no(t),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(r=>{$(no(r),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${s}: Unknown padding parameter: ${t}`)}}function tR(s,t){const n={x:E(s,"x","reshape","string_or_numeric")},r={shape:t};return A.runKernel(mu,n,r)}const L=O({reshape_:tR});function eR(s,t,e,n,r){const i=E(s,"x","avgPool","float32"),o=1;$(Xe(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),cn("avgPool",n,r);const c={x:a},u={filterSize:t,strides:e,pad:n,dimRoundingMode:r};let h=A.runKernel(Ec,c,u);return h=rt(h,i.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Au=O({avgPool_:eR});function nR(s,t,e,n,r,i="NDHWC"){const o=E(s,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=L(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),$(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),$(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),cn("avgPool3d",n,r);const c={x:a},u={filterSize:t,strides:e,pad:n,dimRoundingMode:r,dataFormat:i};let h=A.runKernel(Dc,c,u);return h=rt(h,a.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const T0=O({avgPool3d_:nR});function sR(s,t=0){$(s.length>=1,()=>"Pass at least one tensor to concat");const e=uc(s,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Ks(e[0]);const n=e,r={axis:t};return A.runKernel(Pc,n,r)}const pe=O({concat_:sR});function rR(s,t,e=!1,n=!1){let r=E(s,"a","matMul"),i=E(t,"b","matMul");[r,i]=le(r,i);const o={a:r,b:i},a={transposeA:e,transposeB:n};return A.runKernel(Ac,o,a)}const Ct=O({matMul_:rR});function iR(s){const e={x:E(s,"x","sigmoid","float32")};return A.runKernel(il,e)}const Zn=O({sigmoid_:iR});function oR(s,t,e){const n=E(s,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const r={x:n},i={begin:t,size:e};return A.runKernel(wu,r,i)}const Ot=O({slice_:oR});function aR(s){const e={x:E(s,"x","tanh","float32")};return A.runKernel(hl,e)}const di=O({tanh_:aR});function lR(s,t,e,n,r,i){const o=E(s,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),l=E(e,"lstmBias","basicLSTMCell"),c=E(n,"data","basicLSTMCell"),u=E(r,"c","basicLSTMCell"),h=E(i,"h","basicLSTMCell"),d=pe([c,h],1),p=Ct(d,a),f=tt(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Ot(f,[0,0],y),w=Ot(f,[0,g],y),x=Ot(f,[0,g*2],y),v=Ot(f,[0,g*3],y),C=tt(F(Zn(b),di(w)),F(u,Zn(tt(o,x)))),k=F(di(C),Zn(v));return[C,k]}const CC=O({basicLSTMCell_:lR});function cR(s,t,e){const n=E(s,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);$(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),$(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),$(n.shape[0]%r===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:n},o={blockShape:t,crops:e};return A.runKernel(Oc,i,o)}const Ou=O({batchToSpaceND_:cR});function uR(s){let t;return s.rank===0||s.rank===1?t=L(s,[1,1,1,s.size]):s.rank===2?t=L(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?t=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]):t=s,t}function hR(s,t,e,n,r,i){i==null&&(i=.001);const o=E(s,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c;r!=null&&(c=E(r,"scale","batchNorm"));let u;n!=null&&(u=E(n,"offset","batchNorm")),$(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:uR(o),scale:c,offset:u,mean:a,variance:l},p={varianceEpsilon:i},f=A.runKernel(jc,d,p);return L(f,o.shape)}const fl=O({batchNorm_:hR});function dR(s,t,e,n,r,i){const o=E(s,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c;r!=null&&(c=E(r,"scale","batchNorm"));let u;return n!=null&&(u=E(n,"offset","batchNorm")),$(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),$(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),$(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),fl(o,a,l,u,c,i)}const k0=O({batchNorm2d_:dR});function pR(s,t,e,n,r,i){const o=E(s,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c;r!=null&&(c=E(r,"scale","batchNorm"));let u;return n!=null&&(u=E(n,"offset","batchNorm")),$(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),$(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),$(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),fl(o,a,l,u,c,i)}const I0=O({batchNorm3d_:pR});function fR(s,t,e,n,r,i){const o=E(s,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c;r!=null&&(c=E(r,"scale","batchNorm"));let u;return n!=null&&(u=E(n,"offset","batchNorm")),$(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),$(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),$(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),fl(o,a,l,u,c,i)}const N0=O({batchNorm4d_:fR});function mR(s,t,e){const n=E(s,"x","bincount"),r=E(t,"weights","bincount");$(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),$(e>=0,()=>`size must be non-negative, but got ${e}.`),$(r.size===n.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${r.shape}.`);const i={x:n,weights:r},o={size:e};return A.runKernel($p,i,o)}const $0=O({bincount_:mR});function gR(s,t){const e=E(s,"x","bitwiseAnd"),n=E(t,"y","bitwiseAnd");if(!Dt(e.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${n.shape}`);if(e.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${n.dtype}`);const r={a:e,b:n};return A.runKernel(Rc,r)}const TC=O({bitwiseAnd_:gR});function yR(s,t){const e=E(s,"s0","broadcastArgs","int32"),n=E(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const r={s0:e,s1:n};return A.runKernel(_p,r)}const kC=O({broadcastArgs_:yR});function bR(s,t){let e=E(s,"broadcastTo","x");const n=e.shape;if(Vn(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=L(e,c)}const r=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])i[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return Ks(e);const a={x:e},l={reps:i};return A.runKernel(dl,a,l)}const Ji=O({broadcastTo_:bR});function xR(s){const e={x:E(s,"x","ceil","float32")};return A.runKernel(Na,e)}const _0=O({ceil_:xR});function So(s,t,e){Vn(s),e=e||xo(t);const n={shape:s,value:t,dtype:e};return A.runKernel(jp,{},n)}function wR(s,t,e){const n=E(s,"x","clipByValue");if($(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return So(n.shape,t,n.dtype);const r={x:n},i={clipValueMin:t,clipValueMax:e};return A.runKernel($a,r,i)}const wn=O({clipByValue_:wR});function vR(s){return pe(s,0)}const E0=O({concat1d_:vR});function SR(s,t){return pe(s,t)}const D0=O({concat2d_:SR});function CR(s,t){return pe(s,t)}const A0=O({concat3d_:CR});function TR(s,t){return pe(s,t)}const O0=O({concat4d_:TR});function kR(s,t,e,n,r="NHWC",i=[1,1],o){const a=E(s,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),$(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),cn("conv2d",n,o);const h=r==="NHWC"?c.shape[3]:c.shape[1];$(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),$(Xe(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),$(oo(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),$(oo(e),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:e,pad:n,dataFormat:r,dilations:i,dimRoundingMode:o},f=A.runKernel(Lc,d,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Er=O({conv2d_:kR});function IR(s,t,e,n,r="NWC",i=1,o){const a=E(s,"x","conv1d"),l=E(t,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=L(a,[1,a.shape[0],a.shape[1]])),$(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),$(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),cn("conv1d",n,o),$(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),$(Xe(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),$(oo(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),$(oo(e),()=>"Error in conv1D: Stride should be larger than 0."),$(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=L(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=L(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=Er(d,h,[1,e],n,"NHWC",[1,i],o);return u?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}const Ff=O({conv1d_:IR});function NR(s,t,e,n,r,i="NHWC",o){$(s.length===t.rank,()=>`Length of inShape (${s.length}) and rank of dy (${t.rank}) must match`);let a=s,l=t,c=!1;t.rank===3&&(c=!0,l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,s[0],s[1],s[2]]),$(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),$(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),$(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const u=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];$(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),$(h===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[3]}.`),cn("conv2dDerInput",r,o);const d={dy:l,filter:e},p={strides:n,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},f=A.runKernel(Mc,d,p);return c?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const R0=O({conv2DBackpropInput_:NR});function $R(s,t,e,n,r,i){const o=E(s,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return R0(e,o,a,n,r,"NHWC",i)}const Pf=O({conv2dTranspose_:$R});function _R(s,t,e,n,r="NDHWC",i=[1,1,1]){const o=E(s,"x","conv3d"),a=E(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=L(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),$(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),$(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),$(Xe(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),$(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),$(oo(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),$(oo(e),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:e,pad:n,dataFormat:r,dilations:i},d=A.runKernel(Bc,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const F0=O({conv3d_:_R});function ER(s,t,e,n,r){$(s.length===t.rank,()=>`Length of inShape (${s.length}) and rank of dy (${t.rank}) must match`);let i=s,o=t,a=!1;t.rank===4&&(a=!0,o=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,s[0],s[1],s[2],s[3]]);const l=i[4],c=o.shape[4];$(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),$(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),$(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),$(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),$(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const u={dy:o,filter:e},h={pad:r,strides:n,inputShape:i},d=A.runKernel(Op,u,h);return a?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const IC=O({conv3DBackpropInput_:ER});function DR(s,t,e,n,r){const i=E(s,"x","conv3dTranspose"),o=E(t,"filter","conv3dTranspose");return IC(e,i,o,n,r)}const P0=O({conv3dTranspose_:DR});function AR(s){const e={x:E(s,"x","cos","float32")};return A.runKernel(_a,e)}const Ru=O({cos_:AR});function OR(s){const e={x:E(s,"x","cosh","float32")};return A.runKernel(Ea,e)}const Lf=O({cosh_:OR});function RR(s,t=0,e=!1,n=!1){const i={x:E(s,"x","cumprod")},o={axis:t,exclusive:e,reverse:n};return A.runKernel(Rp,i,o)}const fc=O({cumprod_:RR});function FR(s,t=0,e=!1,n=!1){const i={x:E(s,"x","cumsum")},o={axis:t,exclusive:e,reverse:n};return A.runKernel(zc,i,o)}const Mf=O({cumsum_:FR});function PR(s,t,e,n=!1){const r=E(s,"x","denseBincount"),i=E(t,"weights","denseBincount");$(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),$(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),$(e>=0,()=>`size must be non-negative, but got ${e}.`),$(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:e,binaryOutput:n};return A.runKernel(Pp,o,a)}const Wd=O({denseBincount_:PR});function LR(s,t,e="NHWC"){const n=E(s,"x","depthToSpace","float32"),r=e==="NHWC"?n.shape[1]:n.shape[2],i=e==="NHWC"?n.shape[2]:n.shape[3],o=e==="NHWC"?n.shape[3]:n.shape[1];$(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),$(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${n.shape}`),$(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${n.shape}`),$(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${n.shape}`);const a={x:n},l={blockSize:t,dataFormat:e};return A.runKernel(Lp,a,l)}const L0=O({depthToSpace_:LR});function MR(s,t,e,n,r="NHWC",i=[1,1],o){const a=E(s,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),$(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?c.shape[3]:c.shape[1];$(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),cn("depthwiseConv2d",n,o);const d={x:c,filter:l},p={strides:e,pad:n,dataFormat:r,dilations:i,dimRoundingMode:o},f=A.runKernel(Vc,d,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const ml=O({depthwiseConv2d_:MR});function BR(s){const e={x:E(s,"x","diag")};return A.runKernel(zp,e)}const NC=O({diag_:BR});function zR(s,t,e,n,r=[1,1],i="NHWC"){const o=E(s,"x","dilation2d"),a=E(t,"filter","dilation2d");$(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),$(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),$(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),$(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:e,pad:n,dilations:r},d=A.runKernel(Wc,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const M0=O({dilation2d_:zR});function ao(s,t){const e=s.length,n=[];for(let r=0;r<e;r++){const i=e-1-r,o=s[i]||1;(t[t.length-1-r]||1)>1&&o===1&&n.unshift(i)}return n}function Te(s,t){const e=[];for(let n=0;n<t.length;n++){const r=s[s.length-n-1],i=t.length-n-1,o=t[i];(r==null||r===1&&o>1)&&e.unshift(i)}return e}function St(s,t){const e=Math.max(s.length,t.length),n=new Array(e);for(let r=0;r<e;r++){let i=s[s.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)n[e-r-1]=o;else if(o===1)n[e-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${s} and ${t}.`;throw Error(a)}else n[e-r-1]=i}return n}const VR=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:St,getBroadcastDims:ao,getReductionAxes:Te},Symbol.toStringTag,{value:"Module"}));function WR(s,t){let e=E(s,"a","equal","string_or_numeric"),n=E(t,"b","equal","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Uc,r)}const Pn=O({equal_:WR});function UR(s,t,e){const n=E(t,"a","where"),r=E(e,"b","where"),i=E(s,"condition","where","bool"),o=St(St(i.shape,n.shape),r.shape),a=Ji(i,o),l=Ji(n,o),c=Ji(r,o),u={condition:a,t:l,e:c};return A.runKernel(xu,u)}const Ge=O({where_:UR});function GR(s){const e={x:E(s,"x","zerosLike")};return A.runKernel($u,e)}const Rt=O({zerosLike_:GR});function jR(s,t){let e=E(s,"a","div"),n=E(t,"b","div");[e,n]=le(e,n);const r=ft(e,n),i=Rt(r),o=Pn(n,i);return Ge(o,i,r)}const B0=O({divNoNan_:jR});function HR(s,t){const e=E(s,"t1","dot"),n=E(t,"t2","dot");$((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);const r=e.rank===1?e.size:e.shape[1],i=n.rank===1?n.size:n.shape[0];if($(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),e.rank===1&&n.rank===1){const o=L(e,[1,-1]),a=L(n,[-1,1]),l=Ct(o,a);return L(l,[])}else if(e.rank===1&&n.rank===2){const o=L(e,[1,-1]),a=L(n,[n.shape[0],n.shape[1]]),l=Ct(o,a);return L(l,[l.size])}else if(e.rank===2&&n.rank===1){const o=L(n,[-1,1]),a=Ct(e,o);return L(a,[a.size])}else{const o=L(n,[n.shape[0],n.shape[1]]);return Ct(e,o)}}const z0=O({dot_:HR});function XR(s,...t){const e=t.map((r,i)=>E(r,`tensors${i}`,"einsum")),n={equation:s};return A.runKernel(Wp,e,n)}const zi=O({einsum_:XR});function qR(s){const e={x:E(s,"x","elu","float32")};return A.runKernel(Aa,e)}const gl=O({elu_:qR});function KR(s,t){const e=E(s,"x","ensureShape","string_or_numeric");if(!PS(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return s}const $C=O({ensureShape_:KR});function YR(s){let t=E(s,"x","erf");$(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=rt(t,"float32"));const e={x:t};return A.runKernel(Oa,e)}const Bf=O({erf_:YR});function V0(s,t){for(let e=0;e<s.length;++e)if(s[s.length-e-1]!==t-1-e)return!1;return!0}function _C(s,t,e){const n=s.length+t.length,r=[];let i=0,o=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?r.push(s[i++]):r.push(t[o++]);return r}function ze(s,t){const e=[],n=s.length;for(let i=0;i<n;i++)t.indexOf(i)===-1&&e.push(s[i]);const r=t.map(i=>s[i]);return[e,r]}function fe(s,t){const e=t.map(n=>1);return _C(s,e,t)}function qe(s,t,e){$(V0(t,e),()=>`${s} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function ce(s,t){if(V0(s,t))return null;const e=[];for(let n=0;n<t;++n)s.indexOf(n)===-1&&e.push(n);return s.forEach(n=>e.push(n)),e}function Ci(s){return s.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function me(s,t){const e=[];for(let n=t-s;n<t;++n)e.push(n);return e}function ZR(s,t=null,e=!1){const r={x:E(s,"x","max")},i={reductionIndices:t,keepDims:e};return A.runKernel(eu,r,i)}const Jn=O({max_:ZR});function JR(s,t=null,e=!1){const r={x:E(s,"x","min")},i={axis:t,keepDims:e};return A.runKernel(iu,r,i)}const ea=O({min_:JR});function QR(s,t){let e=E(s,"base","pow"),n=E(t,"exp","pow");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(Ka,r)}const nr=O({pow_:QR});function gt(s,t){if((Oe(s)&&t!=="string"||Array.isArray(s))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Oe(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return vi(s,[],[],t)}function tF(s){const e={x:E(s,"x","sqrt","float32")};return A.runKernel(al,e)}const Me=O({sqrt_:tF});function eF(s){const t=E(s,"x","square"),e={};return A.runKernel("Square",{x:t},e)}const jt=O({square_:eF});function nF(s,t=null,e=!1){let n=E(s,"x","sum");n.dtype==="bool"&&(n=rt(n,"int32"));const r={x:n},i={axis:t,keepDims:e};return A.runKernel(vu,r,i)}const ht=O({sum_:nF});function sF(s,t="euclidean",e=null,n=!1){s=E(s,"x","norm");const r=EC(s,t,e);let i=r.shape;if(n){const o=$t(e,s.shape);i=fe(r.shape,o)}return L(r,i)}function EC(s,t,e=null){if(s.rank===0)return be(s);if(s.rank!==1&&e===null)return EC(L(s,[-1]),t,e);if(s.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ht(be(s),e);if(t===1/0)return Jn(be(s),e);if(t===-1/0)return ea(be(s),e);if(t==="euclidean"||t===2)return Me(ht(nr(be(s),gt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Jn(ht(be(s),e[0]),e[1]-1);if(t===1/0)return Jn(ht(be(s),e[1]),e[0]);if(t===-1/0)return ea(ht(be(s),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Me(ht(jt(s),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const yl=O({norm_:sF});function rF(s,t=null,e=!1){return yl(s,"euclidean",t,e)}const W0=O({euclideanNorm_:rF});function iF(s){const e={x:E(s,"x","exp")};return A.runKernel(Ra,e)}const vn=O({exp_:iF});function oF(s,t=0){const e=E(s,"x","expandDims","string_or_numeric");$(t<=e.rank,()=>"Axis must be <= rank of the tensor");const n={input:e},r={dim:t};return A.runKernel(Gc,n,r)}const we=O({expandDims_:oF});function aF(s){const e={x:E(s,"x","expm1")};return A.runKernel(Fa,e)}const U0=O({expm1_:aF});function lF(s,t){const e=E(s,"x","tile","string_or_numeric");$(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const n={x:e},r={reps:t};return A.runKernel(dl,n,r)}const Xn=O({tile_:lF});function cF(s,t,e,n="float32"){t==null&&(t=s);const r=Tt([s,t],n),i=s<=t?s:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=L(r.toTensor(),[s,t]);if(e==null)return o;if(e.length===1)return Xn(we(o,0),[e[0],1,1]);if(e.length===2)return Xn(we(we(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Xn(we(we(we(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const zf=O({eye_:cF});function uF(s){const e={x:E(s,"x","floor","float32")};return A.runKernel(Pa,e)}const bl=O({floor_:uF});function hF(s,t,e=0,n=0){const r=E(s,"x","gather"),i=E(t,"indices","gather","int32"),o={x:r,indices:i},a={axis:e,batchDims:n};return A.runKernel(Hc,o,a)}const xl=O({gather_:hF});function dF(s,t){let e=E(s,"a","greater","string_or_numeric"),n=E(t,"b","greater","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Xc,r)}const un=O({greater_:dF});function pF(s,t){let e=E(s,"a","greaterEqual","string_or_numeric"),n=E(t,"b","greaterEqual","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Ma,r)}const zr=O({greaterEqual_:pF});function fF(s){const e={input:E(s,"input","imag")};return A.runKernel(Kp,e)}const Fu=O({imag_:fF});function mF(s){const e={x:E(s,"x","isFinite")};return A.runKernel(za,e)}const G0=O({isFinite_:mF});function gF(s){const e={x:E(s,"x","isInf")};return A.runKernel(Va,e)}const j0=O({isInf_:gF});function yF(s){const e={x:E(s,"x","isNaN")};return A.runKernel(Wa,e)}const H0=O({isNaN_:yF});function bF(s,t=.2){const n={x:E(s,"x","leakyRelu")},r={alpha:t};return A.runKernel(qc,n,r)}const Pu=O({leakyRelu_:bF});function xF(s,t){let e=E(s,"a","less","string_or_numeric"),n=E(t,"b","less","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Kc,r)}const na=O({less_:xF});function wF(s,t){let e=E(s,"a","lessEqual","string_or_numeric"),n=E(t,"b","lessEqual","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Yc,r)}const Ti=O({lessEqual_:wF});function DC(s,t,e){if(e<=0)throw new Error("The number of values should be positive.");const n={start:s,stop:t,num:e};return A.runKernel(Yp,{},n)}function vF(s,t=5,e=1,n=1,r=.5){const i=E(s,"x","localResponseNormalization");$(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),$(no(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=L(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:t,bias:e,alpha:n,beta:r},u=A.runKernel(tu,l,c);return a?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const X0=O({localResponseNormalization_:vF});function SF(s){const e={x:E(s,"x","log","float32")};return A.runKernel(Ua,e)}const Ln=O({log_:SF});function CF(s){const e={x:E(s,"x","log1p")};return A.runKernel(Ga,e)}const Lu=O({log1p_:CF});function TF(s){return $(ai(s),()=>"The f passed in grad(f) must be a function"),(t,e)=>{const n=E(t,"x","tf.grad","string_or_numeric"),r=e!=null?E(e,"dy","tf.grad"):null;return A.tidy(()=>{const{value:i,grads:o}=A.gradients(()=>s(n),[n],r);return r!=null&&He(i.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Vf(o),o[0]})}}function kF(s){return $(ai(s),()=>"The f passed in grads(f) must be a function"),(t,e)=>{$(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const n=uc(t,"args","tf.grads","string_or_numeric"),r=e!=null?E(e,"dy","tf.grads"):null;return A.tidy(()=>{const{value:i,grads:o}=A.gradients(()=>s(...n),n,r);return r!=null&&He(i.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vf(o),o})}}function IF(s){return $(ai(s),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{$(t instanceof Lt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),$(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:n,value:r}=A.gradients(()=>s(t),[t],e);return Vf(n),{grad:n[0],value:r}}}function NF(s){return $(ai(s),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{$(Array.isArray(t)&&t.every(r=>r instanceof Lt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),$(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const n=A.gradients(()=>s(...t),t,e);return e!=null&&He(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vf(n.grads),n}}function AC(s,t){$(ai(s),()=>"The f passed in variableGrads(f) must be a function"),$(t==null||Array.isArray(t)&&t.every(c=>c instanceof cc),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const c in A.registeredVariables)t.push(A.registeredVariables[c])}const n=e?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),$(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=A.gradients(s,t,null,i);$(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),n?.forEach(c=>l[c.name]=null),{value:o,grads:l}}function sr(s){return A.customGrad(s)}function Vf(s){if(s.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function $F(s){const e={x:E(s,"x","neg")};return A.runKernel(au,e)}const Zt=O({neg_:$F});function _F(s){const e={x:E(s,"x","softplus")};return A.runKernel(ol,e)}const Co=O({softplus_:_F});function EF(s){const t=E(s,"x","logSigmoid");return sr(n=>({value:Zt(Co(Zt(n))),gradFunc:o=>F(o,Zn(Zt(n)))}))(t)}const q0=O({logSigmoid_:EF});function DF(s,t){let e=E(s,"a","sub"),n=E(t,"b","sub");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(cl,r)}const ct=O({sub_:DF});function AF(s,t=-1){const e=E(s,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return sr((r,i)=>{const a=Jn(r,t,!0),l=ct(r,a),c=ct(rt(l,"float32"),Ln(ht(vn(l),t,!0)));return i([c]),{value:c,gradFunc:(h,d)=>{const[p]=d,f=!0,m=vn(p);return ct(h,F(ht(h,t,f),m))}}})(e)}const Wf=O({logSoftmax_:AF});function OF(s,t=null,e=!1){const n=E(s,"x","logSumExp"),r=$t(t,n.shape),i=Jn(n,r,!0),o=ct(n,i),a=vn(o),l=ht(a,r),c=Ln(l),u=tt(L(i,c.shape),c);if(e){const h=fe(u.shape,r);return L(u,h)}return u}const Mu=O({logSumExp_:OF});function RF(s,t){const e=E(s,"a","logicalAnd","bool"),n=E(t,"b","logicalAnd","bool");St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Zc,r)}const Es=O({logicalAnd_:RF});function FF(s){const e={x:E(s,"x","logicalNot","bool")};return A.runKernel(Jc,e)}const Bu=O({logicalNot_:FF});function PF(s,t){const e=E(s,"a","logicalOr","bool"),n=E(t,"b","logicalOr","bool");St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Qc,r)}const Uf=O({logicalOr_:PF});function LF(s,t){const e=E(s,"a","logicalXor","bool"),n=E(t,"b","logicalXor","bool");return St(e.shape,n.shape),Es(Uf(s,t),Bu(Es(s,t)))}const K0=O({logicalXor_:LF});const Bh=2147483648;function MF(s,t,e="left"){const n=E(s,"sortedSequence","searchSorted"),r=E(t,"values","searchSorted"),i=n.shape[n.shape.length-1],o=r.shape[r.shape.length-1],a=L(n,[-1,i]),l=L(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(K(l.shape)>=Bh)throw new Error(`values tensor size must less than ${Bh}`);if(a.shape[1]>=Bh)throw new Error(`trailing dim_size must less than ${Bh} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:e};return A.runKernel(mf,c,u)}const Gf=O({searchSorted_:MF});function OC(s,t){return Gf(s,t,"left")}function BF(s,t,e,n,r){const i=E(s,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),$(Xe(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),cn("maxPool",n,r);const c={x:a},u={filterSize:t,strides:e,pad:n,dimRoundingMode:r},h=A.runKernel(nu,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const zu=O({maxPool_:BF});function zF(s,t=[1,1,1],e,n,r,i="NDHWC"){const o=E(s,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=L(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),$(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),cn("maxPool3d",n,r);const c={x:a},u={filterSize:t,strides:e,pad:n,dimRoundingMode:r,dataFormat:i},h=A.runKernel(su,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Y0=O({maxPool3d_:zF});function VF(s,t,e,n,r=!1){const o={x:E(s,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:r},l=A.runKernel(tf,o,a);return{result:l[0],indexes:l[1]}}const RC=O({maxPoolWithArgmax_:VF});function WF(s,t){let e=E(s,"a","maximum"),n=E(t,"b","maximum");[e,n]=le(e,n),e.dtype==="bool"&&(e=rt(e,"int32"),n=rt(n,"int32")),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(ja,r)}const ar=O({maximum_:WF});function UF(s,t=null,e=!1){const r={x:E(s,"x","mean")},i={axis:t,keepDims:e};return A.runKernel(ru,r,i)}const oe=O({mean_:UF});function ve(s,t="float32"){if(Vn(s),t==="complex64"){const n=ve(s,"float32"),r=ve(s,"float32");return _r(n,r)}const e=je(K(s),t);return A.makeTensor(e,s,t)}function mn(s,t="float32"){if(Vn(s),t==="complex64"){const n=mn(s,"float32"),r=ve(s,"float32");return _r(n,r)}const e=Cp(K(s),t);return A.makeTensor(e,s,t)}function FC(s,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(s===void 0)return[];let n=E(s,"x","meshgrid",s instanceof Lt?s.dtype:"float32");if(t===void 0)return[n];let r=E(t,"y","meshgrid",t instanceof Lt?t.dtype:"float32");const i=K(n.shape),o=K(r.shape);return e==="xy"?(n=L(n,[1,-1]),r=L(r,[-1,1]),[Ct(mn([o,1],n.dtype),n),Ct(r,mn([1,i],r.dtype))]):(n=L(n,[-1,1]),r=L(r,[1,-1]),[Ct(n,mn([1,o],n.dtype)),Ct(mn([i,1],r.dtype),r)])}function GF(s,t){let e=E(s,"a","minimum"),n=E(t,"b","minimum");[e,n]=le(e,n),e.dtype==="bool"&&(e=rt(e,"int32"),n=rt(n,"int32")),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(Ha,r)}const pi=O({minimum_:GF});function jF(s,t,e){$(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const n=E(s,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);const r=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)$(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(t[a][0]>=0&&t[a][0]<=n.shape[a]-r&&t[a][1]>=0&&t[a][1]<=n.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-r} or less than 0 for input of shape ${n.shape}`);const i={paddings:t,mode:e},o={x:n};return A.runKernel(ou,o,i)}const Z0=O({mirrorPad_:jF});function HF(s,t){let e=E(s,"a","mod"),n=E(t,"b","mod");[e,n]=le(e,n);const r={a:e,b:n};return A.runKernel(Xa,r)}const J0=O({mod_:HF});function XF(s,t=null,e=!1){s=E(s,"x","moments");const n=$t(t,s.shape),r=oe(s,n,e);let i=r.shape;e||(i=fe(r.shape,n));const o=jt(ct(rt(s,"float32"),L(r,i))),a=oe(o,n,e);return{mean:r,variance:a}}const Vu=O({moments_:XF});function qF(s,t,e,n){const r=E(t,"data","multiRNNCell"),i=uc(e,"c","multiRNNCell"),o=uc(n,"h","multiRNNCell");let a=r;const l=[];for(let h=0;h<s.length;h++){const d=s[h](a,i[h],o[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const PC=O({multiRNNCell_:qF});function KF(s,t,e,n=!1){const r=E(s,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const l={logits:o===1?L(r,[1,-1]):r},c={numSamples:t,seed:e,normalized:n},u=A.runKernel(ef,l,c);return o===1?L(u,[u.size]):u}const LC=O({multinomial_:KF});function YF(s,t){let e=E(s,"a","notEqual","string_or_numeric"),n=E(t,"b","notEqual","string_or_numeric");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n};return A.runKernel(lu,r)}const lo=O({notEqual_:YF});function ZF(s,t,e=1,n=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:E(s,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:e,offValue:n};return A.runKernel(uu,o,a)}const co=O({oneHot_:ZF});function JF(s){const e={x:E(s,"x","onesLike")};return A.runKernel(cu,e)}const Mn=O({onesLike_:JF});function QF(s,t){const e=E(s,"v1","outerProduct"),n=E(t,"v2","outerProduct");$(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);const r=L(e,[-1,1]),i=L(n,[1,-1]);return Ct(r,i)}const MC=O({outerProduct_:QF});function tP(s,t,e=0){const n=E(s,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:n};return A.runKernel(du,i,r)}const Vr=O({pad_:tP});function eP(s,t,e=0){return $(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Vr(s,[t],e)}const BC=O({pad1d_:eP});function nP(s,t,e=0){return $(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vr(s,t,e)}const zC=O({pad2d_:nP});function sP(s,t,e=0){return $(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vr(s,t,e)}const Q0=O({pad3d_:sP});function rP(s,t,e=0){return $(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vr(s,t,e)}const VC=O({pad4d_:rP});function iP(s,t,e){const n=E(s,"x","spaceToBatchND");$(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),$(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),$(n.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]===0:o,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:n},i={blockShape:t,paddings:e};return A.runKernel(Su,r,i)}const Wu=O({spaceToBatchND_:iP});function oP(s,t,e,n,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),n===0&&(n="valid");const a=E(s,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(Xe(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const u=ds(l.shape,t,i,r,n),h=[u.dilationHeight,u.dilationWidth];let d;n==="same"?d=lP([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,m]=aP([u.inHeight,u.inWidth],h,d),g=p?n:"valid",y=p?l:Wu(l,h,f),w=(e==="avg"?()=>Au(y,t,i,g,o):()=>zu(y,t,i,g,o))(),x=p?w:Ou(w,h,m);return c?L(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function aP(s,t,e){const n=e.map(u=>u[0]),r=e.map(u=>u[1]),i=s.concat(n,r),o=t.map((u,h)=>(u-i[h]%u)%u),a=r.map((u,h)=>u+o[h]),l=t.map((u,h)=>[n[h],a[h]]),c=t.map((u,h)=>[0,o[h]]);return[l,c]}function lP(s,t){const n=s.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=n.map(o=>Math.floor(o/2)),i=n.map((o,a)=>o-r[a]);return n.map((o,a)=>[r[a],i[a]])}const tb=O({pool_:oP});function cP(s,t){const e=E(s,"x","prelu"),n=E(t,"alpha","prelu"),r={x:e,alpha:n};return A.runKernel(pu,r)}const Uu=O({prelu_:cP});function uP(s,t=null,e=!1){let n=E(s,"x","prod");n.dtype==="bool"&&(n=rt(n,"int32"));const r={x:n},i={axis:t,keepDims:e};return A.runKernel(fu,r,i)}const eb=O({prod_:uP});function hP(s,t,e,n){const r=s.map((u,h)=>E(u,`tensors${h}`,"raggedGather","int32")),i=E(t,"paramsDenseValues","raggedGather"),o=E(e,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:i,indices:o},l={outputRaggedRank:n},c=A.runKernel(of,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const WC=O({raggedGather_:hP});function dP(s,t,e){const n=E(s,"starts","raggedRange"),r=E(t,"limits","raggedRange",n.dtype),i=E(e,"deltas","raggedRange",n.dtype),o={starts:n,limits:r,deltas:i},a=A.runKernel(af,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const UC=O({raggedRange_:dP});function pP(s,t,e,n,r){const i=E(s,"shape","raggedTensorToTensor","int32"),o=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",o.dtype),l=n.map((h,d)=>E(h,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:r};return A.runKernel(lf,c,u)}const GC=O({raggedTensorToTensor_:pP});function fP(s,t,e){Vn(s);const n=K(s);let r=null;if(e==null||e==="float32")r=new Float32Array(n);else if(e==="int32")r=new Int32Array(n);else if(e==="bool")r=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let i=0;i<n;i++)r[i]=t();return A.makeTensor(r,s,e)}const jC=O({rand_:fP});var fd={exports:{}},mP=fd.exports,Mw;function gP(){return Mw||(Mw=1,(function(s){(function(t,e,n){function r(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new r(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=o:this.alea=o})(mP,s)})(fd)),fd.exports}var md={exports:{}},yP=md.exports,Bw;function bP(){return Bw||(Bw=1,(function(s){(function(t,e,n){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}e&&e.exports?e.exports=o:this.xor128=o})(yP,s)})(md)),md.exports}var gd={exports:{}},xP=gd.exports,zw;function wP(){return zw||(zw=1,(function(s){(function(t,e,n){function r(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}e&&e.exports?e.exports=o:this.xorwow=o})(xP,s)})(gd)),gd.exports}var yd={exports:{}},vP=yd.exports,Vw;function SP(){return Vw||(Vw=1,(function(s){(function(t,e,n){function r(a){var l=this;l.next=function(){var u=l.x,h=l.i,d,p;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,l.i=h+1&7,p};function c(u,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],u.x=p,u.i=0,d=256;d>0;--d)u.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.x&&i(u,c),h.state=function(){return i(c,{})}),h}e&&e.exports?e.exports=o:this.xorshift7=o})(vP,s)})(yd)),yd.exports}var bd={exports:{}},CP=bd.exports,Ww;function TP(){return Ww||(Ww=1,(function(s){(function(t,e,n){function r(a){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,p,f;return l.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(u^u>>>16)|0};function c(u,h){var d,p,f,m,g,y=[],b=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,b=Math.max(b,h.length)),f=0,m=-32;m<b;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;u.w=g,u.X=y,u.i=f}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.X&&i(u,c),h.state=function(){return i(c,{})}),h}e&&e.exports?e.exports=o:this.xor4096=o})(CP,s)})(bd)),bd.exports}var xd={exports:{}},kP=xd.exports,Uw;function IP(){return Uw||(Uw=1,(function(s){(function(t,e,n){function r(a){var l=this,c="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}e&&e.exports?e.exports=o:this.tychei=o})(kP,s)})(xd)),xd.exports}var wd={exports:{}};const NP={},$P=Object.freeze(Object.defineProperty({__proto__:null,default:NP},Symbol.toStringTag,{value:"Module"})),_P=dA($P);var EP=wd.exports,Gw;function DP(){return Gw||(Gw=1,(function(s){(function(t,e,n){var r=256,i=6,o=52,a="random",l=n.pow(r,i),c=n.pow(2,o),u=c*2,h=r-1,d;function p(x,v,C){var k=[];v=v==!0?{entropy:!0}:v||{};var I=y(g(v.entropy?[x,w(e)]:x??b(),3),k),N=new f(k),_=function(){for(var T=N.g(i),D=l,R=0;T<c;)T=(T+R)*r,D*=r,R=N.g(1);for(;T>=u;)T/=2,D/=2,R>>>=1;return(T+R)/D};return _.int32=function(){return N.g(4)|0},_.quick=function(){return N.g(4)/4294967296},_.double=_,y(w(N.S),e),(v.pass||C||function(T,D,R,P){return P&&(P.S&&m(P,N),T.state=function(){return m(N,{})}),R?(n[a]=T,D):T})(_,I,"global"in v?v.global:this==n,v.state)}function f(x){var v,C=x.length,k=this,I=0,N=k.i=k.j=0,_=k.S=[];for(C||(x=[C++]);I<r;)_[I]=I++;for(I=0;I<r;I++)_[I]=_[N=h&N+x[I%C]+(v=_[I])],_[N]=v;(k.g=function(T){for(var D,R=0,P=k.i,B=k.j,U=k.S;T--;)D=U[P=h&P+1],R=R*r+U[h&(U[P]=U[B=h&B+D])+(U[B]=D)];return k.i=P,k.j=B,R})(r)}function m(x,v){return v.i=x.i,v.j=x.j,v.S=x.S.slice(),v}function g(x,v){var C=[],k=typeof x,I;if(v&&k=="object")for(I in x)try{C.push(g(x[I],v-1))}catch{}return C.length?C:k=="string"?x:x+"\0"}function y(x,v){for(var C=x+"",k,I=0;I<C.length;)v[h&I]=h&(k^=v[h&I]*19)+C.charCodeAt(I++);return w(v)}function b(){try{var x;return d&&(x=d.randomBytes)?x=x(r):(x=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(x)),w(x)}catch{var v=t.navigator,C=v&&v.plugins;return[+new Date,t,C,t.screen,w(e)]}}function w(x){return String.fromCharCode.apply(0,x)}if(y(n.random(),e),s.exports){s.exports=p;try{d=_P}catch{}}else n["seed"+a]=p})(typeof self<"u"?self:EP,[],Math)})(wd)),wd.exports}var ig,jw;function AP(){if(jw)return ig;jw=1;var s=gP(),t=bP(),e=wP(),n=SP(),r=TP(),i=IP(),o=DP();return o.alea=s,o.xor128=t,o.xorwow=e,o.xorshift7=n,o.xor4096=r,o.tychei=i,ig=o,ig}var jf=AP();const OP=.001,HC=.1;function RP(s,t,e){return e==null&&(e=nb()),Qg(s,t,(n,r)=>sb(n,r,e))}function nb(){return A.backend.floatPrecision()===32?OP:HC}function Qg(s,t,e){let n=!0;if((Oe(s)||Oe(t))&&(n=!1),Oe(s)&&Oe(t)&&(n=!0),n){const o=s.constructor.name,a=t.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(s)&&Array.isArray(t)){const o=er(s),a=er(t);if(!Dt(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const r=Oe(s)?s:tr(s),i=Oe(t)?t:tr(t);if(r.length!==i.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${i.length}.
Actual:   ${r}.
Expected: ${i}.`);for(let o=0;o<i.length;++o){const a=r[o],l=i[o];if(!e(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${r}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function FP(s,t){s().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function PP(s,t){const e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Gs(s)||Gs(s[0])||Gs(t)||Gs(t[0])?Qg(s,e,(n,r)=>n==r):Qg(s,t,(n,r)=>sb(n,r,0))}function LP(s,t,e){if(e==null&&(e=nb()),!sb(s,t,e))throw new Error(`Numbers differ: actual === ${s}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function sb(s,t,e){return!isFinite(s)&&!isFinite(t)?!0:!(isNaN(s)||isNaN(t)||Math.abs(s-t)>e)}function MP(s,t,e){for(let n=0;n<s.length;n++)if(s[n]<t||s[n]>e)throw new Error(`Value out of range:${s[n]} low: ${t}, high: ${e}`)}function BP(s,t){const e=new Float32Array(s),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let r=0;r<n.length;r++)if(e[r]!==n[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${n[r]} but got ${e[r]} instead`)}function XC(s){for(let t=0;t<s.length;t++){const e=s[t];Array.isArray(e)?XC(e):s[t]=qs(e)}return s}function zP(s){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(s),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function VP(s){await s.play(),"requestVideoFrameCallback"in s&&await new Promise(t=>{s.requestVideoFrameCallback(t)})}const WP=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:HC,createVideoElement:zP,encodeStrings:XC,expectArrayBuffersEqual:BP,expectArraysClose:RP,expectArraysEqual:PP,expectNumbersClose:LP,expectPromiseToFail:FP,expectValuesInRange:MP,play:VP,testEpsilon:nb},Symbol.toStringTag,{value:"Module"}));class rb{constructor(t,e,n,r,i){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=jf.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,n=!1;for(;!n;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class UP{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const i=r||Math.random();this.randu=jf.alea(i.toString()),this.randn=new rb(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,i,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class GP{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=jf.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function jP(s,t,e=1,n="float32",r){if(Vn(s),e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);const i=new UP(t,e,n,r),o=Tt(s,n);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const qC=O({randomGamma_:jP});function HP(s,t=0,e=1,n,r){if(Vn(s),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const i=new rb(t,e,n,!1,r),o=Tt(s,n);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Hf=O({randomNormal_:HP});function XP(s,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Hf(s,0,1,t,e)}const KC=O({randomStandardNormal_:XP});function qP(s,t=0,e=1,n="float32",r){Vn(s);const i=Tt(s,n),o=new GP(t,e,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ki=O({randomUniform_:qP});function KP(s,t,e,n){return ki(s,t,e,"int32",n)}const YC=O({randomUniformInt_:KP});function Dr(s,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:s,stop:t,step:e,dtype:n};return A.runKernel(cf,{},r)}function YP(s){const e={input:E(s,"input","real")};return A.runKernel(uf,e)}const sa=O({real_:YP});function ZP(s){const e={x:E(s,"x","reciprocal")};return A.runKernel(Ya,e)}const ib=O({reciprocal_:ZP});function JP(s){const e={x:E(s,"x","relu")};return A.runKernel(Za,e)}const Fs=O({relu_:JP});function QP(s){const e={x:E(s,"x","relu6")};return A.runKernel(Ja,e)}const Xf=O({relu6_:QP});function tL(s,t){const n={x:E(s,"x","reverse")},r={dims:t};return A.runKernel(bu,n,r)}const Qn=O({reverse_:tL});function eL(s){const t=E(s,"x","reverse");return $(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Qn(t,0)}const ZC=O({reverse1d_:eL});function nL(s,t){const e=E(s,"x","reverse");return $(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Qn(e,t)}const JC=O({reverse2d_:nL});function sL(s,t){const e=E(s,"x","reverse");return $(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Qn(e,t)}const QC=O({reverse3d_:sL});function rL(s,t){const e=E(s,"x","reverse");return $(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Qn(e,t)}const tT=O({reverse4d_:rL});function iL(s){const e={x:E(s,"x","round")};return A.runKernel(Qa,e)}const qf=O({round_:iL});function oL(s){const e={x:E(s,"x","rsqrt","float32")};return A.runKernel(tl,e)}const Kf=O({rsqrt_:oL});function aL(s){const e={x:E(s,"x","selu")};return A.runKernel(el,e)}const Yf=O({selu_:aL});function lL(s,t,e,n,r,i=[1,1],o="NHWC"){const a=E(s,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),c=E(e,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),$(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),$(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),$(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];$(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=ml(u,l,n,r,o,i),g=Er(f,c,1,"valid",o);return h?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Zf=O({separableConv2d_:lL});async function cL(s,t){const e=E(s,"x","setdiff1d"),n=E(t,"y","setdiff1d");$(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),$(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),$(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const r=await e.data(),i=await n.data(),o=new Set(i);let a=0;for(let u=0;u<r.length;u++)o.has(r[u])||a++;const l=new Ce([a],e.dtype),c=new Ce([a],"int32");for(let u=0,h=0;u<r.length;u++)o.has(r[u])||(l.values[h]=r[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const eT=cL;function uL(s){const e={x:E(s,"x","sign")};return A.runKernel(rl,e)}const ob=O({sign_:uL});function hL(s){const e={x:E(s,"x","sin","float32")};return A.runKernel(nl,e)}const Jf=O({sin_:hL});function dL(s){const e={x:E(s,"x","sinh")};return A.runKernel(sl,e)}const Qf=O({sinh_:dL});function pL(s,t,e){const n=E(s,"x","slice1d");return $(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Ot(n,[t],[e])}const Gu=O({slice1d_:pL});function fL(s,t,e){const n=E(s,"x","slice2d");return $(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}const tm=O({slice2d_:fL});function mL(s,t,e){const n=E(s,"x","slice3d");return $(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}const ju=O({slice3d_:mL});function gL(s,t,e){const n=E(s,"x","slice4d");return $(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Ot(n,t,e)}const ra=O({slice4d_:gL});function yL(s,t=-1){const e=E(s,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const n={logits:e},r={dim:t};return A.runKernel(Tu,n,r)}const Hu=O({softmax_:yL});function bL(s){$(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const t={input:s};return A.runKernel(Gp,t)}const Xu=O({fft_:bL});function xL(s){$(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const t={input:s};return A.runKernel(qp,t)}const ia=O({ifft_:xL});function wL(s){const t=s.shape[s.shape.length-1],e=s.size/t;let n;if(t<=2){const r=L(s,[e,t]);n=ia(r)}else{const r=[e,2*(t-1)],i=L(sa(s),[e,t]),o=L(Fu(s),[e,t]),a=Qn(Ot(i,[0,1],[e,t-2]),1),l=F(Qn(Ot(o,[0,1],[e,t-2]),1),gt(-1)),c=pe([i,a],1),u=pe([o,l],1),h=L(_r(c,u),[r[0],r[1]]);n=ia(h)}if(n=sa(n),s.rank===3&&s.shape[0]!==0){const r=n,i=s.shape[0];n=L(n,[i,n.shape[0]/i,n.shape[1]]),r.dispose()}return n}const em=O({irfft_:wL});function vL(s,t,e=0){const r={x:E(s,"x","split")},i={numOrSizeSplits:t,axis:e};return A.runKernel(Cu,r,i)}const gn=O({split_:vL});function SL(s,t){$(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let e=s.shape[s.shape.length-1];const n=s.size/e;let r;if(t!=null&&t<e){const f=s.shape.map(g=>0),m=s.shape.map(g=>g);m[s.shape.length-1]=t,r=Ot(s,f,m),e=t}else if(t!=null&&t>e){const f=s.shape.map(m=>m);f[s.shape.length-1]=t-e,r=pe([s,ve(f)],s.shape.length-1),e=t}else r=s;const i=Rt(r),o=L(_r(r,i),[n,e]),a=Xu(o),l=Math.floor(e/2)+1,c=sa(a),u=Fu(a),h=gn(c,[l,e-l],c.shape.length-1),d=gn(u,[l,e-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,L(_r(h[0],d[0]),p)}const qu=O({rfft_:SL});function CL(s,t){let e=E(s,"a","squaredDifference"),n=E(t,"b","squaredDifference");[e,n]=le(e,n),St(e.shape,n.shape);const r={a:e,b:n},i={};return A.runKernel(ll,r,i)}const nm=O({squaredDifference_:CL});function TL(s,t){const e=E(s,"x","squeeze","string_or_numeric");return L(e,Pr(e.shape,t).newShape)}const En=O({squeeze_:TL});function kL(s,t=0){const e=uc(s,"tensors","stack","string_or_numeric");$(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&$(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const n=e,r={axis:t};return A.runKernel(hu,n,r)}const Sn=O({stack_:kL});function IL(s,t=0){const n={x:E(s,"x","step")},r={alpha:t};return A.runKernel(pl,n,r)}const To=O({step_:IL});function NL(s,t,e,n,r=0,i=0,o=0,a=0,l=0){const u={x:E(s,"x","stridedSlice","string_or_numeric")},h={begin:t,end:e,strides:n,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return A.runKernel(Sf,u,h)}const ab=O({stridedSlice_:NL});function $L(s){const e={x:E(s,"x","tan","float32")};return A.runKernel(ul,e)}const lb=O({tan_:$L});function Je(s,t){bo(s);const e=er(s,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return vi(s,null,e,t)}function Ko(s,t,e){if(bo(s),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=er(s,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return vi(s,t,n,e)}function cb(s,t,e){if(bo(s),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=er(s,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return vi(s,t,n,e)}function nT(s,t,e){if(bo(s),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const n=er(s,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return vi(s,t,n,e)}function sT(s,t,e){if(bo(s),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const n=er(s,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return vi(s,t,n,e)}function rT(s,t,e){if(bo(s),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const n=er(s,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,vi(s,t,n,e)}function ub(s,t,e){const n=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${s}, sliceDim: ${n}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(s.length<n+(e.rank-r))throw new Error(i+` Output shape length < ${n+(e.rank-r)}`);if(e.rank!==r+s.length-n)throw new Error(i+` update.rank != ${r+s.length-n}`);for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==s[o+n])throw new Error(i+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${s[o+r]})`)}function sm(s,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(s.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${s.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(s.size===0)throw new Error(`Updates specified for empty output. updates shape: ${s.shape}`)}ub(e,t,s)}function Ii(s,t,e){const n=t.shape.length,r=n>1?t.shape[n-1]:1,i=e.length;let o=1;for(let h=r;h<i;++h)o*=e[h];const a=r<1?1:r,l=K(t.shape)/a,c=[...yt(e.slice(0,r)),1],u=K(e);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const _L=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Ii,validateInput:sm,validateUpdateShape:ub},Symbol.toStringTag,{value:"Module"}));function EL(s,t,e){const n=E(s,"tensor","tensorScatterupdate"),r=E(t,"indices","tensorScatterupdate","int32"),i=E(e,"updates","tensorScatterupdate");if(sm(i,r,n.shape),n.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${i.dtype}.`);const o={tensor:n,indices:r,updates:i},a={};return A.runKernel(ff,o,a)}const iT=O({tensorScatterUpdate_:EL});function DL(s,t=1,e=!0){const n=E(s,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:n},o={k:t,sorted:e},[a,l]=A.runKernel(If,i,o);return{values:a,indices:l}}const hb=O({topk_:DL});function AL(s,t=0,e=1,n,r){if(Vn(s),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new rb(t,e,n,!0,r),o=Tt(s,n);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const rm=O({truncatedNormal_:AL});function OL(s,t=0){const e=E(s,"x","unique","string_or_numeric");$(e.rank>0,()=>"The input tensor must be at least 1D");const n={x:e},r={axis:t},[i,o]=A.runKernel($f,n,r);return{values:i,indices:o}}const db=O({unique_:OL});function RL(s,t,e){const n=E(s,"x","unsortedSegmentSum"),r=E(t,"segmentIds","unsortedSegmentSum","int32");$(no(e),()=>"numSegments must be of dtype int");const i={x:n,segmentIds:r},o={numSegments:e};return A.runKernel(Nu,i,o)}const im=O({unsortedSegmentSum_:RL});function FL(s,t=0){const e=E(s,"x","unstack","string_or_numeric");$(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const n={value:e},r={axis:t};return A.runKernel(Iu,n,r)}const ts=O({unstack_:FL});function oT(s,t){return Gf(s,t,"right")}function pb(s,t=!0,e,n){return A.makeVariable(s,t,e,n)}function om(s,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const n=Tt(s,"int32"),r=Tt([e.length,s.length],"int32");for(let i=0;i<e.length;i++){const o=n.indexToLoc(e[i]),a=i*s.length;r.values.set(o,a)}return r.toTensor()}async function PL(s){const t=E(s,"condition","whereAsync","bool"),e=await t.data(),n=om(t.shape,e);return s!==t&&t.dispose(),n}const fb=PL;async function LL(s,t,e){const n=E(s,"tensor","boolMask"),r=E(t,"mask","boolMask","bool"),i=e??0,o=r.rank,a=n.shape;$(o>0,()=>"mask cannot be scalar"),He(a.slice(i,i+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=L(n,c),h=L(r,[-1]),d=await fb(h),p=En(d,[1]),f=xl(u,p,i);return s!==n&&n.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}const aT=LL;function ML(s,t,e){const n=E(s,"x","transpose");if(t==null&&(t=n.shape.map((o,a)=>a).reverse()),$(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(o=>{$(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();const r={x:n},i={perm:t};return n.dtype==="complex64"?W(()=>{let o=sa(n),a=Fu(n);return o=A.runKernel(Zi,{x:o},i),a=A.runKernel(Zi,{x:a},i),e&&(a=Zt(a)),_r(o,a)}):A.runKernel(Zi,r,i)}const At=O({transpose_:ML});function BL(s,t,e,n,r=!0){const i=E(s,"v","movingAverage"),o=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");sC(i,o),$(Dt(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=gt(1),c=ct(l,a);let u=F(ct(o,i),c);if(r){$(n!=null,()=>"When using zeroDebias: true, step is required.");const h=E(n,"step","movingAverage");u=ft(u,ct(l,nr(a,h)))}return tt(i,u)}const lT=O({movingAverage_:BL});function zL(s,t,e){Vn(e);const n=E(s,"indices","scatterND","int32"),r=E(t,"updates","scatterND");sm(r,n,e);const i={indices:n,updates:r},o={shape:e};return A.runKernel(pf,i,o)}const cT=O({scatterND_:zL});function VL(s,t,e,n){if(s.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${s.dtype}.`);if(s.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${s.shape}.`);const r=s.rank>0?s.shape[0]:1,i=s.rank>1?s.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function WL(s,t,e,n=0){Vn(e);const r=E(s,"sparseIndices","sparseToDense","int32"),i=E(t,"sparseValues","sparseToDense","string_or_numeric"),o=E(n,"defaultValue","sparseToDense",i.dtype);VL(r,i,e,o);const a={sparseIndices:r,sparseValues:i,defaultValue:o},l={outputShape:e};return A.runKernel(wf,a,l)}const uT=O({sparseToDense_:WL});function UL(s,t){const e=E(t,"indices","gatherND","int32"),r={params:E(s,"x","gatherND","string_or_numeric"),indices:e};return A.runKernel(Xp,r)}const hT=O({gatherND_:UL});function GL(s,t){if(t==null)return s.shape.slice();if(Dt(s.shape,t))return t;if(s.shape.length===t.length){const e=[];for(let n=0;n<s.shape.length;n++)t[n]==null&&s.shape[n]!=null?e.push(s.shape[n]):e.push(t[n]);return e}return t}function jL(s,t,e,n){const r=E(s,"x","dropout");if($(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),$(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return s instanceof Lt?r.clone():r;const i=GL(r,e),o=1-t,a=ft(bl(tt(ki(i,0,1,"float32",n),o)),o);return F(r,a)}const mb=O({dropout_:jL});function gb(s){return Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2))))}function am(s,t,e){const n=1-s%2,r=new Float32Array(s);for(let i=0;i<s;++i){const o=2*Math.PI*i/(s+n-1);r[i]=t-e*Math.cos(o)}return Je(r,"float32")}async function HL(s,t,e=1){const n=E(s,"predictions","inTopK"),r=E(t,"targets","inTopK");$(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),$(n.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${r.rank}`),He(n.shape.slice(0,n.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=n.shape[n.shape.length-1];$(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=await n.data(),a=await r.data(),[l,c]=[o.length/i,i],u=Le("bool",l);for(let h=0;h<l;h++){const d=h*c,p=o.subarray(d,d+c),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<e;m++)if(f[m].index===a[h]){u[h]=1;break}}return s!==n&&n.dispose(),t!==r&&r.dispose(),Yn(u,r.shape,"bool")}const dT=HL;function XL(s,t,e,n,r,i="NHWC",o){let a=s;s.rank===3&&(a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),$(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),$(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],u=i==="NHWC"?l.shape[3]:l.shape[1];$(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),$(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),cn("conv2dDerFilter",r,o);const h={x:a,dy:l},d={strides:n,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e};return A.runKernel(Dp,h,d)}const yb=O({conv2DBackpropFilter_:XL});function lm(s,t,e){if(e==null||e==="linear")return s;if(e==="relu")return F(s,To(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function cm(s,t){let e=t;const n=Te(s.shape,t.shape);return n.length>0&&(e=ht(e,n)),L(e,s.shape)}function um(s,t,e,n){if(t==="linear")return s;if(t==="relu")return Fs(s);if(t==="elu")return gl(s);if(t==="relu6")return Xf(s);if(t==="prelu")return Uu(s,e);if(t==="leakyrelu")return Pu(s,n);if(t==="sigmoid")return Zn(s);throw new Error(`Unknown fused activation ${t}.`)}const hm=(s,t)=>!(s>0)||t==="linear";function qL({x:s,filter:t,strides:e,pad:n,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",hm(A.state.gradientDepth,l)===!1){$(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=Er(s,t,e,n,r,i,o);return a!=null&&(C=tt(C,a)),um(C,l,c,u)}const h=E(s,"x","conv2d","float32"),d=E(t,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),$(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),cn("fused conv2d",n,o);const m=r==="NHWC"?p.shape[3]:p.shape[1];$(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),$(Xe(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const g=Be(p.shape,d.shape,e,i,n,o);let y;a!=null&&(y=E(a,"bias","fused conv2d"),[y]=le(y,h),r==="NHWC"?St(g.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(c!=null){const C=c.shape;if($(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)$(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{St(C,g.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(I)}b=E(c,"prelu weights","fused conv2d")}const w=(C,k)=>{$(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[I,N,_,T]=k,D=lm(C,_,l);$(hi(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const R=R0(N.shape,D,I,e,n),P=yb(N,D,I.shape,e,n),B=[R,P];if(T!=null){const U=cm(T,D);B.push(U)}return B},x={x:p,filter:d,bias:y,preluActivationWeights:b},v={strides:e,pad:n,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?sr((k,I,N)=>{let _=A.runKernel(ic,x,v);return N([I,k,_]),f&&(_=L(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:w}})(p,d):sr((k,I,N,_)=>{let T=A.runKernel(ic,x,v);return _([I,k,T,N]),f&&(T=L(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:w}})(p,d,y)}const pT=O({fusedConv2d_:qL});function KL(s,t,e,n,r,i=[1,1],o){let a=s;s.rank===3&&(a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l=t;l.rank===3&&(l=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:a,dy:l},u={strides:n,pad:r,dimRoundingMode:o,dilations:i,filterShape:e};return A.runKernel(Mp,c,u)}const fT=O({depthwiseConv2dNativeBackpropFilter_:KL});function YL(s,t,e,n,r,i=[1,1],o){let a=t,l=!1;t.rank===3&&(l=!0,a=L(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:a,filter:e},u={strides:n,pad:r,dimRoundingMode:o,dilations:i,inputShape:s},h=A.runKernel(Bp,c,u);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const mT=O({depthwiseConv2dNativeBackpropInput_:YL});function ZL({x:s,filter:t,strides:e,pad:n,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(hm(A.state.gradientDepth,l)===!1){let v=ml(s,t,e,n,r,i,o);return a!=null&&(v=tt(v,a)),um(v,l,c,u)}const h=E(s,"x","depthwiseConv2d","float32"),d=E(t,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),$(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),$(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),i==null&&(i=[1,1]),$(Xe(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),cn("fused depthwiseConv2d",n,o);const m=Be(p.shape,d.shape,e,i,n,o,!0);let g;a!=null&&(g=E(a,"bias","fused conv2d"),[g]=le(g,h),St(m.outShape,g.shape));let y;c!=null&&(y=E(c,"prelu weights","fused depthwiseConv2d"));const b=(v,C)=>{$(hi(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[k,I,N,_]=C,T=lm(v,N,l),D=mT(I.shape,T,k,e,n,i,o),R=fT(I,T,k.shape,e,n,i,o);if(_!=null){const P=cm(g,T);return[D,R,P]}return[D,R]},w={x:p,filter:d,bias:g,preluActivationWeights:y},x={strides:e,pad:n,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?sr((C,k,I)=>{let N=A.runKernel(oc,w,x);return I([k,C,N]),f&&(N=L(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(p,d):sr((C,k,I,N)=>{let _=A.runKernel(oc,w,x);return N([k,C,_,I]),f&&(_=L(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:b}})(p,d,g)}const JL=O({fusedDepthwiseConv2d_:ZL});function QL({a:s,b:t,transposeA:e=!1,transposeB:n=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(hm(A.state.gradientDepth,i)===!1){let T=Ct(s,t,e,n);return r!=null&&(T=tt(T,r)),um(T,i,o,a)}let l=E(s,"a","fused matMul"),c=E(t,"b","fused matMul");[l,c]=le(l,c);const u=e?l.shape[l.rank-2]:l.shape[l.rank-1],h=n?c.shape[c.rank-1]:c.shape[c.rank-2],d=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=K(f),y=K(m);$(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${n} must match.`);const w=St(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=e?L(l,[g,u,d]):L(l,[g,d,u]),v=n?L(c,[y,p,h]):L(c,[y,h,p]);let C;r!=null&&(C=E(r,"bias","fused matMul"),[C]=le(C,l),St(w,C.shape));let k;o!=null&&(k=E(o,"prelu weights","fused matMul"));const I=(T,D)=>{const[R,P,B,U]=D,H=lm(L(T,B.shape),B,i);let G,X;if(!e&&!n?(G=Ct(H,P,!1,!0),X=Ct(R,H,!0,!1)):!e&&n?(G=Ct(H,P,!1,!1),X=Ct(H,R,!0,!1)):e&&!n?(G=Ct(P,H,!1,!0),X=Ct(R,H,!1,!1)):(G=Ct(P,H,!0,!0),X=Ct(H,R,!0,!0)),r!=null){const Z=cm(U,H);return[G,X,Z]}else return[G,X]},N={a:x,b:v,bias:C,preluActivationWeights:k},_={transposeA:e,transposeB:n,activation:i,leakyreluAlpha:a};return r==null?sr((D,R,P)=>{const B=A.runKernel(rc,N,_);return P([D,R,B]),{value:L(B,w),gradFunc:I}})(x,v):sr((D,R,P,B)=>{const U=A.runKernel(rc,N,_);return B([D,R,U,P]),{value:L(U,w),gradFunc:I}})(x,v,C)}const ty=O({fusedMatMul_:QL});const gT=Object.freeze(Object.defineProperty({__proto__:null,conv2d:pT,depthwiseConv2d:JL,matMul:ty},Symbol.toStringTag,{value:"Module"}));function tM(s){return am(s,.54,.46)}const eM=O({hammingWindow_:tM});function nM(s){return am(s,.5,.5)}const yT=O({hannWindow_:nM});function sM(s,t,e,n=!1,r=0){let i=0;const o=[];for(;i+t<=s.size;)o.push(Ot(s,i,t)),i+=e;if(n)for(;i<s.size;){const a=i+t-s.size,l=pe([Ot(s,i,t-a),So([a],r)]);o.push(l),i+=e}return o.length===0?Ko([],[0,t]):L(pe(o),[o.length,t])}const bT=O({frame_:sM});function rM(s,t,e,n,r=yT){n==null&&(n=gb(t));const i=bT(s,t,e),o=F(i,r(t));return qu(o,n)}const iM=O({stft_:rM});function oM(s,t,e,n,r="bilinear",i=0){const o=E(s,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),c=a.shape[0];$(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),$(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),$(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),$(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),$(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),$(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const u={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:i,cropSize:n};return A.runKernel(Fp,u,h)}const aM=O({cropAndResize_:oM});function lM(s){const t=E(s,"image","flipLeftRight","float32");$(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return A.runKernel(Hp,e,{})}const cM=O({flipLeftRight_:lM});function uM(s){const t=E(s,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];$(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),$(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Xn(t,r)}const hM=O({grayscaleToRGB_:uM});function dM(s){const t=E(s,"image","RGBToGrayscale"),e=t.rank-1,n=t.shape[e];$(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),$(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);const r=t.dtype,i=rt(t,"float32"),o=Je([.2989,.587,.114]);let a;switch(t.rank){case 2:a=zi("ij,j->i",i,o);break;case 3:a=zi("ijk,k->ij",i,o);break;case 4:a=zi("ijkl,l->ijk",i,o);break;case 5:a=zi("ijklm,m->ijkl",i,o);break;case 6:a=zi("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=we(a,-1),rt(a,r)}const pM=O({rgbToGrayscale_:dM});function fM(s,t,e=0,n=.5){const r=E(s,"image","rotateWithOffset","float32");$(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:e,center:n};return A.runKernel(_f,i,o)}const mM=O({rotateWithOffset_:fM});function wl(s,t,e,n,r,i){n==null&&(n=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=s.shape[0];return e=Math.min(e,o),$(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),$(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),$(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),$(t.rank===1,()=>"scores must be a 1D tensor"),$(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),$(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:r,softNmsSigma:i}}function gM(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY){const i=E(s,"boxes","nonMaxSuppression","float32"),o=E(t,"scores","nonMaxSuppression","float32"),a=wl(i,o,e,n,r);e=a.maxOutputSize,n=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:e,iouThreshold:n,scoreThreshold:r};return A.runKernel(nf,{boxes:i,scores:o},l)}const yM=O({nonMaxSuppression_:gM});function bM(s,t,e){const n=xM(s,t,e),r=n<0?-(n+1):n;s.splice(r,0,t)}function xM(s,t,e){return vM(s,t,e||wM)}function wM(s,t){return s>t?1:s<t?-1:0}function vM(s,t,e){let n=0,r=s.length,i=0,o=!1;for(;n<r;){i=n+(r-n>>>1);const a=e(t,s[i]);a>0?n=i+1:(r=i,o=!a)}return o?n:-n-1}function dm(s,t,e,n,r){return bb(s,t,e,n,r,0)}function pm(s,t,e,n,r,i){return bb(s,t,e,n,r,0,!1,i,!0)}function fm(s,t,e,n,r,i){return bb(s,t,e,n,r,i,!0)}function bb(s,t,e,n,r,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>r&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(Hw);const u=i>0?-.5/i:0,h=[],d=[];for(;h.length<e&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:w}=g;if(y<r)break;let x=!1;for(let v=h.length-1;v>=w;--v){const C=SM(s,b,h[v]);if(C>=n){x=!0;break}if(g.score=g.score*CM(n,u,C),g.score<=r)break}g.suppressBeginIndex=h.length,x||(g.score===y?(h.push(b),d.push(g.score)):g.score>r&&bM(c,g,Hw))}const p=h.length,f=e-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function SM(s,t,e){const n=s.subarray(t*4,t*4+4),r=s.subarray(e*4,e*4+4),i=Math.min(n[0],n[2]),o=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,d),w=Math.max(y-m,0)*Math.max(b-g,0);return w/(p+f-w)}function CM(s,t,e){const n=Math.exp(t*e*e);return e<=s?n:0}function Hw(s,t){return s.score-t.score||s.score===t.score&&t.boxIndex-s.boxIndex}async function TM(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY){const i=E(s,"boxes","nonMaxSuppressionAsync"),o=E(t,"scores","nonMaxSuppressionAsync"),a=wl(i,o,e,n,r);e=a.maxOutputSize,n=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=dm(c,u,e,n,r);return i!==s&&i.dispose(),o!==t&&o.dispose(),Je(h,"int32")}const kM=TM;function IM(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=E(s,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=wl(o,a,e,n,r,i);e=l.maxOutputSize,n=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:e,iouThreshold:n,scoreThreshold:r,softNmsSigma:i},h=A.runKernel(rf,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const NM=O({nonMaxSuppressionWithScore_:IM});async function $M(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=E(s,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=wl(o,a,e,n,r,i);e=l.maxOutputSize,n=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=fm(u,h,e,n,r,i);return o!==s&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Je(d,"int32"),selectedScores:Je(p)}}const _M=$M;function EM(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=E(s,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=wl(o,a,e,n,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},f=A.runKernel(sf,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const DM=O({nonMaxSuppressionPadded_:EM});async function AM(s,t,e,n=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=E(s,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=wl(o,a,e,n,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:m}=pm(d,p,c,u,h,i);return o!==s&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Je(f,"int32"),validOutputs:gt(m,"int32")}}const OM=AM;function RM(s,t,e=!1,n=!1){const r=E(s,"images","resizeBilinear");$(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),$(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),$(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:n,size:t},c=A.runKernel(yu,a,l);return o?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const xT=O({resizeBilinear_:RM});function FM(s,t,e=!1,n=!1){const r=E(s,"images","resizeNearestNeighbor");$(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),$(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),$(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:e,halfPixelCenters:n,size:t},c=A.runKernel(gu,a,l);return o?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const wT=O({resizeNearestNeighbor_:FM});function PM(s,t="binary",e=!1,n=.5){const r=E(s,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=F(Je([n]),255),u,h,d,p;if($(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),$(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),$(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),$(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[u,h,d]=gn(r,[1,1,1],-1);const g=F(u,i),y=F(h,o),b=F(d,a);p=tt(tt(g,y),b)}else p=s;if(t==="otsu"){const g=$0(rt(qf(p),"int32"),Yn([]),256);c=LM(g,l)}const f=e?Ti(p,c):un(p,c);return rt(F(f,255),"int32")}function LM(s,t){let e=Je([-1]),n=Je([0]),r=Je([0]),i,o,a,l,c,u;for(let h=0;h<s.size-1;h++){i=Ot(s,0,h+1),o=Ot(s,h+1),c=ft(ht(i),t),u=ft(ht(o),t);const d=ht(F(i,Dr(0,i.size)));a=ft(d,ht(i));const p=So(o.shape,i.size),f=tt(Dr(0,o.size),p),m=F(o,f);l=ft(ht(m),ht(o));const g=ct(a,l),y=ct(a,l),b=F(c,u);r=F(F(b,g),y);const w=un(r,n);n=Ge(w,r,n),e=Ge(w,Je([h]),e)}return e}const MM=O({threshold_:PM});function BM(s,t,e="nearest",n="constant",r=0,i){const o=E(s,"image","transform","float32"),a=E(t,"transforms","transform","float32");$(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),$(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:e,fillMode:n,fillValue:r,outputShape:i};return A.runKernel(Nf,l,c)}const zM=O({transform_:BM});function VM(s,t,e){const n=E(s,"a","bandPart");$(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const r=n.shape,[i,o]=n.shape.slice(-2);let a,l;typeof t=="number"?($(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),$(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),a=E(t<0?i:t,"numLower","bandPart")):($(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Ge(na(t,0),i,pi(t,i))),typeof e=="number"?($(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),$(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),l=E(e<0?o:e,"numUpper","bandPart")):($(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Ge(na(e,0),o,pi(e,o)));const c=L(Dr(0,i,1,"int32"),[-1,1]),u=Dr(0,o,1,"int32"),h=ct(c,u),d=Es(Ti(h,a),zr(h,Zt(l))),p=ve([i,o],n.dtype);return L(Sn(ts(L(n,[-1,i,o])).map(f=>Ge(d,f,p))),r)}const WM=O({bandPart_:VM});function UM(s){let t;if(Array.isArray(s)){t=!1,$(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=s[0].shape[0];for(let i=1;i<s.length;++i)$(s[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[i].shape[0]} vs. ${r})`)}else t=!0,s=gn(s,s.shape[0],0).map(r=>En(r,[0]));$(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const e=[],n=s;for(let r=0;r<s.length;++r)e.push(A.tidy(()=>{let i=n[r];if(r>0)for(let o=0;o<r;++o){const a=F(ht(F(e[o],i)),e[o]);i=ct(i,a)}return ft(i,yl(i,"euclidean"))}));return t?Sn(e,0):e}const GM=O({gramSchmidt_:UM});function jM(s,t=!1){if($(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return Xw(s,t);{const e=s.shape.slice(0,s.shape.length-2).reduce((l,c)=>l*c),n=ts(L(s,[e,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),r=[],i=[];n.forEach(l=>{const[c,u]=Xw(l,t);r.push(c),i.push(u)});const o=L(Sn(r,0),s.shape),a=L(Sn(i,0),s.shape);return[o,a]}}function Xw(s,t=!1){return A.tidy(()=>{$(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const e=s.shape[0],n=s.shape[1];let r=zf(e),i=Ks(s);const o=Ko([[1]],[1,1]);let a=Ks(o);const l=e>=n?n:e;for(let c=0;c<l;++c){const u=i,h=a,d=r;[a,i,r]=A.tidy(()=>{const p=Ot(i,[c,c],[e-c,1]),f=yl(p),m=Ot(i,[c,c],[1,1]),g=Ge(un(m,0),Ko([[-1]]),Ko([[1]])),y=ct(m,F(g,f)),b=ft(p,y);b.shape[0]===1?a=Ks(o):a=pe([o,Ot(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const w=Zt(ft(Ct(g,y),f)),x=Ot(i,[c,0],[e-c,n]),v=F(w,a),C=At(a);if(c===0)i=ct(x,Ct(v,Ct(C,x)));else{const N=ct(x,Ct(v,Ct(C,x)));i=pe([Ot(i,[0,0],[c,n]),N],0)}const k=At(v),I=Ot(r,[0,c],[e,r.shape[1]-c]);if(c===0)r=ct(I,Ct(Ct(I,a),k));else{const N=ct(I,Ct(Ct(I,a),k));r=pe([Ot(r,[0,0],[e,c]),N],1)}return[a,i,r]}),Nt([u,h,d])}return!t&&e>n&&(r=Ot(r,[0,0],[e,n]),i=Ot(i,[0,0],[n,n])),[r,i]})}const HM=O({qr_:jM});var rn;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(rn||(rn={}));function XM(s,t,e=rn.SUM_BY_NONZERO_WEIGHTS){const n=E(s,"losses","computeWeightedLoss");let r=null;t!=null&&(r=E(t,"weights","computeWeightedLoss"));const i=r==null?n:F(n,r);if(e===rn.NONE)return i;if(e===rn.SUM)return ht(i);if(e===rn.MEAN){if(r==null)return oe(i);{const o=n.size/r.size,a=ft(ht(i),ht(r));return o>1?ft(a,gt(o)):a}}if(e===rn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ft(ht(i),gt(n.size));{const o=F(r,mn(n.shape)),a=rt(ht(lo(o,gt(0))),"float32");return ft(ht(i),a)}}throw Error(`Unknown reduction: ${e}`)}const Wr=O({computeWeightedLoss_:XM});function qM(s,t,e,n=rn.SUM_BY_NONZERO_WEIGHTS){const r=E(s,"labels","absoluteDifference"),i=E(t,"predictions","absoluteDifference");let o=null;e!=null&&(o=E(e,"weights","absoluteDifference")),He(r.shape,i.shape,"Error in absoluteDifference: ");const a=be(ct(r,i));return Wr(a,o,n)}const KM=O({absoluteDifference_:qM});function YM(s,t,e,n,r=rn.SUM_BY_NONZERO_WEIGHTS){const i=E(s,"labels","cosineDistance"),o=E(t,"predictions","cosineDistance");let a=null;n!=null&&(a=E(n,"weights","cosineDistance")),He(i.shape,o.shape,"Error in cosineDistance: ");const l=gt(1),c=ct(l,ht(F(i,o),e,!0));return Wr(c,a,r)}const ZM=O({cosineDistance_:YM});function JM(s,t,e,n=rn.SUM_BY_NONZERO_WEIGHTS){let r=E(s,"labels","hingeLoss");const i=E(t,"predictions","hingeLoss");let o=null;e!=null&&(o=E(e,"weights","hingeLoss")),He(r.shape,i.shape,"Error in hingeLoss: ");const a=gt(1);r=ct(F(gt(2),r),a);const l=Fs(ct(a,F(r,i)));return Wr(l,o,n)}const QM=O({hingeLoss_:JM});function t3(s,t,e,n=1,r=rn.SUM_BY_NONZERO_WEIGHTS){const i=E(s,"labels","huberLoss"),o=E(t,"predictions","huberLoss");let a=null;e!=null&&(a=E(e,"weights","huberLoss")),He(i.shape,o.shape,"Error in huberLoss: ");const l=gt(n),c=be(ct(o,i)),u=pi(c,l),h=ct(c,u),d=tt(F(gt(.5),jt(u)),F(l,h));return Wr(d,a,r)}const e3=O({huberLoss_:t3});function n3(s,t,e,n=1e-7,r=rn.SUM_BY_NONZERO_WEIGHTS){const i=E(s,"labels","logLoss"),o=E(t,"predictions","logLoss");let a=null;e!=null&&(a=E(e,"weights","logLoss")),He(i.shape,o.shape,"Error in logLoss: ");const l=gt(1),c=gt(n),u=Zt(F(i,Ln(tt(o,c)))),h=F(ct(l,i),Ln(tt(ct(l,o),c))),d=ct(u,h);return Wr(d,a,r)}const s3=O({logLoss_:n3});function r3(s,t,e,n=rn.SUM_BY_NONZERO_WEIGHTS){const r=E(s,"labels","meanSquaredError"),i=E(t,"predictions","meanSquaredError");let o=null;e!=null&&(o=E(e,"weights","meanSquaredError")),He(r.shape,i.shape,"Error in meanSquaredError: ");const a=nm(r,i);return Wr(a,o,n)}const i3=O({meanSquaredError_:r3});function o3(s,t){const e=E(s,"labels","sigmoidCrossEntropyWithLogits"),n=E(t,"logits","sigmoidCrossEntropyWithLogits");He(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Fs(n),i=F(n,e),o=Lu(vn(Zt(be(n))));return tt(ct(r,i),o)}function a3(s,t,e,n=0,r=rn.SUM_BY_NONZERO_WEIGHTS){let i=E(s,"multiClassLabels","sigmoidCrossEntropy");const o=E(t,"logits","sigmoidCrossEntropy");let a=null;if(e!=null&&(a=E(e,"weights","sigmoidCrossEntropy")),He(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),n>0){const c=gt(n),u=gt(1),h=gt(.5);i=tt(F(i,ct(u,c)),F(h,c))}const l=o3(i,o);return Wr(l,a,r)}const l3=O({sigmoidCrossEntropy_:a3});function c3(s,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return sr((r,i,o)=>{const l=Mu(i,[e],!0),c=ct(rt(i,"float32"),l);o([r,c]);const u=Zt(F(c,r));return{value:ht(u,[e]),gradFunc:(p,f)=>{const[m,g]=f,y=fe(p.shape,[e]);return[F(L(p,y),ct(rt(m,"float32"),vn(g))),F(L(p,y),ct(vn(g),rt(m,"float32")))]}}})(s,t)}function u3(s,t,e,n=0,r=rn.SUM_BY_NONZERO_WEIGHTS){let i=E(s,"onehotLabels","softmaxCrossEntropy");const o=E(t,"logits","softmaxCrossEntropy");let a=null;if(e!=null&&(a=E(e,"weights","softmaxCrossEntropy")),He(i.shape,o.shape,"Error in softmaxCrossEntropy: "),n>0){const c=gt(n),u=gt(1),h=gt(i.shape[1]);i=tt(F(i,ct(u,c)),ft(c,h))}const l=c3(i,o);return Wr(l,a,r)}const h3=O({softmaxCrossEntropy_:u3});function d3(s,t,e,n){const r=E(s,"indices","sparseFillEmptyRows","int32"),i=E(t,"values","sparseFillEmptyRows"),o=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(n,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:i,denseShape:o,defaultValue:a},c=A.runKernel(gf,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const p3=O({sparseFillEmptyRows_:d3});function f3(s,t,e){const n=E(s,"inputIndices","sparseReshape","int32"),r=E(t,"inputShape","sparseReshape","int32"),i=E(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:n,inputShape:r,newShape:i},a=A.runKernel(yf,o);return{outputIndices:a[0],outputShape:a[1]}}const m3=O({sparseReshape_:f3});function g3(s,t,e){const n=E(s,"data","sparseSegmentMean"),r=E(t,"indices","sparseSegmentMean","int32"),i=E(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:n,indices:r,segmentIds:i};return A.runKernel(bf,o)}const y3=O({sparseSegmentMean_:g3});function b3(s,t,e){const n=E(s,"data","sparseSegmentSum"),r=E(t,"indices","sparseSegmentSum","int32"),i=E(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:n,indices:r,segmentIds:i};return A.runKernel(xf,o)}const x3=O({sparseSegmentSum_:b3});function w3(s,t,e,n,r,i,o,a){const l=E(s,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=E(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:e,nGramWidths:n,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},d=A.runKernel(Cf,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const v3=O({stringNGrams_:w3});function S3(s,t,e=!0){const n=E(s,"input","stringSplit","string"),r=E(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:e},o={input:n,delimiter:r},a=A.runKernel(Tf,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const C3=O({stringSplit_:S3});function T3(s,t){const e=E(s,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:e};return A.runKernel(kf,r,n)}const k3=O({stringToHashBucketFast_:T3});function I3(s,t,e,n=!0){const r=E(s,"input","staticRegexReplace","string"),i={pattern:t,rewrite:e,replaceGlobal:n};return A.runKernel(ku,{x:r},i)}const N3=O({staticRegexReplace_:I3});const vT={fft:Xu,ifft:ia,rfft:qu,irfft:em},ST={hammingWindow:eM,hannWindow:yT,frame:bT,stft:iM},Dn={flipLeftRight:cM,grayscaleToRGB:hM,resizeNearestNeighbor:wT,resizeBilinear:xT,rgbToGrayscale:pM,rotateWithOffset:mM,cropAndResize:aM,nonMaxSuppression:yM,nonMaxSuppressionAsync:kM,nonMaxSuppressionWithScore:NM,nonMaxSuppressionWithScoreAsync:_M,nonMaxSuppressionPadded:DM,nonMaxSuppressionPaddedAsync:OM,threshold:MM,transform:zM},xb={bandPart:WM,gramSchmidt:GM,qr:HM},CT={absoluteDifference:KM,computeWeightedLoss:Wr,cosineDistance:ZM,hingeLoss:QM,huberLoss:e3,logLoss:s3,meanSquaredError:i3,sigmoidCrossEntropy:l3,softmaxCrossEntropy:h3},TT={sparseFillEmptyRows:p3,sparseReshape:m3,sparseSegmentMean:y3,sparseSegmentSum:x3},kT={stringNGrams:v3,stringSplit:C3,stringToHashBucketFast:k3,staticRegexReplace:N3};const $3=new Map,ey=new Map;class ko{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Hn{constructor(){this.classNameMap={}}static getMap(){return Hn.instance==null&&(Hn.instance=new Hn),Hn.instance}static register(t){Hn.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function nt(s,t,e){$(s.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),$(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=s.className);const n=e,r=t+">"+n;return Hn.register(s),$3.set(r,s),ey.set(s,r),s}function _3(s){return ey.has(s)?ey.get(s):s.className}const E3=Object.freeze(Object.defineProperty({__proto__:null,Serializable:ko,SerializationMap:Hn,getRegisteredName:_3,registerClass:nt},Symbol.toStringTag,{value:"Module"}));class Ur extends ko{minimize(t,e=!1,n){const{value:r,grads:i}=this.computeGradients(t,n);if(n!=null){const o=n.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Nt(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return AC(t,e)}dispose(){this.iterations_!=null&&Nt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:gt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Ur,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});class wb extends Ur{static get className(){return"Adadelta"}constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,r)=>{const i=A.registeredVariables[n],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:W(()=>Rt(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:W(()=>Rt(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[n];if(a==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;W(()=>{const u=tt(F(l,this.rho),F(jt(a),1-this.rho)),h=F(ft(Me(tt(c,this.epsilon)),Me(tt(l,this.epsilon))),a),d=tt(F(c,this.rho),F(jt(h),1-this.rho));l.assign(u),c.assign(d);const p=tt(F(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Nt(this.accumulatedGrads.map(t=>t.variable)),Nt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class vb extends Ur{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,r)=>{const i=A.registeredVariables[n];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:W(()=>So(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[n];if(o==null)return;const a=this.accumulatedGrads[r].variable;W(()=>{const l=tt(a,jt(o));a.assign(l);const c=tt(F(ft(o,Me(tt(l,A.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Nt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class Sb extends Ur{static get className(){return"Adam"}constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],W(()=>{this.accBeta1=gt(e).variable(),this.accBeta2=gt(n).variable()}),r==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);W(()=>{const n=ct(1,this.accBeta1),r=ct(1,this.accBeta2);e.forEach((i,o)=>{const a=A.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:W(()=>Rt(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:W(()=>Rt(a).variable(l))});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=tt(F(u,this.beta1),F(c,1-this.beta1)),p=tt(F(h,this.beta2),F(jt(c),1-this.beta2)),f=ft(d,n),m=ft(p,r);u.assign(d),h.assign(p);const g=tt(F(ft(f,tt(Me(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(F(this.accBeta1,this.beta1)),this.accBeta2.assign(F(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Nt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Nt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),W(()=>{this.accBeta1.assign(nr(this.beta1,this.iterations_+1)),this.accBeta2.assign(nr(this.beta2,this.iterations_+1))});const e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class Cb extends Ur{static get className(){return"Adamax"}constructor(t,e,n,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],W(()=>{this.iteration=gt(0).variable(),this.accBeta1=gt(e).variable()}),r==null&&(this.epsilon=A.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);W(()=>{const n=ct(1,this.accBeta1),r=ft(-this.learningRate,tt(F(this.iteration,this.decay),1));e.forEach((i,o)=>{const a=A.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Rt(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Rt(a).variable(l)});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=tt(F(u,this.beta1),F(c,1-this.beta1)),p=F(h,this.beta2),f=be(c),m=ar(p,f);u.assign(d),h.assign(m);const g=tt(F(ft(r,n),ft(d,tt(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(tt(this.iteration,1)),this.accBeta1.assign(F(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Nt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Nt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class mm extends Ur{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,r)=>{const i=Array.isArray(t)?t[r].tensor:t[n];if(i==null)return;const o=A.registeredVariables[n];W(()=>{const a=tt(F(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ie(gt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class Tb extends mm{static get className(){return"Momentum"}constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=gt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,r)=>{const i=A.registeredVariables[n];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${n}/momentum`,variable:W(()=>Rt(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[n];a!=null&&W(()=>{let l;const c=tt(F(this.m,o),a);this.useNesterov?l=tt(F(this.c,tt(a,F(c,this.m))),i):l=tt(F(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Nt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class kb extends Ur{static get className(){return"RMSProp"}constructor(t,e=.9,n=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=A.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,r)=>{const i=A.registeredVariables[n],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:W(()=>Rt(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:W(()=>Rt(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:W(()=>Rt(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[n];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;W(()=>{const u=tt(F(l,this.decay),F(jt(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=tt(F(h,this.decay),F(a,1-this.decay)),p=ft(F(a,this.learningRate),Me(ct(u,tt(jt(d),this.epsilon)))),f=tt(F(c,this.momentum),p);l.assign(u),h.assign(d),c.assign(f);const m=ct(i,f);i.assign(m)}else{const h=tt(F(l,this.decay),F(jt(a),1-this.decay)),d=tt(F(c,this.momentum),ft(F(a,this.learningRate),Me(tt(h,this.epsilon))));l.assign(h),c.assign(d);const p=ct(i,d);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Nt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Nt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Nt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const D3=[wb,vb,Sb,Cb,Tb,kb,mm];function A3(){for(const s of D3)nt(s)}const O3="model",R3=".json",F3=".weights.bin";function qw(s){return new Promise(t=>setTimeout(t)).then(s)}class uo{constructor(t){if(!j().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(uo.URL_SCHEME)&&(t=t.slice(uo.URL_SCHEME.length)),(t==null||t.length===0)&&(t=O3),this.modelJsonFileName=t+R3,this.weightDataFileName=t+F3}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=Rs.join(t.weightData),n=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=dC(t,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await qw(()=>a.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=n,await qw(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Eu(t)}}}}uo.URL_SCHEME="downloads://";class P3{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const n=new FileReader;n.onload=r=>{const i=JSON.parse(r.target.result),o=i.modelTopology;if(o==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const l=p0(i,c=>this.loadWeights(c));t(l)},n.onerror=r=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){const e=[],n=[];for(const o of t)e.push(...o.weights),n.push(...o.paths);const r=this.checkManifestAndWeightFiles(t),i=n.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(i).then(o=>[e,o])}loadWeightsFile(t,e){return new Promise((n,r)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;n(a)},i.onerror=o=>r(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],n=this.weightsFiles.map(i=>Lw(i.name)),r={};for(const i of t)i.paths.forEach(o=>{const a=Lw(o);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const L3=s=>j().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(uo.URL_SCHEME)?M3(s.slice(uo.URL_SCHEME.length)):null;ie.registerSaveRouter(L3);function M3(s="model"){return new uo(s)}function B3(s){return new P3(s)}function Kw(s,t,e,n){o(s),e=e??0,n=n??1,a(e,n);let r=0;const i=l=>(l.then(c=>{const u=e+ ++r/s.length*(n-e);return t(u),c}),l);function o(l){$(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){$(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),$(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),$(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(s.map(i))}async function IT(s,t){t==null&&(t={});const e=t.fetchFunc==null?j().platform.fetch:t.fetchFunc,n=s.map(h=>e(h,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(n):await Kw(n,t.onProgress,0,.5)).map(h=>h.arrayBuffer());return t.onProgress==null?await Promise.all(a):await Kw(a,t.onProgress,.5,1)}function z3(s,t){var e;const n=t.fetchFunc==null?j().platform.fetch:t.fetchFunc;let r=0,i;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async o=>{for(var a;r<s.length;){i||(i=(await n(s[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await i.read();if(l){r++,i=void 0,(a=t.onProgress)===null||a===void 0||a.call(t,r/s.length);continue}o.enqueue(c);return}o.close()}})}async function V3(s,t="",e,n){return NT(o=>IT(o,{requestInit:n}))(s,t,e)}function NT(s){return async(t,e="",n)=>{const r=t.map(()=>!1),i={},o=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=so[y]*K(g.shape),w=()=>{r[f]=!0,i[f]==null&&(i[f]=[]),i[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};n!=null?n.forEach((x,v)=>{x===g.name&&(w(),o[v]=!0)}):w(),a.push(g.name),m+=b})}),!o.every(p=>p)){const p=n.filter((f,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),c=[];l.forEach(p=>{t[p].paths.forEach(f=>{const m=e+(e.endsWith("/")?"":"/")+f;c.push(m)})});const u=await s(c),h={};let d=0;return l.forEach(p=>{const f=t[p].paths.length,m=new Rs(u.slice(d,d+f));i[p].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),w=lC(b,[y.manifestEntry]);for(const x in w)h[x]=w[x]}),d+=f}),h}}const W3="application/octet-stream",U3="application/json";class Ib{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?($(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=j().platform.fetch,$(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&$(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=dC(t,n);if(e.body.append("model.json",new Blob([JSON.stringify(r)],{type:U3}),"model.json"),t.weightData!=null){const o=Rs.join(t.weightData);e.body.append("model.weights.bin",new Blob([o],{type:W3}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:Eu(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const n=e.modelTopology,r=e.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return p0(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),n=qg(t.weightsManifest),r=()=>z3(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=G3(e),i=this.weightPathPrefix||n,o=[],a=[];for(const l of t)for(const c of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(c)):o.push(i+c+r);return this.weightUrlConverter&&o.push(...await Promise.all(a)),o}async loadWeights(t){const e=await this.getWeightUrls(t),n=qg(t),r=await IT(e,this.loadOptions);return[n,r]}}Ib.URL_SCHEME_REGEX=/^https?:\/\//;function G3(s){const t=s.lastIndexOf("/"),e=s.lastIndexOf("?"),n=s.substring(0,t),r=e>t?s.substring(e):"";return[n+"/",r]}function ny(s){return s.match(Ib.URL_SCHEME_REGEX)!=null}const $T=(s,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(s)?e=s.every(n=>ny(n)):e=ny(s),e)return Nb(s,t)}return null};ie.registerSaveRouter($T);ie.registerLoadRouter($T);function Nb(s,t){return new Ib(s,t)}function j3(s,t){return Nb(s,t)}class og{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class _T{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class H3{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function X3(s,t,e,n){const r=arguments;return new H3(ET(...r))}function ET(s,t,e,n){return arguments.length===1?s.modelTopology!=null||s.weightSpecs!=null?new og(s):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new og({modelTopology:s})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new og({modelTopology:s,weightSpecs:t,weightData:e,trainingConfig:n}))}function q3(s){return new _T(s)}function K3(s){return new _T(s)}const $b=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Rs,browserFiles:B3,browserHTTPRequest:j3,concatenateArrayBuffers:hC,copyModel:kO,decodeWeights:lC,decodeWeightsStream:uC,encodeWeights:Xg,fromMemory:X3,fromMemorySync:ET,getLoadHandlers:hO,getModelArtifactsForJSON:p0,getModelArtifactsForJSONSync:pC,getModelArtifactsInfoForJSON:Eu,getSaveHandlers:fC,getWeightSpecs:qg,http:Nb,isHTTPScheme:ny,listModels:CO,loadWeights:V3,moveModel:IO,registerLoadRouter:uO,registerSaveRouter:cO,removeModel:TO,weightsLoaderFactory:NT,withSaveHandler:q3,withSaveHandlerSync:K3},Symbol.toStringTag,{value:"Module"}));function Y3(s,t,e){const n=E(s,"labels","confusionMatrix"),r=E(t,"predictions","confusionMatrix");$(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),$(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),$(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),$(n.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),$(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);const i=co(rt(n,"int32"),e),o=co(rt(r,"int32"),e),a=At(i),l=Ct(a,o);return rt(l,"int32")}const Z3=O({confusionMatrix_:Y3});const J3=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Z3},Symbol.toStringTag,{value:"Module"}));let Di,Yw=!1;function DT(s,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,r=!1,i=!1,o=!1,a=!1;if(s.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&s instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)i=!0;else if(s.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&s instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${s.constructor.name}`);if(lc(zd,A.backendName)!=null){const f={pixels:s},m={numChannels:t};return A.runKernel(zd,f,m)}const[c,u]=r?[s.videoWidth,s.videoHeight]:[s.width,s.height];let h;if(o)h=s.getContext("2d").getImageData(0,0,c,u).data;else if(n||e)h=s.data;else if(i||r||a){if(Di==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Di=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Di=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Di.canvas.width=c,Di.canvas.height=u,Di.drawImage(s,0,0,c,u),h=Di.getImageData(0,0,c,u).data}let d;if(t===4)d=new Int32Array(h);else{const f=c*u;d=new Int32Array(f*t);for(let m=0;m<f;m++)for(let g=0;g<t;++g)d[m*t+g]=h[m*4+g]}return cb(d,[u,c,t],"int32")}function Q3(s){return s!=null&&s.data instanceof Uint8Array}function tB(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function eB(s){return s!=null&&s.width!==0&&s.height!==0}function nB(s){return tB()&&!(s instanceof ImageBitmap)&&eB(s)&&!Q3(s)}async function sB(s,t=3){let e=null;if(j().getBool("WRAP_TO_IMAGEBITMAP")&&nB(s)){let n;try{n=await createImageBitmap(s,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===s.width&&n.height===s.height?e=n:e=s}else e=s;return DT(e,t)}function AT(s){if(s.rank!==2&&s.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${s.rank}.`);const t=s.rank===2?1:s.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(s.dtype!=="float32"&&s.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${s.dtype}. Please use float32 or int32 tensors.`)}function rB(s){const t=s?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function iB(s,t){let e=E(s,"img","toPixels");if(!(s instanceof Lt)){const c=e;e=rt(c,"int32"),c.dispose()}AT(e);const[n,r]=e.shape.slice(0,2),i=e.rank===2?1:e.shape[2],o=await e.data(),a=e.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*n*4);for(let c=0;c<n*r;++c){const u=[0,0,0,255];for(let d=0;d<i;d++){const p=o[c*i+d];if(e.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(e.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);i===1?(u[0]=p*a,u[1]=p*a,u[2]=p*a):u[d]=p*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(t!=null){Yw||lc(Vp,A.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Yw=!0),t.width=r,t.height=n;const c=t.getContext("2d"),u=new ImageData(l,r,n);c.putImageData(u,0,0)}return e!==s&&e.dispose(),l}function oB(s,t,e){let n=E(s,"img","draw");if(!(s instanceof Lt)){const o=n;n=rt(o,"int32"),o.dispose()}AT(n),rB(e?.imageOptions);const r={image:n},i={canvas:t,options:e};A.runKernel(Vp,r,i)}const OT=O({fromPixels_:DT}),aB=Object.freeze(Object.defineProperty({__proto__:null,draw:oB,fromPixels:OT,fromPixelsAsync:sB,toPixels:iB},Symbol.toStringTag,{value:"Module"}));function gm(s,t){const e=s.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(K(s.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${s.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=s.shape,l=r.slice();l.pop();let c=1;for(let h=i;h<e;++h)c*=a[h],l.push(a[h]);const u=[...yt(s.shape).map(h=>h/c),1].slice(0,i);return[l,o,c,u]}const lB=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:gm},Symbol.toStringTag,{value:"Module"}));const sy=-2,cB=-1;function _b(s,t,e){const n=s.shape.length;$(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),$(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let r=0;r<n;++r)$(t[r]+e[r]<=s.shape[r],()=>`Error in slice${n}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${s.shape[r]})`)}function uB(s){const t=[];let e=0;for(;s>0;)s&1&&t.push(e),s/=2,e++;return t}function Eb(s,t,e){const n=[];for(let r=0;r<s.length;r++)n[r]=Math.ceil((t[r]-s[r])/e[r]);return n}function RT(s,t,e,n){const r=[...s];for(let i=r.length;i<n.length;i++)r.push(1);for(let i=0;i<e;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function FT(s,t,e){return e<=s?e:e-(t-1)}function PT(s,t){const e=[];for(let n=0;n<s;n++)e.push(t+n);return e}function hB(s,t,e,n,r,i,o,a,l){const c=s.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&e>0){const p=t[0],f=e+1;u=LT(o,p,f,n,s),h=MT(a,p,f,r,s),d=RT(i,p,f,s)}else for(let p=0;p<c;p++)u[p]=zT(o,n,i,s,p,l),h[p]=VT(a,r,i,s,p,l),d[p]=BT(i,p,l);return{begin:u,end:h,strides:d}}function LT(s,t,e,n,r){const i=[...r],o=PT(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=FT(t,e,a);let c=n[l];s&1<<l&&(c=0),i[a]=c}return i}function MT(s,t,e,n,r){const i=[...r],o=PT(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=FT(t,e,a);let c=n[l];s&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=oi(0,i[a],r[a])}return i}function BT(s,t,e){let n=s[t];return(e&1<<t||n==null)&&(n=1),n}function zT(s,t,e,n,r,i){let o=t[r];const a=e[r]||1;(s&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=n[r];return o<0&&(o+=l),o=oi(0,o,l-1),o}function VT(s,t,e,n,r,i){let o=t[r];const a=e[r]||1;(s&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=n[r];return o<0&&(o+=l),a>0?o=oi(0,o,l):o=oi(-1,o,l-1),o}function Db(s,t,e){let n=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){n=r;break}for(let r=n+1;r<e.length;r++)if(t[r]>0||e[r]!==s[r])return!1;return!0}function Ab(s,t){let e=s.length>0?s[s.length-1]:1;for(let n=0;n<s.length-1;n++)e+=s[n]*t[n];return e}function ym(s,t,e){let n;const r=s.shape.length;typeof t=="number"?n=[t,...new Array(r-1).fill(0)]:t.length<r?n=t.concat(new Array(r-t.length).fill(0)):n=t.slice(),n.forEach(o=>{$(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((o,a)=>o>=0?o:($(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),s.shape[a]-n[a])),[n,i]}function Ob(s,t,e,n,r,i,o,a,l){let c;if(n==null?(c=new Array(t.length),c.fill(1)):c=n,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let w=0;w<h.dims;w++)u&&(1<<w&a)!==0&&h.numAddAxisAfterEllipsis++,1<<w&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};dB(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let w=0;w<s.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const x=!!(d.shrinkAxisMask&1<<w),v=s[w];if(v===-1){g.push(x?1:-1);continue}const C=[d.beginMask&1<<w,d.endMask&1<<w],k=[d.strides[w]>0?0:-1,d.strides[w]>0?v:v-1];if(x&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[w]===1;const I=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(x){const D=d.begin[w]<0?v+d.begin[w]:d.begin[w];if(d.begin[w]=D,d.end[w]=d.begin[w]+1,D<0||D>=v)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=Zw(d.begin[w],0,d.strides[w],v,C,k),d.end[w]=Zw(d.end[w],1,d.strides[w],v,C,k);const T=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===v;p=p&&T,f=f&&(w===0&&d.strides[w]===1||T)}else p=p&&d.strides[w]===1&&I,f=f&&(w===0&&d.strides[w]===1||I);let N,_=!1;if(d.beginValid&&d.endValid?(N=d.end[w]-d.begin[w],_=!0):x?(N=1,_=!0):I&&v>=0&&(d.strides[w]<0?N=-v:N=v,_=!0),_){let T;N===0||N<0!=d.strides[w]<0?T=0:T=Math.trunc(N/d.strides[w])+(N%d.strides[w]!==0?1:0),g.push(T)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){const x=d.finalShapeGatherIndices[w];x>=0?y.push(g[x]):x===sy&&y.push(1)}return{finalShapeSparse:y.filter((w,x)=>d.finalShapeGatherIndices[x]!==sy),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function dB(s,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=s.begin!=null,t.endValid=s.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<s.dims;n++)if(1<<n&s.ellipsisMask){const r=Math.min(t.dims-(s.dims-n)+1+s.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&s.newAxisMask)t.finalShapeGatherIndices.push(sy),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);s.begin!=null&&(t.begin[e]=s.begin[n]),s.end!=null&&(t.end[e]=s.end[n]),t.strides[e]=s.strides[n],s.beginMask&1<<n&&(t.beginMask|=1<<e),s.endMask&1<<n&&(t.endMask|=1<<e),s.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(cB),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function Zw(s,t,e,n,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const o=s<0?n+s:s;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const WT=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:_b,computeFlatOffset:Ab,computeOutShape:Eb,getNormalizedAxes:hB,isSliceContinous:Db,maskToAxes:uB,parseSliceParams:ym,sliceInfo:Ob,startForAxis:zT,startIndicesWithElidedDims:LT,stopForAxis:VT,stopIndicesWithElidedDims:MT,stridesForAxis:BT,stridesWithElidedDims:RT},Symbol.toStringTag,{value:"Module"}));const pB="4.22.0";class UT{static sgd(t){return new mm(t)}static momentum(t,e,n=!1){return new Tb(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,i=!1){return new kb(t,e,n,r,i)}static adam(t=.001,e=.9,n=.999,r=null){return new Sb(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new wb(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,i=0){return new Cb(t,e,n,r,i)}static adagrad(t,e=.1){return new vb(t,e)}}const Fi=UT;const fB=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:s=>s();function Rb(){return new Promise(s=>fB(()=>s()))}function Fb(s,t){const e=s[0].length;s.forEach((r,i)=>{$(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),$(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const n=s[0];s.forEach((r,i)=>{for(let o=0;o<e;o++)$(o===t||r[o]===n[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${n}) along the non-concatenated axis ${i}.`)})}function Ys(s,t){const e=s[0].slice();for(let n=1;n<s.length;n++)e[t]+=s[n][t];return e}var Ss;(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(Ss||(Ss={}));function GT(s,t,e){let n=new Array;if(e==null&&t==null)return n;if(t==null)for(;n.length<s+e.length;)n.push(-1);else n=t.slice();if(e==null)return n;if(s+e.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${s+e.length}, but shape.rank = ${n.length}`);for(let r=1;r<e.length;++r){const i=e[r],o=n[n.length-e.length+r],a=n[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+s}] = ${i} but shape[${r+s}] = ${a}`)}else n[o]=i}return n}function jT(s){const t={FIRST_DIM_SIZE:Ss.FIRST_DIM_SIZE,VALUE_ROWIDS:Ss.VALUE_ROWIDS,ROW_LENGTHS:Ss.ROW_LENGTHS,ROW_SPLITS:Ss.ROW_SPLITS,ROW_LIMITS:Ss.ROW_LIMITS,ROW_STARTS:Ss.ROW_STARTS},e=[];for(const n of s)if(n in t)e.push(t[n]);else break;return e}function HT(s){return s.length===0?0:s[0]===Ss.FIRST_DIM_SIZE?s.length-1:s.length}function XT(s,t){if(s==null||t==null)return;const e=s.length,n=t.length;if(e>=n)throw new Error(`defaultValue.shape=${s} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${n})`);for(let r=0;r<Math.min(e,n-1);++r){const i=s[r],o=t[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${s}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-s.length}] = ${i} but ragged tensor input.flatValues.shape[${r-s.length}] = ${o}`)}}const Pb=30;function bm(s){return s<=Pb?s:Ld(s,Math.floor(Math.sqrt(s)))}function Lb(s,t,e){const n=e*(typeof s=="number"?s:s[0]),r=t*(typeof s=="number"?s:s[1]);return[n,r]}function Ku(s,t,e,n=!0){let r=[];if(n)r=r.concat(t.slice(0)),r.push(s[0]/e),r=r.concat(s.slice(1));else{r=r.concat(s[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([s[o+1]/t[o],t[o]]);r=r.concat(s.slice(i+1))}return r}function Yu(s,t,e=!0){const n=[];if(e){n.push(t);for(let r=t+1;r<s;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],i=[];for(let o=1;o<s;++o)o>=t*2+1||o%2===1?i.push(o):r.push(o);n.push(...r),n.push(0),n.push(...i)}return n}function Zu(s,t,e,n=!0){const r=[];n?r.push(s[0]/e):r.push(s[0]*e);for(let i=1;i<s.length;++i)i<=t.length?n?r.push(t[i-1]*s[i]):r.push(s[i]/t[i-1]):r.push(s[i]);return r}function Mb(s,t){const e=[0];for(let n=0;n<t;++n)e.push(s[n][0]);return e}function Bb(s,t,e){const n=s.slice(0,1);for(let r=0;r<e;++r)n.push(s[r+1]-t[r][0]-t[r][1]);return n}const xm=1.7580993408473768,wm=1.0507009873554805;const zb=.3275911,Vb=.254829592,Wb=-.284496736,Ub=1.421413741,Gb=-1.453152027,jb=1.061405429;function Ar(s,t){if(s.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${s.length}, imag: ${t.length}.`);const e=new Float32Array(s.length*2);for(let n=0;n<e.length;n+=2)e[n]=s[n/2],e[n+1]=t[n/2];return e}function qT(s){const t=new Float32Array(s.length/2),e=new Float32Array(s.length/2);for(let n=0;n<s.length;n+=2)t[n/2]=s[n],e[n/2]=s[n+1];return{real:t,imag:e}}function KT(s){const t=Math.ceil(s.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let r=0;r<s.length;r+=4)e[Math.floor(r/4)]=s[r],n[Math.floor(r/4)]=s[r+1];return{real:e,imag:n}}function YT(s){const t=Math.floor(s.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let r=2;r<s.length;r+=4)e[Math.floor(r/4)]=s[r],n[Math.floor(r/4)]=s[r+1];return{real:e,imag:n}}function Hb(s,t){const e=s[t*2],n=s[t*2+1];return{real:e,imag:n}}function ZT(s,t,e,n){s[n*2]=t,s[n*2+1]=e}function JT(s,t){const e=new Float32Array(s/2),n=new Float32Array(s/2);for(let r=0;r<Math.ceil(s/2);r++){const i=(t?2:-2)*Math.PI*(r/s);e[r]=Math.cos(i),n[r]=Math.sin(i)}return{real:e,imag:n}}function QT(s,t,e){const n=(e?2:-2)*Math.PI*(s/t),r=Math.cos(n),i=Math.sin(n);return{real:r,imag:i}}const ag="->",mB=/->/g,Jw=",",Qw="...";function Xb(s,t){s=s.replace(/\s/g,"");const e=(s.length-s.replace(mB,"").length)/ag.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${ag}").`);const[n,r]=s.split(ag);$(n.indexOf(Qw)===-1,()=>`The ellipsis notation ("${Qw}") is not supported yet.`);const i=n.split(Jw),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!i.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<n.length;++d){const p=n[d];a.indexOf(p)===-1&&p!==Jw&&a.push(p)}const l=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<i[d].length;++p)l[d].push(a.indexOf(i[d][p]))}const c=a.length,u=r.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function qb(s,t){let e=new Array(s);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const n=[];for(let r=0;r<s;++r)e[r]===-1&&n.push(r);return e=e.filter(r=>r!==-1),{permutationIndices:e,expandDims:n}}function Kb(s,t,e){const n=new Array(s);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let o=0;o<t[r].length;++o)n[t[r][o]]===void 0?n[t[r][o]]=i[o]:$(n[t[r][o]]===i[o],()=>`Expected dimension ${n[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function Yb(s,t){const e=s,n=[];let r=0;s.length===0&&e.push(-1),r=s.length+1;for(let o=0;o<r;++o)n.push([]);const i=[];for(let o=0;o<e.length;++o){const a=e[o],l=gB(t,a);for(const c of l)i.indexOf(c)===-1&&(n[o].push(c),i.push(c))}return{path:e,steps:n}}function Zb(s){return s.every((t,e)=>t===e)}function gB(s,t){const e=[];for(let n=0;n<s.length;++n)(s[n].length===0||s[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function Jb(s,t,e=0){let n=[];if(typeof t=="number")$(s.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(s.shape[e]/t);else{const r=t.reduce((o,a)=>(a===-1&&(o+=1),o),0);$(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=s.shape[e]-o}$(s.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function tk(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${s}`}function ek(s,t){return`indices(${s}, 0) is invalid: ${t} < 0`}function nk(s,t,e){return`indices(${s}, 0) is invalid: ${t} >= ${e}`}function sk(s,t){return`only one output dimension may be -1, not both ${s} and ${t}`}function rk(s,t){return`size ${s} must be non-negative, not ${t}`}function ik(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ok(s,t){const e=K(s),n=K(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${s} outputShape= ${t}`}function ak(s,t){const e=K(s),n=K(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${s} outputShape=${t}`}function ry(){return"segment ids must be >= 0"}function lk(){return"segment ids are not increasing"}function ck(s,t){return`Segment id ${s} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function uk(s,t,e){return`Bad: indices[${s}] == ${t} out of range [0, ${e})`}function hk(s,t){let e=!1,n;for(s<=Pb?(n=s,e=!0):n=Ld(s,Math.floor(Math.sqrt(s)));!e;)n>t||n===s?e=!0:n=Ld(s,n+1);return n}function dk(s,t,e){const n=[],r=s.length;for(let i=0;i<r;i++)i!==t?n.push(s[i]):n.push(e);return n}function Qb(s,t,e,n){const r=t.shape.length,i=s.shape.length;if(n!==0&&(n<-r||n>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${n}`);if(n<0&&(n+=r),n>i)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${i}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let h=0;h<n;++h)if(s.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${s.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const o=s.shape[e],a=[];let l=1,c=1,u=1;for(let h=0;h<n;++h)a.push(s.shape[h]),l*=s.shape[h];for(let h=n;h<e;h++)a.push(s.shape[h]),c*=s.shape[h];for(let h=n;h<r;h++)a.push(t.shape[h]);for(let h=e+1;h<i;h++)a.push(s.shape[h]),u*=s.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const yB=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Qb,computeOutShape:dk,segOpComputeOptimalWindowSize:hk},Symbol.toStringTag,{value:"Module"}));function Or(s){try{return s.map(t=>$r(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function pk(s){return s.map(t=>qs(t))}const fk=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Vb,ERF_A2:Wb,ERF_A3:Ub,ERF_A4:Gb,ERF_A5:jb,ERF_P:zb,PARALLELIZE_THRESHOLD:Pb,get RowPartitionType(){return Ss},SELU_SCALE:wm,SELU_SCALEALPHA:xm,applyActivation:um,assertAndGetBroadcastShape:St,assertAxesAreInnerMostDims:qe,assertParamsConsistent:Fb,assignToTypedArray:ZT,axesAreInnerMostDims:V0,calculateShapes:Ii,checkEinsumDimSizes:Kb,checkPadOnDimRoundingMode:cn,combineLocations:_C,combineRaggedTensorToTensorShapes:GT,complexWithEvenIndex:KT,complexWithOddIndex:YT,computeConv2DInfo:Be,computeConv3DInfo:Si,computeDefaultPad:C0,computeDilation2DInfo:Du,computeOptimalWindowSize:bm,computeOutAndReduceShapes:ze,computeOutShape:Ys,computePool2DInfo:ds,computePool3DInfo:Mr,convertConv2DDataFormat:Br,decodeEinsumEquation:Xb,eitherStridesOrDilationsAreOne:Xe,expandShapeToKeepDim:fe,exponent:QT,exponents:JT,fromStringArrayToUint8:pk,fromUint8ToStringArray:Or,getAxesPermutation:ce,getBroadcastDims:ao,getComplexWithIndex:Hb,getEinsumComputePath:Yb,getEinsumPermutation:qb,getFusedBiasGradient:cm,getFusedDyActivation:lm,getImageCenter:Lb,getInnerMostAxes:me,getPermuted:Yu,getRaggedRank:HT,getReductionAxes:Te,getReshaped:Ku,getReshapedPermuted:Zu,getRowPartitionTypesHelper:jT,getSliceBeginCoords:Mb,getSliceSize:Bb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:tk,getSparseFillEmptyRowsNegativeIndexErrorMessage:ek,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:nk,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:ik,getSparseReshapeInputOutputMismatchErrorMessage:ak,getSparseReshapeInputOutputMultipleErrorMessage:ok,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:sk,getSparseReshapeNegativeOutputDimErrorMessage:rk,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:uk,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ry,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:lk,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:ck,getUndoAxesPermutation:Ci,isIdentityPermutation:Zb,log:aA,mergeRealAndImagArrays:Ar,prepareAndValidate:gm,prepareSplitSize:Jb,segment_util:yB,shouldFuse:hm,slice_util:WT,splitRealAndImagArrays:qT,stridesOrDilationsArePositive:oo,tupleValuesAreOne:hi,upcastType:bn,validateDefaultValueShape:XT,validateInput:sm,validateUpdateShape:ub,warn:jn},Symbol.toStringTag,{value:"Module"}));const bB=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:dm,nonMaxSuppressionV4Impl:pm,nonMaxSuppressionV5Impl:fm,whereImpl:om},Symbol.toStringTag,{value:"Module"}));A3();const mk=Object.freeze(Object.defineProperty({__proto__:null,Abs:Ic,Acos:xa,Acosh:wa,AdadeltaOptimizer:wb,AdagradOptimizer:vb,AdamOptimizer:Sb,AdamaxOptimizer:Cb,Add:vo,AddN:Nc,All:Tp,Any:kp,ArgMax:$c,ArgMin:_c,Asin:va,Asinh:Sa,Atan:Ca,Atan2:ka,Atanh:Ta,AvgPool:Ec,AvgPool3D:Dc,AvgPool3DGrad:Np,AvgPoolGrad:Ip,BatchMatMul:Ac,BatchToSpaceND:Oc,Bincount:$p,BitwiseAnd:Rc,BroadcastArgs:_p,BroadcastTo:jS,Cast:Ia,Ceil:Na,ClipByValue:$a,Complex:Ep,ComplexAbs:Fc,Concat:Pc,Conv2D:Lc,Conv2DBackpropFilter:Dp,Conv2DBackpropInput:Mc,Conv3D:Bc,Conv3DBackpropFilterV2:Ap,Conv3DBackpropInputV2:Op,Cos:_a,Cosh:Ea,CropAndResize:Fp,Cumprod:Rp,Cumsum:zc,DataStorage:Jy,DenseBincount:Pp,DepthToSpace:Lp,DepthwiseConv2dNative:Vc,DepthwiseConv2dNativeBackpropFilter:Mp,DepthwiseConv2dNativeBackpropInput:Bp,Diag:zp,Dilation2D:Wc,Dilation2DBackpropFilter:Bd,Dilation2DBackpropInput:Md,Draw:Vp,get ENV(){return s0},Einsum:Wp,Elu:Aa,EluGrad:Up,Environment:US,Equal:Uc,Erf:Oa,Exp:Ra,ExpandDims:Gc,Expm1:Fa,FFT:Gp,Fill:jp,FlipLeftRight:Hp,Floor:Pa,FloorDiv:La,FromPixels:zd,FusedBatchNorm:jc,FusedConv2D:ic,FusedDepthwiseConv2D:oc,GatherNd:Xp,GatherV2:Hc,Greater:Xc,GreaterEqual:Ma,IFFT:qp,Identity:Ba,Imag:Kp,IsFinite:za,IsInf:Va,IsNan:Wa,KernelBackend:vp,LRN:tu,LRNGrad:Zp,LeakyRelu:qc,Less:Kc,LessEqual:Yc,LinSpace:Yp,Log:Ua,Log1p:Ga,LogSoftmax:HS,LogicalAnd:Zc,LogicalNot:Jc,LogicalOr:Qc,LogicalXor:nA,LowerBound:sA,MatrixBandPart:rA,Max:eu,MaxPool:nu,MaxPool3D:su,MaxPool3DGrad:Qp,MaxPoolGrad:Jp,MaxPoolWithArgmax:tf,Maximum:ja,Mean:ru,Min:iu,Minimum:Ha,MirrorPad:ou,Mod:Xa,MomentumOptimizer:Tb,Multinomial:ef,Multiply:qa,Neg:au,NonMaxSuppressionV3:nf,NonMaxSuppressionV4:sf,NonMaxSuppressionV5:rf,NotEqual:lu,OP_SCOPE_SUFFIX:c0,OneHot:uu,OnesLike:cu,Optimizer:Ur,OptimizerConstructors:UT,Pack:hu,PadV2:du,Pool:iA,Pow:Ka,Prelu:pu,Prod:fu,RMSPropOptimizer:kb,RaggedGather:of,RaggedRange:af,RaggedTensorToTensor:lf,Range:cf,get Rank(){return zg},Real:uf,RealDiv:Da,Reciprocal:Ya,get Reduction(){return rn},Relu:Za,Relu6:Ja,Reshape:mu,ResizeBilinear:yu,ResizeBilinearGrad:df,ResizeNearestNeighbor:gu,ResizeNearestNeighborGrad:hf,Reverse:bu,RotateWithOffset:_f,Round:Qa,Rsqrt:tl,SGDOptimizer:mm,ScatterNd:pf,SearchSorted:mf,Select:xu,Selu:el,Sigmoid:il,Sign:rl,Sin:nl,Sinh:sl,Slice:wu,Softmax:Tu,Softplus:ol,SpaceToBatchND:Su,SparseFillEmptyRows:gf,SparseReshape:yf,SparseSegmentMean:bf,SparseSegmentSum:xf,SparseToDense:wf,SplitV:Cu,Sqrt:al,Square:vf,SquaredDifference:ll,StaticRegexReplace:ku,Step:pl,StridedSlice:Sf,StringNGrams:Cf,StringSplit:Tf,StringToHashBucketFast:kf,Sub:cl,Sum:vu,Tan:ul,Tanh:hl,Tensor:Lt,TensorBuffer:Ce,TensorScatterUpdate:ff,Tile:dl,TopK:If,Transform:Nf,Transpose:Zi,Unique:$f,Unpack:Iu,UnsortedSegmentSum:Nu,UpperBound:oA,Variable:cc,ZerosLike:$u,_FusedMatMul:rc,abs:be,acos:m0,acosh:g0,add:tt,addN:SC,all:Rf,any:hc,argMax:ui,argMin:y0,asin:b0,asinh:x0,atan:w0,atan2:v0,atanh:S0,avgPool:Au,avgPool3d:T0,backend:Af,backend_util:fk,basicLSTMCell:CC,batchNorm:fl,batchNorm2d:k0,batchNorm3d:I0,batchNorm4d:N0,batchToSpaceND:Ou,bincount:$0,bitwiseAnd:TC,booleanMaskAsync:aT,broadcastArgs:kC,broadcastTo:Ji,broadcast_util:VR,browser:aB,buffer:Tt,cast:rt,ceil:_0,clipByValue:wn,clone:Ks,complex:_r,concat:pe,concat1d:E0,concat2d:D0,concat3d:A0,concat4d:O0,conv1d:Ff,conv2d:Er,conv2dTranspose:Pf,conv3d:F0,conv3dTranspose:P0,copyRegisteredKernels:uA,cos:Ru,cosh:Lf,cosineWindow:am,cumprod:fc,cumsum:Mf,customGrad:sr,denseBincount:Wd,deprecationWarn:jA,depthToSpace:L0,depthwiseConv2d:ml,device_util:BA,diag:NC,dilation2d:M0,disableDeprecationWarnings:GA,dispose:Nt,disposeVariables:HA,div:ft,divNoNan:B0,dot:z0,dropout:mb,einsum:zi,elu:gl,enableDebugMode:UA,enableProdMode:WA,enclosingPowerOfTwo:gb,engine:Gn,ensureShape:$C,env:j,equal:Pn,erf:Bf,euclideanNorm:W0,exp:vn,expandDims:we,expm1:U0,eye:zf,fft:Xu,fill:So,findBackend:ZA,findBackendFactory:JA,floor:bl,floorDiv:Of,fused:gT,gather:xl,gatherND:hT,gather_util:lB,getBackend:u0,getGradient:Mg,getKernel:lc,getKernelsForBackend:Vd,grad:TF,grads:kF,greater:un,greaterEqual:zr,ifft:ia,imag:Fu,image:Dn,inTopKAsync:dT,io:$b,irfft:em,isFinite:G0,isInf:j0,isNaN:H0,keep:Ie,kernel_impls:bB,leakyRelu:Pu,less:na,lessEqual:Ti,linalg:xb,linspace:DC,localResponseNormalization:X0,log:Ln,log1p:Lu,logSigmoid:q0,logSoftmax:Wf,logSumExp:Mu,logicalAnd:Es,logicalNot:Bu,logicalOr:Uf,logicalXor:K0,losses:CT,lowerBound:OC,matMul:Ct,math:J3,max:Jn,maxPool:zu,maxPool3d:Y0,maxPoolWithArgmax:RC,maximum:ar,mean:oe,memory:Hg,meshgrid:FC,min:ea,minimum:pi,mirrorPad:Z0,mod:J0,moments:Vu,movingAverage:lT,mul:F,multiRNNCell:PC,multinomial:LC,neg:Zt,nextFrame:Rb,norm:yl,notEqual:lo,oneHot:co,ones:mn,onesLike:Mn,op:O,outerProduct:MC,pad:Vr,pad1d:BC,pad2d:zC,pad3d:Q0,pad4d:VC,pool:tb,pow:nr,prelu:Uu,print:f0,prod:eb,profile:XA,raggedGather:WC,raggedRange:UC,raggedTensorToTensor:GC,rand:jC,randomGamma:qC,randomNormal:Hf,randomStandardNormal:KC,randomUniform:ki,randomUniformInt:YC,range:Dr,ready:aC,real:sa,reciprocal:ib,registerBackend:h0,registerGradient:XS,registerKernel:Ef,relu:Fs,relu6:Xf,removeBackend:YA,reshape:L,reverse:Qn,reverse1d:ZC,reverse2d:JC,reverse3d:QC,reverse4d:tT,rfft:qu,round:qf,rsqrt:Kf,scalar:gt,scatterND:cT,scatter_util:_L,searchSorted:Gf,selu:Yf,separableConv2d:Zf,serialization:E3,setBackend:KA,setPlatform:QA,setdiff1dAsync:eT,sigmoid:Zn,sign:ob,signal:ST,sin:Jf,sinh:Qf,slice:Ot,slice1d:Gu,slice2d:tm,slice3d:ju,slice4d:ra,slice_util:WT,softmax:Hu,softplus:Co,spaceToBatchND:Wu,sparse:TT,sparseToDense:uT,spectral:vT,split:gn,sqrt:Me,square:jt,squaredDifference:nm,squeeze:En,stack:Sn,step:To,stridedSlice:ab,string:kT,sub:ct,sum:ht,sumOutType:Df,tan:lb,tanh:di,tensor:Yn,tensor1d:Je,tensor2d:Ko,tensor3d:cb,tensor4d:nT,tensor5d:sT,tensor6d:rT,tensorScatterUpdate:iT,tensor_util:RA,test_util:WP,tidy:W,tile:Xn,time:qA,topk:hb,train:Fi,transpose:At,truncatedNormal:rm,unique:db,unregisterGradient:cA,unregisterKernel:lA,unsortedSegmentSum:im,unstack:ts,upcastType:bn,upperBound:oT,util:vA,valueAndGrad:IF,valueAndGrads:NF,variable:pb,variableGrads:AC,version_core:pB,where:Ge,whereAsync:fb,zeros:ve,zerosLike:Rt},Symbol.toStringTag,{value:"Module"}));const xB=j();xB.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var kn;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(kn||(kn={}));var tv;(function(s){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(tv||(tv={}));const wB={};function gk(s){return wB[s]}function S(s,t,e,n,r){const i=t.inputParams[s];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,c=a<0?t.inputNames.length+a:a;if(i.type==="tensor")return We(t.inputNames[c],e,n,r);if(i.type==="tensors"){const d=t.inputs.slice(a,l);return t.inputNames.slice(a,l).filter((f,m)=>{var g;return((g=d[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>We(f,e,n,r))}const u=We(t.inputNames[c],e,n,r),h=u.dataSync();return i.type==="number"?h[0]:Kn(u.shape,h)}const o=t.attrParams[s];return o&&o.value}function We(s,t,e,n){const[r,i]=In(s,e);if(n!=null){const a=n.getHashTableHandleByName(r);if(a!=null)return a}const o=e.currentContextIds.find(a=>!!t[Ud(r,a)]);return o!==void 0?t[Ud(r,o)][i]:void 0}function ev(s,t,e){return t[Ud(s,e.currentContextId)]}function fr(s,t){const[e,n,r]=In(s,t);return[Ud(e,t&&t.currentContextId),n,r]}function Ud(s,t){return t?`${s}-${t}`:s}function In(s,t){if(s==="")return["",0,void 0];const e=t!=null&&t.parseNodeNameCache!=null;if(e){const i=t.parseNodeNameCache.get(s);if(i!=null)return i}const n=s.split(":");let r;if(n.length===1)r=[s,0,void 0];else{const i=n[0],o=n.length===3?n[1]:void 0,a=Number(n[n.length-1]);r=[i,a,o]}return e&&t.parseNodeNameCache.set(s,r),r}function vd(s,t,e){let n=S("pad",s,t,e);if(n==="explicit"){n=S("explicitPaddings",s,t,e);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=n[i*2],r[i][1]=n[i*2+1];return r}return n}function mr(s){return s.kept?s:Ks(s)}const vB=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SB=Object.freeze(Object.defineProperty({__proto__:null,json:vB},Symbol.toStringTag,{value:"Module"}));const CB=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],TB=Object.freeze(Object.defineProperty({__proto__:null,json:CB},Symbol.toStringTag,{value:"Module"}));const kB=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],IB=Object.freeze(Object.defineProperty({__proto__:null,json:kB},Symbol.toStringTag,{value:"Module"}));const NB=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],$B=Object.freeze(Object.defineProperty({__proto__:null,json:NB},Symbol.toStringTag,{value:"Module"}));const _B=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],EB=Object.freeze(Object.defineProperty({__proto__:null,json:_B},Symbol.toStringTag,{value:"Module"}));const DB=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],AB=Object.freeze(Object.defineProperty({__proto__:null,json:DB},Symbol.toStringTag,{value:"Module"}));const OB=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],RB=Object.freeze(Object.defineProperty({__proto__:null,json:OB},Symbol.toStringTag,{value:"Module"}));const FB=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],PB=Object.freeze(Object.defineProperty({__proto__:null,json:FB},Symbol.toStringTag,{value:"Module"}));const LB=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],MB=Object.freeze(Object.defineProperty({__proto__:null,json:LB},Symbol.toStringTag,{value:"Module"}));const BB=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],zB=Object.freeze(Object.defineProperty({__proto__:null,json:BB},Symbol.toStringTag,{value:"Module"}));const VB=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],WB=Object.freeze(Object.defineProperty({__proto__:null,json:VB},Symbol.toStringTag,{value:"Module"}));const UB=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],GB=Object.freeze(Object.defineProperty({__proto__:null,json:UB},Symbol.toStringTag,{value:"Module"}));const jB=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],HB=Object.freeze(Object.defineProperty({__proto__:null,json:jB},Symbol.toStringTag,{value:"Module"}));const XB=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],qB=Object.freeze(Object.defineProperty({__proto__:null,json:XB},Symbol.toStringTag,{value:"Module"}));const KB=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],YB=Object.freeze(Object.defineProperty({__proto__:null,json:KB},Symbol.toStringTag,{value:"Module"}));const ZB=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],JB=Object.freeze(Object.defineProperty({__proto__:null,json:ZB},Symbol.toStringTag,{value:"Module"}));const QB=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],tz=Object.freeze(Object.defineProperty({__proto__:null,json:QB},Symbol.toStringTag,{value:"Module"}));const ez=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],nz=Object.freeze(Object.defineProperty({__proto__:null,json:ez},Symbol.toStringTag,{value:"Module"}));const sz=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],rz=Object.freeze(Object.defineProperty({__proto__:null,json:sz},Symbol.toStringTag,{value:"Module"}));class nv{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[SB,TB,IB,$B,EB,AB,RB,PB,MB,zB,WB,GB,HB,qB,YB,JB,tz,nz,rz],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(t,e={}){const n=t.node,r=[],i=[],o=[],a=n.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?i.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},h={};e!=null&&(u=this.mapSignatureEntries(e.inputs),h=this.mapSignatureEntries(e.outputs));const d=Object.keys(a);d.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[w,,x]=fr(y),v=a[w];if(v.outputs!=null){const C=v.outputs.indexOf(x);if(C!==-1){const k=`${w}:${C}`;g.inputNames[b]=k}}g.inputs.push(v),v.children.push(g)})}),Object.keys(h).length===0?d.forEach(m=>{const g=a[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{const[g]=fr(m),y=a[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=fr(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=r;let p={};t.library!=null&&t.library.function!=null&&(p=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:a,inputs:l,outputs:c,weights:i,placeholders:r,signature:e,functions:p};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){const e=gk(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((r,i)=>{const o=i.type;let a;switch(i.type){case"string":a=iy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=iy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=dy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=dy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=ay(t.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=ay(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=hy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=hy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=oy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=oy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=fy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=fy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=uy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=uy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=py(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=py(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=ly(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=ly(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=cy(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=cy(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=sv(t.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=sv(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return r[i.name]={value:a,type:o},r},{})),n}mapFunction(t){const e=t.nodeDef,n=[],r=[];let i={};e!=null&&(i=e.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const o=[],a=[];t.signature.inputArg.forEach(h=>{const[d]=fr(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:tx(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,o.push(p),i[d]=p}),Object.keys(i).forEach(h=>{const d=i[h];d.inputNames.forEach((p,f)=>{const[m,,g]=fr(p),y=i[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const w=`${m}:${b}`;d.inputNames[f]=w}}d.inputs.push(y),y.children.push(d)})});const c=t.ret;t.signature.outputArg.forEach(h=>{const[d,p]=fr(c[h.name]),f=i[d];f!=null&&(f.defaultOutput=p,a.push(f))});const u=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:r,placeholders:n,signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}}function iz(s){const t=j().global;if(typeof t.atob<"u")return t.atob(s);if(typeof Buffer<"u")return new Buffer(s,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function yk(s,t){const e=Array.isArray(s)?String.fromCharCode.apply(null,s):iz(s);return t?e:e.toLowerCase()}function iy(s,t,e,n=!1){const r=s[t];return r!=null?yk(r.s,n):e}function oy(s,t,e){const n=s[t];return n?n.b:e}function ay(s,t,e){const n=s[t]||{},r=n.i!=null?n.i:n.f!=null?n.f:e;return typeof r=="number"?r:parseInt(r,10)}function tx(s){switch(typeof s=="string"&&(s=kn[s]),s){case kn.DT_FLOAT:case kn.DT_HALF:return"float32";case kn.DT_INT32:case kn.DT_INT64:case kn.DT_INT8:case kn.DT_UINT8:return"int32";case kn.DT_BOOL:return"bool";case kn.DT_DOUBLE:return"float32";case kn.DT_STRING:return"string";case kn.DT_COMPLEX64:case kn.DT_COMPLEX128:return"complex64";default:return null}}function sv(s,t,e){const n=s[t];return n&&n.func?n.func.name:e}function ly(s,t,e){const n=s[t];return n&&n.type?tx(n.type):e}function cy(s,t,e){const n=s[t];return n&&n.list&&n.list.type?n.list.type.map(r=>tx(r)):e}function bk(s){if(!s.unknownRank)return s.dim!=null?s.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function uy(s,t,e){const n=s[t];return n&&n.shape?bk(n.shape):e}function hy(s,t,e){const n=s[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):e}function dy(s,t,e,n=!1){const r=s[t];return r&&r.list&&r.list.s?r.list.s.map(i=>yk(i,n)):e}function py(s,t,e){const n=s[t];return n&&n.list&&n.list.shape?n.list.shape.map(r=>bk(r)):e}function fy(s,t,e){const n=s[t];return n&&n.list&&n.list.b?n.list.b:e}class oz{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(t){return We(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(n.tensor!=null)return We(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return ay(this.node.rawAttrs,t,e);if(n.s!=null)return iy(this.node.rawAttrs,t,e);if(n.b!=null)return oy(this.node.rawAttrs,t,e);if(n.shape!=null)return uy(this.node.rawAttrs,t,e);if(n.type!=null)return ly(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return hy(this.node.rawAttrs,t,e);if(n.list.s!=null)return dy(this.node.rawAttrs,t,e);if(n.list.shape!=null)return py(this.node.rawAttrs,t,e);if(n.list.b!=null)return fy(this.node.rawAttrs,t,e);if(n.list.type!=null)return cy(this.node.rawAttrs,t,e)}return e}}const Ke=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:c0,abs:be,acos:m0,acosh:g0,add:tt,addN:SC,all:Rf,any:hc,argMax:ui,argMin:y0,asin:b0,asinh:x0,atan:w0,atan2:v0,atanh:S0,avgPool:Au,avgPool3d:T0,basicLSTMCell:CC,batchNorm:fl,batchNorm2d:k0,batchNorm3d:I0,batchNorm4d:N0,batchToSpaceND:Ou,bincount:$0,bitwiseAnd:TC,booleanMaskAsync:aT,broadcastArgs:kC,broadcastTo:Ji,buffer:Tt,cast:rt,ceil:_0,clipByValue:wn,clone:Ks,complex:_r,concat:pe,concat1d:E0,concat2d:D0,concat3d:A0,concat4d:O0,conv1d:Ff,conv2d:Er,conv2dTranspose:Pf,conv3d:F0,conv3dTranspose:P0,cos:Ru,cosh:Lf,cosineWindow:am,cumprod:fc,cumsum:Mf,denseBincount:Wd,depthToSpace:L0,depthwiseConv2d:ml,diag:NC,dilation2d:M0,div:ft,divNoNan:B0,dot:z0,dropout:mb,einsum:zi,elu:gl,enclosingPowerOfTwo:gb,ensureShape:$C,equal:Pn,erf:Bf,euclideanNorm:W0,exp:vn,expandDims:we,expm1:U0,eye:zf,fft:Xu,fill:So,floor:bl,floorDiv:Of,fused:gT,gather:xl,gatherND:hT,greater:un,greaterEqual:zr,ifft:ia,imag:Fu,image:Dn,inTopKAsync:dT,irfft:em,isFinite:G0,isInf:j0,isNaN:H0,leakyRelu:Pu,less:na,lessEqual:Ti,linalg:xb,linspace:DC,localResponseNormalization:X0,log:Ln,log1p:Lu,logSigmoid:q0,logSoftmax:Wf,logSumExp:Mu,logicalAnd:Es,logicalNot:Bu,logicalOr:Uf,logicalXor:K0,losses:CT,lowerBound:OC,matMul:Ct,max:Jn,maxPool:zu,maxPool3d:Y0,maxPoolWithArgmax:RC,maximum:ar,mean:oe,meshgrid:FC,min:ea,minimum:pi,mirrorPad:Z0,mod:J0,moments:Vu,movingAverage:lT,mul:F,multiRNNCell:PC,multinomial:LC,neg:Zt,norm:yl,notEqual:lo,oneHot:co,ones:mn,onesLike:Mn,op:O,outerProduct:MC,pad:Vr,pad1d:BC,pad2d:zC,pad3d:Q0,pad4d:VC,pool:tb,pow:nr,prelu:Uu,print:f0,prod:eb,raggedGather:WC,raggedRange:UC,raggedTensorToTensor:GC,rand:jC,randomGamma:qC,randomNormal:Hf,randomStandardNormal:KC,randomUniform:ki,randomUniformInt:YC,range:Dr,real:sa,reciprocal:ib,relu:Fs,relu6:Xf,reshape:L,reverse:Qn,reverse1d:ZC,reverse2d:JC,reverse3d:QC,reverse4d:tT,rfft:qu,round:qf,rsqrt:Kf,scalar:gt,scatterND:cT,searchSorted:Gf,selu:Yf,separableConv2d:Zf,setdiff1dAsync:eT,sigmoid:Zn,sign:ob,signal:ST,sin:Jf,sinh:Qf,slice:Ot,slice1d:Gu,slice2d:tm,slice3d:ju,slice4d:ra,softmax:Hu,softplus:Co,spaceToBatchND:Wu,sparse:TT,sparseToDense:uT,spectral:vT,split:gn,sqrt:Me,square:jt,squaredDifference:nm,squeeze:En,stack:Sn,step:To,stridedSlice:ab,string:kT,sub:ct,sum:ht,tan:lb,tanh:di,tensor:Yn,tensor1d:Je,tensor2d:Ko,tensor3d:cb,tensor4d:nT,tensor5d:sT,tensor6d:rT,tensorScatterUpdate:iT,tile:Xn,topk:hb,transpose:At,truncatedNormal:rm,unique:db,unsortedSegmentSum:im,unstack:ts,upperBound:oT,variable:pb,where:Ge,whereAsync:fb,zeros:ve,zerosLike:Rt},Symbol.toStringTag,{value:"Module"}));const az=(s,t,e,n=Ke)=>{switch(s.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(S("a",s,t,e),S("b",s,t,e))];case"AddN":return[n.addN(S("tensors",s,t,e))];case"FloorMod":case"Mod":return[n.mod(S("a",s,t,e),S("b",s,t,e))];case"Mul":return[n.mul(S("a",s,t,e),S("b",s,t,e))];case"RealDiv":case"Div":return[n.div(S("a",s,t,e),S("b",s,t,e))];case"DivNoNan":return[n.divNoNan(S("a",s,t,e),S("b",s,t,e))];case"FloorDiv":return[n.floorDiv(S("a",s,t,e),S("b",s,t,e))];case"Sub":return[n.sub(S("a",s,t,e),S("b",s,t,e))];case"Minimum":return[n.minimum(S("a",s,t,e),S("b",s,t,e))];case"Maximum":return[n.maximum(S("a",s,t,e),S("b",s,t,e))];case"Pow":return[n.pow(S("a",s,t,e),S("b",s,t,e))];case"SquaredDifference":return[n.squaredDifference(S("a",s,t,e),S("b",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const lz=(s,t,e,n=Ke)=>{switch(s.op){case"Abs":case"ComplexAbs":return[n.abs(S("x",s,t,e))];case"Acos":return[n.acos(S("x",s,t,e))];case"Acosh":return[n.acosh(S("x",s,t,e))];case"Asin":return[n.asin(S("x",s,t,e))];case"Asinh":return[n.asinh(S("x",s,t,e))];case"Atan":return[n.atan(S("x",s,t,e))];case"Atan2":return[n.atan2(S("x",s,t,e),S("y",s,t,e))];case"Atanh":return[n.atanh(S("x",s,t,e))];case"Ceil":return[n.ceil(S("x",s,t,e))];case"Complex":return[n.complex(S("real",s,t,e),S("imag",s,t,e))];case"Cos":return[n.cos(S("x",s,t,e))];case"Cosh":return[n.cosh(S("x",s,t,e))];case"Elu":return[n.elu(S("x",s,t,e))];case"Erf":return[n.erf(S("x",s,t,e))];case"Exp":return[n.exp(S("x",s,t,e))];case"Expm1":return[n.expm1(S("x",s,t,e))];case"Floor":return[n.floor(S("x",s,t,e))];case"Log":return[n.log(S("x",s,t,e))];case"Log1p":return[n.log1p(S("x",s,t,e))];case"Imag":return[n.imag(S("x",s,t,e))];case"Neg":return[n.neg(S("x",s,t,e))];case"Reciprocal":return[n.reciprocal(S("x",s,t,e))];case"Real":return[n.real(S("x",s,t,e))];case"Relu":return[n.relu(S("x",s,t,e))];case"Round":return[n.round(S("x",s,t,e))];case"Selu":return[n.selu(S("x",s,t,e))];case"Sigmoid":return[n.sigmoid(S("x",s,t,e))];case"Sin":return[n.sin(S("x",s,t,e))];case"Sign":return[n.sign(S("x",s,t,e))];case"Sinh":return[n.sinh(S("x",s,t,e))];case"Softplus":return[n.softplus(S("x",s,t,e))];case"Sqrt":return[n.sqrt(S("x",s,t,e))];case"Square":return[n.square(S("x",s,t,e))];case"Tanh":return[n.tanh(S("x",s,t,e))];case"Tan":return[n.tan(S("x",s,t,e))];case"ClipByValue":return[n.clipByValue(S("x",s,t,e),S("clipValueMin",s,t,e),S("clipValueMax",s,t,e))];case"Relu6":return[n.relu6(S("x",s,t,e))];case"Rsqrt":return[n.rsqrt(We(s.inputNames[0],t,e))];case"LeakyRelu":return[n.leakyRelu(S("x",s,t,e),S("alpha",s,t,e))];case"Prelu":return[n.prelu(S("x",s,t,e),S("alpha",s,t,e))];case"IsNan":return[n.isNaN(We(s.inputNames[0],t,e))];case"IsInf":return[n.isInf(We(s.inputNames[0],t,e))];case"IsFinite":return[n.isFinite(We(s.inputNames[0],t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function os(s,t,e=""){if(!(typeof s=="number"||typeof t=="number")){$(s.length===t.length,()=>e+` Shapes ${s} and ${t} must match`);for(let n=0;n<s.length;n++){const r=s[n],i=t[n];$(r<0||i<0||r===i,()=>e+` Shapes ${s} and ${t} must match`)}}}function rv(s){return!(typeof s=="number"||s.some(t=>t<0))}function Rl(s,t,e){let n=my(s,e);const r=!rv(n);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(r&&t.forEach(i=>{n=my(i.shape,n)}),!rv(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function my(s,t){if(typeof s=="number")return t;if(typeof t=="number")return s;if(s.length!==t.length)throw new Error(`Incompatible ranks during merge: ${s} vs. ${t}`);const e=[];for(let n=0;n<s.length;++n){const r=s[n],i=t[n];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${s} vs. ${t}`);e[n]=r>=0?r:i}return e}class cz{constructor(t,e,n,r,i,o,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=gt(0),Ie(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),os(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Ie(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,r)=>this.write(n,e[r]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return Yn([],[0].concat(this.elementShape));const n=this.readMany(t);return os(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Sn(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Yn([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const n=this.readMany(e);return os(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),pe(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,ts(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const r=t.map(l=>(n+=l,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=n===0?0:e.size/n,o=[];W(()=>{e=L(e,[1,n,i]);for(let l=0;l<t.length;++l){const u=[0,l===0?0:r[l-1],0],h=[1,t[l],i];o[l]=L(Ot(e,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}class ho{get id(){return this.idTensor.id}constructor(t,e,n,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t?.forEach(i=>{if(n!==i.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${i.dtype}`);os(e,i.shape,"TensorList shape mismatch: "),Ie(i)}),this.idTensor=gt(0),this.maxNumElements=r,Ie(this.idTensor)}copy(){return new ho([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);os(t,this.elementShape,"TensorList shape mismatch: ");const r=Rl(this.elementShape,this.tensors,t);return W(()=>{const i=this.tensors.map(o=>L(o,r));return Sn(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=Rl(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,os(r.shape,t,"TensorList shape mismatch: "),L(r,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(os(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ie(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new ho([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);os(this.tensors[t].shape,e,"TensorList shape mismatch: ");const r=Rl(this.elementShape,this.tensors,e);return L(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);os(this.elementShape,e.shape,"TensorList shape mismatch: "),Ie(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);os(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Rl(this.elementShape,this.tensors,n);return t.length===0?Yn([],[0].concat(r)):W(()=>{const i=t.map(o=>L(this.tensors[o],r));return Sn(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);os(this.elementShape,e,"TensorList shape mismatch: ");const n=Rl(this.elementShape,this.tensors,e);return this.size()===0?Yn([],[0].concat(n)):W(()=>{const r=this.tensors.map(i=>L(i,n));return pe(r,0)})}}function uz(s,t,e){const n=s.dtype;if(s.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${s.shape}`);if(s.dtype!==e)throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${e}`);const r=s.shape.slice(1);os(r,t,"TensorList shape mismatch: ");const i=ts(s);return new ho(i,t,n)}function hz(s,t,e,n){return new ho([],s,t,n)}function dz(s,t,e,n){if(t.length!==s.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${s.shape[0]}`);const r=Math.max(...t);if(n!=null&&n!==-1&&r>=n)throw new Error(`Max index must be < array size (${r}  vs. ${n})`);const i=new ho([],e,s.dtype,n),o=ts(s,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}function pz(s,t,e){let n=0;const r=t.map(u=>(n+=u,n));if(n!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${s.shape}`);const i=s.shape.slice(1),o=my(i,e),a=n===0?0:s.size/n,l=W(()=>{const u=[];s=L(s,[1,n,a]);for(let h=0;h<t.length;++h){const p=[0,h===0?0:r[h-1],0],f=[1,t[h],a];u[h]=L(Ot(s,p,f),o)}return s.dispose(),u}),c=new ho([],e,s.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}const fz=async(s,t,e)=>{switch(s.op){case"If":case"StatelessIf":{const n=S("thenBranch",s,t,e),r=S("elseBranch",s,t,e),i=S("cond",s,t,e),o=S("args",s,t,e);return(await i.data())[0]?e.functionMap[n].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap):e.functionMap[r].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{const n=S("body",s,t,e),r=S("cond",s,t,e),i=S("args",s,t,e),o=await e.functionMap[r].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap),a=i.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=i;for(;l[0];){const u=c;c=await e.functionMap[n].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);const h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await e.functionMap[r].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{const n=S("pred",s,t,e);return[mr(n)]}case"Switch":{const n=S("pred",s,t,e);let r=S("data",s,t,e);return r.kept||(r=mr(r)),(await n.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const n=s.inputNames.find(r=>We(r,t,e)!==void 0);if(n){const r=We(n,t,e);return[mr(r)]}return}case"Enter":{const n=S("frameName",s,t,e),r=S("tensor",s,t,e);return e.enterFrame(n),[mr(r)]}case"Exit":{const n=S("tensor",s,t,e);return e.exitFrame(),[mr(n)]}case"NextIteration":{const n=S("tensor",s,t,e);return e.nextIteration(),[mr(n)]}case"TensorArrayV3":{const n=S("size",s,t,e),r=S("dtype",s,t,e),i=S("elementShape",s,t,e),o=S("dynamicSize",s,t,e),a=S("clearAfterRead",s,t,e),l=S("identicalElementShapes",s,t,e),c=S("name",s,t,e),u=new cz(c,r,n,i,l,o,a);return e.addTensorArray(u),[u.idTensor,gt(1)]}case"TensorArrayWriteV3":{const n=S("tensorArrayId",s,t,e),r=S("index",s,t,e),i=S("tensor",s,t,e),o=e.getTensorArray(n.id);return o.write(r,i),[o.idTensor]}case"TensorArrayReadV3":{const n=S("tensorArrayId",s,t,e),r=S("index",s,t,e);return[e.getTensorArray(n.id).read(r)]}case"TensorArrayGatherV3":{const n=S("tensorArrayId",s,t,e),r=S("indices",s,t,e),i=S("dtype",s,t,e);return[e.getTensorArray(n.id).gather(r,i)]}case"TensorArrayScatterV3":{const n=S("tensorArrayId",s,t,e),r=S("indices",s,t,e),i=S("tensor",s,t,e),o=e.getTensorArray(n.id);return o.scatter(r,i),[o.idTensor]}case"TensorArrayConcatV3":{const n=S("tensorArrayId",s,t,e),r=e.getTensorArray(n.id),i=S("dtype",s,t,e);return[r.concat(i)]}case"TensorArraySplitV3":{const n=S("tensorArrayId",s,t,e),r=S("tensor",s,t,e),i=S("lengths",s,t,e),o=e.getTensorArray(n.id);return o.split(i,r),[o.idTensor]}case"TensorArraySizeV3":{const n=S("tensorArrayId",s,t,e),r=e.getTensorArray(n.id);return[gt(r.size(),"int32")]}case"TensorArrayCloseV3":{const n=S("tensorArrayId",s,t,e),r=e.getTensorArray(n.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const n=S("tensorListId",s,t,e),r=S("index",s,t,e),i=S("tensor",s,t,e),o=e.getTensorList(n.id);return o.setItem(r,i),[o.idTensor]}case"TensorListGetItem":{const n=S("tensorListId",s,t,e),r=S("index",s,t,e),i=S("elementShape",s,t,e),o=S("elementDType",s,t,e);return[e.getTensorList(n.id).getItem(r,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=S("indices",s,t,e),r=S("tensor",s,t,e),i=S("elementShape",s,t,e),o=S("numElements",s,t,e),a=dz(r,n,i,o);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=S("elementShape",s,t,e),r=S("elementDType",s,t,e);let i;s.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=S(i,s,t,e),a=s.op==="TensorListReserve"?-1:o,l=hz(n,r,o,a);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{const n=S("tensorListId",s,t,e),r=S("indices",s,t,e),i=S("elementShape",s,t,e),o=S("elementDType",s,t,e);return[e.getTensorList(n.id).gather(r,o,i)]}case"TensorListStack":{const n=S("tensorListId",s,t,e),r=S("elementShape",s,t,e),i=S("elementDType",s,t,e),o=S("numElements",s,t,e);return[e.getTensorList(n.id).stack(r,i,o)]}case"TensorListFromTensor":{const n=S("tensor",s,t,e),r=S("elementShape",s,t,e),i=S("elementDType",s,t,e),o=uz(n,r,i);return e.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=S("tensorListId",s,t,e),r=e.getTensorList(n.id),i=S("dtype",s,t,e),o=S("elementShape",s,t,e);return[r.concat(i,o)]}case"TensorListPushBack":{const n=S("tensorListId",s,t,e),r=S("tensor",s,t,e),i=e.getTensorList(n.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const n=S("tensorListId",s,t,e),r=S("elementShape",s,t,e),i=S("elementDType",s,t,e);return[e.getTensorList(n.id).popBack(r,i)]}case"TensorListSplit":{const n=S("tensor",s,t,e),r=S("elementShape",s,t,e),i=S("lengths",s,t,e),o=pz(n,i,r);return e.addTensorList(o),[o.idTensor]}case"TensorListLength":{const n=S("tensorListId",s,t,e),r=e.getTensorList(n.id);return[gt(r.size(),"int32")]}case"TensorListResize":{const n=S("tensorListId",s,t,e),r=S("size",s,t,e),o=e.getTensorList(n.id).resize(r);return e.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};function iv(s,t,e){const[n,r]=S("fusedOps",s,t,e),i=n==="biasadd",o=!i,a=r==="prelu",l=n==="fusedbatchnorm",c=S("numArgs",s,t,e);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=S("strides",s,t,e),h=vd(s,t,e),d=S("dataFormat",s,t,e).toUpperCase(),p=S("dilations",s,t,e);let[f,m]=S("args",s,t,e);o&&(m=f,f=void 0);const g=S("leakyreluAlpha",s,t,e);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const mz=(s,t,e,n=Ke)=>{switch(s.op){case"Conv1D":{const r=S("stride",s,t,e),i=S("pad",s,t,e),o=S("dataFormat",s,t,e).toUpperCase(),a=S("dilation",s,t,e);return[n.conv1d(S("x",s,t,e),S("filter",s,t,e),r,i,o,a)]}case"Conv2D":{const r=S("strides",s,t,e),i=vd(s,t,e),o=S("dataFormat",s,t,e).toUpperCase(),a=S("dilations",s,t,e);return[n.conv2d(S("x",s,t,e),S("filter",s,t,e),[r[1],r[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=iv(s,t,e);return[n.fused.conv2d({x:S("x",s,t,e),filter:S("filter",s,t,e),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=iv(s,t,e);return[n.fused.depthwiseConv2d({x:S("x",s,t,e),filter:S("filter",s,t,e),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=S("outputShape",s,t,e),i=S("strides",s,t,e),o=vd(s,t,e);return[n.conv2dTranspose(S("x",s,t,e),S("filter",s,t,e),r,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=S("strides",s,t,e),i=vd(s,t,e),o=S("dilations",s,t,e),a=S("dataFormat",s,t,e).toUpperCase();return[n.depthwiseConv2d(S("input",s,t,e),S("filter",s,t,e),[r[1],r[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("dataFormat",s,t,e).toUpperCase(),a=S("dilations",s,t,e);return[n.conv3d(S("x",s,t,e),S("filter",s,t,e),[r[1],r[2],r[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("kernelSize",s,t,e);return[n.avgPool(S("x",s,t,e),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("kernelSize",s,t,e);return[n.maxPool(S("x",s,t,e),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("kernelSize",s,t,e),a=S("includeBatchInIndex",s,t,e),{result:l,indexes:c}=n.maxPoolWithArgmax(S("x",s,t,e),[o[1],o[2]],[r[1],r[2]],i,a);return[l,c]}case"AvgPool3D":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("kernelSize",s,t,e);return[n.avgPool3d(S("x",s,t,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("kernelSize",s,t,e);return[n.maxPool3d(S("x",s,t,e),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=S("strides",s,t,e),i=S("pad",s,t,e),o=S("dilations",s,t,e),a=r[1],l=r[2],c=o[1],u=o[2];return[n.dilation2d(S("x",s,t,e),S("filter",s,t,e),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const gz=(s,t,e,n=Ke)=>{switch(s.op){case"Fill":{const r=S("shape",s,t,e),i=S("dtype",s,t,e),o=S("value",s,t,e);return[n.fill(r,o,i)]}case"LinSpace":{const r=S("start",s,t,e),i=S("stop",s,t,e),o=S("num",s,t,e);return[n.linspace(r,i,o)]}case"Multinomial":{const r=S("logits",s,t,e),i=S("numSamples",s,t,e),o=S("seed",s,t,e);return[n.multinomial(r,i,o)]}case"OneHot":{const r=S("indices",s,t,e),i=S("depth",s,t,e),o=S("onValue",s,t,e),a=S("offValue",s,t,e),l=S("dtype",s,t,e);return[n.oneHot(r,i,o,a,l)]}case"Ones":return[n.ones(S("shape",s,t,e),S("dtype",s,t,e))];case"OnesLike":return[n.onesLike(S("x",s,t,e))];case"RandomStandardNormal":return[n.randomStandardNormal(S("shape",s,t,e),S("dtype",s,t,e),S("seed",s,t,e))];case"RandomUniform":return[n.randomUniform(S("shape",s,t,e),S("minval",s,t,e),S("maxval",s,t,e),S("dtype",s,t,e))];case"RandomUniformInt":return[n.randomUniformInt(S("shape",s,t,e),S("minval",s,t,e),S("maxval",s,t,e),S("seed",s,t,e))];case"Range":{const r=S("start",s,t,e),i=S("stop",s,t,e),o=S("step",s,t,e);return[n.range(r,i,o,S("dtype",s,t,e))]}case"TruncatedNormal":{const r=S("shape",s,t,e),i=S("mean",s,t,e),o=S("stdDev",s,t,e),a=S("seed",s,t,e);return[n.truncatedNormal(r,i,o,S("dtype",s,t,e),a)]}case"Zeros":return[n.zeros(S("shape",s,t,e),S("dtype",s,t,e))];case"ZerosLike":return[n.zerosLike(S("x",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function lg(s,t,e){const n=S("boxes",s,t,e),r=S("scores",s,t,e),i=S("maxOutputSize",s,t,e),o=S("iouThreshold",s,t,e),a=S("scoreThreshold",s,t,e),l=S("softNmsSigma",s,t,e);return{boxes:n,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const yz=async(s,t,e,n,r=Ke)=>{switch(s.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=lg(s,t,e),h=await r.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=lg(s,t,e),u=S("padToMaxOutputSize",s,t,e),h=await r.image.nonMaxSuppressionPaddedAsync(i,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=lg(s,t,e);return[await r.image.nonMaxSuppressionAsync(i,o,a,l,c)]}case"Where":{const i=r.cast(S("condition",s,t,e),"bool"),o=[await r.whereAsync(i)];return i.dispose(),o}case"ListDiff":return r.setdiff1dAsync(S("x",s,t,e),S("y",s,t,e));default:throw TypeError(`Node type ${s.op} is not implemented`)}};const bz=(s,t,e,n=Ke)=>{switch(s.op){case"LowerBound":{const r=S("sortedSequence",s,t,e),i=S("values",s,t,e);return[n.lowerBound(r,i)]}case"TopKV2":{const r=S("x",s,t,e),i=S("k",s,t,e),o=S("sorted",s,t,e),a=n.topk(r,i,o);return[a.values,a.indices]}case"UpperBound":{const r=S("sortedSequence",s,t,e),i=S("values",s,t,e);return[n.upperBound(r,i)]}case"Unique":{const r=S("x",s,t,e),i=n.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=S("x",s,t,e),i=S("axis",s,t,e),o=n.unique(r,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const xz=(s,t,e,n=Ke)=>{switch(s.op){case"Const":return t[s.name];case"PlaceholderWithDefault":const r=S("default",s,t,e);return[We(s.name,t,e)||r];case"Placeholder":return[We(s.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=S("x",s,t,e);return[mr(u)]}case"IdentityN":return S("x",s,t,e).map(u=>mr(u));case"Snapshot":const i=S("x",s,t,e);return[mr(i)];case"Shape":return[n.tensor1d(S("x",s,t,e).shape,"int32")];case"ShapeN":return S("x",s,t,e).map(u=>n.tensor1d(u.shape));case"Size":return[n.scalar(S("x",s,t,e).size,"int32")];case"Rank":return[n.scalar(S("x",s,t,e).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const o=S("x",s,t,e),a=S("data",s,t,e),l=S("message",s,t,e),c=S("summarize",s,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${s.op} is not implemented`)}};class wz{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=gt(0),this.tensorMap=new Map,Ie(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return gt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),W(()=>{const r=ts(e),i=n.length,o=r.length;$(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=n[a],c=r[a];Ie(c),this.tensorMap.set(l,c)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const n=await t.data();return W(()=>{const r=[];for(let i=0;i<n.length;i++){const o=n[i],a=this.findWithDefault(o,e);r.push(a)}return Sn(r)})}findWithDefault(t,e){const n=this.tensorMap.get(t);return n??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const vz=async(s,t,e,n)=>{switch(s.op){case"HashTable":case"HashTableV2":{const r=n.getHashTableHandleByName(s.name);if(r!=null)return[r];{const i=S("keyDType",s,t,e),o=S("valueDType",s,t,e),a=new wz(i,o);return n.addHashTable(s.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=S("tableHandle",s,t,e,n),i=S("keys",s,t,e),o=S("values",s,t,e);return[await n.getHashTableById(r.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=S("tableHandle",s,t,e,n),i=S("keys",s,t,e),o=S("defaultValue",s,t,e);return[await n.getHashTableById(r.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=S("tableHandle",s,t,e,n);return[n.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Sz=(s,t,e,n=Ke)=>{switch(s.op){case"ResizeBilinear":{const r=S("images",s,t,e),i=S("size",s,t,e),o=S("alignCorners",s,t,e),a=S("halfPixelCenters",s,t,e);return[n.image.resizeBilinear(r,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const r=S("images",s,t,e),i=S("size",s,t,e),o=S("alignCorners",s,t,e),a=S("halfPixelCenters",s,t,e);return[n.image.resizeNearestNeighbor(r,[i[0],i[1]],o,a)]}case"CropAndResize":{const r=S("image",s,t,e),i=S("boxes",s,t,e),o=S("boxInd",s,t,e),a=S("cropSize",s,t,e),l=S("method",s,t,e),c=S("extrapolationValue",s,t,e);return[n.image.cropAndResize(r,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const r=S("images",s,t,e),i=S("transforms",s,t,e),o=S("outputShape",s,t,e),a=S("fillValue",s,t,e),l=S("interpolation",s,t,e),c=S("fillMode",s,t,e);return[n.image.transform(r,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Cz=(s,t,e,n=Ke)=>{switch(s.op){case"Equal":return[n.equal(S("a",s,t,e),S("b",s,t,e))];case"NotEqual":return[n.notEqual(S("a",s,t,e),S("b",s,t,e))];case"Greater":return[n.greater(S("a",s,t,e),S("b",s,t,e))];case"GreaterEqual":return[n.greaterEqual(S("a",s,t,e),S("b",s,t,e))];case"Less":return[n.less(S("a",s,t,e),S("b",s,t,e))];case"LessEqual":return[n.lessEqual(S("a",s,t,e),S("b",s,t,e))];case"LogicalAnd":return[n.logicalAnd(S("a",s,t,e),S("b",s,t,e))];case"LogicalNot":return[n.logicalNot(S("a",s,t,e))];case"LogicalOr":return[n.logicalOr(S("a",s,t,e),S("b",s,t,e))];case"Select":case"SelectV2":return[n.where(S("condition",s,t,e),S("a",s,t,e),S("b",s,t,e))];case"BitwiseAnd":return[n.bitwiseAnd(S("a",s,t,e),S("b",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Tz=(s,t,e,n=Ke)=>{switch(s.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(S("a",s,t,e),S("b",s,t,e),S("transposeA",s,t,e),S("transposeB",s,t,e))];case"Einsum":return[n.einsum(S("equation",s,t,e),...S("tensors",s,t,e))];case"Transpose":return[n.transpose(S("x",s,t,e),S("perm",s,t,e))];case"_FusedMatMul":const[r,i]=S("fusedOps",s,t,e),o=r==="biasadd",a=i==="prelu",l=S("numArgs",s,t,e),c=S("leakyreluAlpha",s,t,e);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=S("args",s,t,e);return[n.fused.matMul({a:S("a",s,t,e),b:S("b",s,t,e),transposeA:S("transposeA",s,t,e),transposeB:S("transposeB",s,t,e),bias:u,activation:i,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[n.linalg.bandPart(S("a",s,t,e),S("numLower",s,t,e),S("numUpper",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const kz=(s,t,e,n=Ke)=>{switch(s.op){case"EuclideanNorm":return[n.euclideanNorm(S("x",s,t,e),S("axis",s,t,e),S("keepDims",s,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(S("x",s,t,e),S("mean",s,t,e),S("variance",s,t,e),S("offset",s,t,e),S("scale",s,t,e),S("epsilon",s,t,e))];case"FusedBatchNormV3":return[n.batchNorm(S("x",s,t,e),S("mean",s,t,e),S("variance",s,t,e),S("offset",s,t,e),S("scale",s,t,e),S("epsilon",s,t,e))];case"LRN":return[n.localResponseNormalization(S("x",s,t,e),S("radius",s,t,e),S("bias",s,t,e),S("alpha",s,t,e),S("beta",s,t,e))];case"Softmax":return[n.softmax(S("x",s,t,e))];case"LogSoftmax":return[n.logSoftmax(S("x",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Iz=(s,t,e,n=Ke)=>{switch(s.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=n.raggedGather(S("paramsNestedSplits",s,t,e),S("paramsDenseValues",s,t,e),S("indices",s,t,e),S("outputRaggedRank",s,t,e));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=n.raggedRange(S("starts",s,t,e),S("limits",s,t,e),S("splits",s,t,e));return[r,i]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(S("shape",s,t,e),S("values",s,t,e),S("defaultValue",s,t,e),S("rowPartitionTensors",s,t,e),S("rowPartitionTypes",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Nz=(s,t,e,n=Ke)=>{switch(s.op){case"Max":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.max(S("x",s,t,e),a,l)]}case"Mean":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.mean(S("x",s,t,e),a,l)]}case"Min":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.min(S("x",s,t,e),a,l)]}case"Sum":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.sum(S("x",s,t,e),a,l)]}case"All":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.all(S("x",s,t,e),a,l)]}case"Any":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.any(S("x",s,t,e),a,l)]}case"ArgMax":{const a=S("axis",s,t,e);return[n.argMax(S("x",s,t,e),a)]}case"ArgMin":{const a=S("axis",s,t,e);return[n.argMin(S("x",s,t,e),a)]}case"Prod":{const a=S("axis",s,t,e),l=S("keepDims",s,t,e);return[n.prod(S("x",s,t,e),a,l)]}case"Cumprod":{const a=S("axis",s,t,e),l=S("exclusive",s,t,e),c=S("reverse",s,t,e);return[n.cumprod(S("x",s,t,e),a,l,c)]}case"Cumsum":{const a=S("axis",s,t,e),l=S("exclusive",s,t,e),c=S("reverse",s,t,e);return[n.cumsum(S("x",s,t,e),a,l,c)]}case"Bincount":const r=S("x",s,t,e),i=S("weights",s,t,e),o=S("size",s,t,e);return[n.bincount(r,i,o)];case"DenseBincount":{const a=S("x",s,t,e),l=S("weights",s,t,e),c=S("size",s,t,e),u=S("binaryOutput",s,t,e);return[n.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const $z=(s,t,e,n=Ke)=>{switch(s.op){case"ConcatV2":case"Concat":{const r=S("n",s,t,e),i=S("axis",s,t,e);let o=S("tensors",s,t,e);return o=o.slice(0,r),[n.concat(o,i)]}case"Gather":{const r=S("x",s,t,e),i=S("indices",s,t,e);return[n.gather(r,n.cast(i,"int32"),0)]}case"GatherV2":{const r=S("axis",s,t,e),i=S("batchDims",s,t,e),o=S("x",s,t,e),a=S("indices",s,t,e);return[n.gather(o,n.cast(a,"int32"),r,i)]}case"Reverse":{const r=S("dims",s,t,e),i=[];for(let a=0;a<r.length;a++)r[a]&&i.push(a);const o=S("x",s,t,e);return[n.reverse(o,i)]}case"ReverseV2":{const r=S("axis",s,t,e),i=S("x",s,t,e);return[n.reverse(i,r)]}case"Slice":{const r=S("begin",s,t,e),i=S("size",s,t,e);return[n.slice(S("x",s,t,e),r,i)]}case"StridedSlice":{const r=S("begin",s,t,e),i=S("end",s,t,e),o=S("strides",s,t,e),a=S("beginMask",s,t,e),l=S("endMask",s,t,e),c=S("ellipsisMask",s,t,e),u=S("newAxisMask",s,t,e),h=S("shrinkAxisMask",s,t,e),d=S("x",s,t,e);return[n.stridedSlice(d,r,i,o,a,l,c,u,h)]}case"Pack":return W(()=>{const r=S("axis",s,t,e),i=S("tensors",s,t,e),o=i[0].shape,a=n.squeeze(i[0]).shape,l=i.map(c=>{const u=Dt(c.shape,o);if(!u&&!Dt(n.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:n.reshape(c,o)});return[n.stack(l,r)]});case"Unpack":{const r=S("axis",s,t,e),i=S("tensor",s,t,e);return n.unstack(i,r)}case"Tile":{const r=S("reps",s,t,e);return[n.tile(S("x",s,t,e),r)]}case"Split":case"SplitV":{const r=S("axis",s,t,e),i=S("numOrSizeSplits",s,t,e),o=S("x",s,t,e);return n.split(o,i,r)}case"ScatterNd":{const r=S("indices",s,t,e),i=S("values",s,t,e),o=S("shape",s,t,e);return[n.scatterND(r,i,o)]}case"GatherNd":{const r=S("x",s,t,e),i=S("indices",s,t,e);return[n.gatherND(r,i)]}case"SparseToDense":{const r=S("sparseIndices",s,t,e),i=S("outputShape",s,t,e),o=S("sparseValues",s,t,e),a=S("defaultValue",s,t,e);return[n.sparseToDense(r,o,i,o.dtype===a.dtype?a:n.cast(a,o.dtype))]}case"TensorScatterUpdate":{const r=S("indices",s,t,e),i=S("values",s,t,e),o=S("tensor",s,t,e);return[n.tensorScatterUpdate(o,r,i)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const _z=(s,t,e,n=Ke)=>{switch(s.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=n.sparse.sparseFillEmptyRows(S("indices",s,t,e),S("values",s,t,e),S("denseShape",s,t,e),S("defaultValue",s,t,e));return[r,i,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=n.sparse.sparseReshape(S("inputIndices",s,t,e),S("inputShape",s,t,e),S("newShape",s,t,e));return[r,i]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(S("data",s,t,e),S("indices",s,t,e),S("segmentIds",s,t,e))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(S("data",s,t,e),S("indices",s,t,e),S("segmentIds",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Ez=(s,t,e,n=Ke)=>{switch(s.op){case"FFT":return[n.fft(S("x",s,t,e))];case"IFFT":return[n.ifft(S("x",s,t,e))];case"RFFT":return[n.rfft(S("x",s,t,e))];case"IRFFT":return[n.irfft(S("x",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Dz=(s,t,e,n=Ke)=>{switch(s.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(S("input",s,t,e),S("pattern",s,t,e),S("rewrite",s,t,e),S("replaceGlobal",s,t,e))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=n.string.stringNGrams(S("data",s,t,e),S("dataSplits",s,t,e),S("separator",s,t,e),S("nGramWidths",s,t,e),S("leftPad",s,t,e),S("rightPad",s,t,e),S("padWidth",s,t,e),S("preserveShortSequences",s,t,e));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:o}=n.string.stringSplit(S("input",s,t,e),S("delimiter",s,t,e),S("skipEmpty",s,t,e));return[r,i,o]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(S("input",s,t,e),S("numBuckets",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Az=(s,t,e,n=Ke)=>{switch(s.op){case"Cast":return[n.cast(S("x",s,t,e),S("dtype",s,t,e))];case"ExpandDims":{const r=S("axis",s,t,e);return[n.expandDims(S("x",s,t,e),r)]}case"Squeeze":{const r=S("axis",s,t,e);return[n.squeeze(S("x",s,t,e),r)]}case"Reshape":return[n.reshape(S("x",s,t,e),S("shape",s,t,e))];case"EnsureShape":return[n.ensureShape(S("x",s,t,e),S("shape",s,t,e))];case"MirrorPad":return[n.mirrorPad(S("x",s,t,e),S("padding",s,t,e),S("mode",s,t,e))];case"PadV2":case"Pad":return[n.pad(S("x",s,t,e),S("padding",s,t,e),S("constantValue",s,t,e))];case"SpaceToBatchND":{const r=S("blockShape",s,t,e),i=S("paddings",s,t,e);return[n.spaceToBatchND(S("x",s,t,e),r,i)]}case"BatchToSpaceND":{const r=S("blockShape",s,t,e),i=S("crops",s,t,e);return[n.batchToSpaceND(S("x",s,t,e),r,i)]}case"DepthToSpace":{const r=S("blockSize",s,t,e),i=S("dataFormat",s,t,e).toUpperCase();return[n.depthToSpace(S("x",s,t,e),r,i)]}case"BroadcastTo":return[n.broadcastTo(S("x",s,t,e),S("shape",s,t,e))];case"BroadcastArgs":return[n.broadcastArgs(S("s0",s,t,e),S("s1",s,t,e))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function ov(s,t,e,n,r=W){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return r(()=>az(o,a,l));case"basic_math":return r(()=>lz(o,a,l));case"control":return fz(o,a,l);case"convolution":return r(()=>mz(o,a,l));case"creation":return r(()=>gz(o,a,l));case"dynamic":return yz(o,a,l);case"evaluation":return r(()=>bz(o,a,l));case"image":return r(()=>Sz(o,a,l));case"graph":return r(()=>xz(o,a,l));case"logical":return r(()=>Cz(o,a,l));case"matrices":return r(()=>Tz(o,a,l));case"normalization":return r(()=>kz(o,a,l));case"ragged":return r(()=>Iz(o,a,l));case"reduction":return r(()=>Nz(o,a,l));case"slice_join":return r(()=>$z(o,a,l));case"sparse":return r(()=>_z(o,a,l));case"spectral":return r(()=>Ez(o,a,l));case"string":return r(()=>Dz(o,a,l));case"transformation":return r(()=>Az(o,a,l));case"hash_table":return vz(o,a,l,n);case"custom":const c=gk(o.op);if(c&&c.customExecutor)return c.customExecutor(new oz(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(s,t,e);return li(i)?i.then(o=>[].concat(o)):[].concat(i)}class av{constructor(t={},e={},n={},r={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function lv(s,t,e,n){const r=new Set,i=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(s).map(d=>In(d)[0]));n=n||[];const u=new Set(n.map(d=>In(d.name)[0])),h=[...t];for(;h.length>0;){const d=h.pop();if((Vi(d)||zz(d)||Vz(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),e[d.name]==null&&!c.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:s,outputs:t,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:a}}function Oz(s,t){const{usedNodes:e,inputs:n}=t,r=Object.keys(n).map(g=>In(g)[0]).map(g=>s.nodes[g]),i=s.initNodes||[],o=g=>e.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...r,...s.weights,...i]).filter(o),c=a([...l,...Object.values(s.nodes)]).filter(o),u=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)o(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const d=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),p=[...d];for(;d.length>0;){const g=d.pop(),y=u.get(g);for(const b of y.children.filter(o))--h[b.name]===0&&(p.push(b.name),d.push(b.name))}const f=p.map(g=>u.get(g)),m=Rz(f,l);return Fz(m,l),m}function Rz(s,t){const e=new Map(s.map(o=>[o.name,o])),n=t.map(o=>o.name),r=new Set(n);for(;n.length>0;){const o=n.pop(),a=e.get(o);for(const l of a.children)!e.has(l.name)||r.has(l.name)||(r.add(l.name),n.push(l.name))}return s.filter(o=>r.has(o.name))}class zh extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function Fz(s,t){const e=new Map(s.map((a,l)=>[a.name,l])),n=new Set(t.map(a=>a.name)),r=a=>n.has(typeof a=="string"?a:a.name),i=new Set(s.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of s){for(const l of a.children.filter(o)){if(!e.has(l.name))throw new zh(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new zh(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!r(a))for(const l of a.inputs){if(!e.has(l.name))throw new zh(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new zh(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function Pz(s){const t=new Map(s.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,n=s.map((a,l)=>Vi(a)?e:l),r=a=>{const l=n[t.get(a.name)];return l??-1},i=s.map((a,l)=>a.children.map(r).reduce((c,u)=>Math.max(c,u),n[l])),o=new Map;for(let a=0;a<s.length;++a){const l=i[a];if(l===e)continue;const c=s[a],u=s[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const Lz=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Mz=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Bz=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Vi(s){return Lz.has(s.op)}function zz(s){return Mz.has(s.op)}function Vz(s){return Bz.has(s.op)}class Gd{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(n=>t[n].map(r=>r.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Gd(t.functions[n],this)})}getCompilationKey(t,e){const n=t.map(i=>i.name).sort(),r=e.map(i=>i.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,e){const n=lv(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=n;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const c=e.map(h=>h.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${r}]`)}const a=Oz(this.graph,n),l=Pz(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;const e=t.clone();return Ie(e),e}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,this.cloneTensorList(n)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=n.map(d=>this.graph.nodes[In(d)[0]]),i=e.map(d=>In(d)[0]),o=new Set(i);let a=i.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(r,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(t,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const u={},h={};return W(()=>{const d=new av(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{const[b,w]=In(y,d),x=[];x[w]=t[y],p[b]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(x))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(const y of m){if(p[y.name])continue;const b=ov(y,p,d,this._resourceManager);if(li(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,d,f,o,g.get(y.name))}return this.parent==null&&d.dispose(f),e.map(y=>We(y,p,d))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(r=>r.id)));return new Set(e)}checkTensorForDisposal(t,e,n,r,i,o,a){if(!(Vi(e)||o.has(t))){for(const l of n[t])l!=null&&(a[l.id]=(a[l.id]||0)+e.children.length);for(const l of e.inputs){if(Vi(l))continue;const c=ev(l.name,n,r);if(c!=null)for(const u of c){if(!u||u.kept||i.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,n,r,i,o){function a(l){return Vi(l)||i.has(l.name)}if(!(Vi(t)||o==null))for(const l of o){if(a(l))continue;const c=ev(l.name,e,n);for(const u of c)!u||u.kept||r.has(u.id)||u.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,n=!1,r={},i={}){this.disposeIntermediateTensors(),n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new av(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(t,o,e,n),l=e.map(d=>We(d,a,o)),c=l.map(d=>d.id),u=Object.keys(t).map(d=>t[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(t,e,n){const r=t.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(r,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,r){const i=Object.keys(t),o=i.map(x=>this.graph.nodes[In(x)[0]]),a=n.map(x=>In(x)[0]),l=new Set(a);let c=a.map(x=>this.graph.nodes[x]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:d,syncInputs:p}=lv(t,c,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:e.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(x=>{const[v,C]=In(x),k=[];k[C]=t[x],m[v]=k});const g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){const x=this.processStack(o,f,e,m,b,y,l,g,u);await Promise.all(x)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=c.filter(x=>!Vi(x)&&!We(x.name,m,e)).map(x=>x.name);if(w.length>0){let x="";throw d!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${x}`)}return m}processStack(t,e,n,r,i,o,a,l,c){const u=[];for(;e.length>0;){const h=e.pop();n.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&S("isConstant",h.node,r,n)&&([d]=fr(h.node.name,n)),r[h.node.name]==null){const p=ov(h.node,r,n,this._resourceManager);d||([d]=fr(h.node.name,n));const f=n.currentContext;li(p)?u.push(p.then(m=>(r[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),n.currentContext=f,this.checkTensorForDisposal(d,h.node,r,n,o,a,l),this.processChildNodes(h.node,e,n,r,i,c),m))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,n,o,a,l),this.processChildNodes(h.node,e,n,r,i,c))}else this.processChildNodes(h.node,e,n,r,i,c)}return u}processChildNodes(t,e,n,r,i,o){t.children.forEach(a=>{const[l]=fr(a.name,n);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!We(c,r,n))&&(i[l]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(c=>!!We(c,r,n))&&(i[l]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const n=t[e],[r]=In(e),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===n.shape.length&&n.shape.every((l,c)=>o[c]===-1||o[c]===l);$(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${n.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&$(n.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){var e,n;const r={};for(const i in t){const o=(n=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||n===void 0?void 0:n[i];o!=null?r[o.name]=t[i]:r[i]=t[i]}return r}checkInputs(t){const e=Object.keys(t).filter(n=>{const[r]=In(n);return this.graph.nodes[r]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var n,r;const i=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[e];return i!=null?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[n]=In(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}}class Wz{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const Uz="?tfjs-format=file",Gz="model.json";class jz{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},n=$b){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=n,e==null&&(this.loadOptions={}),this.resourceManager=new Wz}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return li(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const e=await uC(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new Gd(nv.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const i=nv.Instance.transformGraph(t.modelInitializer);this.initializer=new Gd(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){const n=this.io.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof Lt?[t]:t,n={};return e.forEach((r,i)=>n[this.structuredOutputKeys[i]]=r),n}return t}predict(t,e){const n=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(t,e){const n=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(t){var e;if(!(t instanceof Lt)&&!Array.isArray(t)){const i=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const n=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?i[o]=this.resourceIdToCapturedInput[u]:i[o]=t[r++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,n=Object.keys(e);for(let r=0;r<n.length;r++){const i=n[r],o=e[i];this.resourceIdToCapturedInput[o.resourceId]=t[r]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Nt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function xk(s,t={},e=$b){if(s==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof s=="string"&&(s=Hz(s));const n=new jz(s,t,e);return await n.load(),n}function Hz(s){return s.endsWith("/")||(s=s+"/"),`${s}${Gz}${Uz}`}var gy=function(s,t){return gy=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var r in n)n.hasOwnProperty(r)&&(e[r]=n[r])},gy(s,t)};function wk(s,t){gy(s,t);function e(){this.constructor=s}s.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var Ls=function(){return Ls=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++){e=arguments[n];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])}return t},Ls.apply(this,arguments)};function js(s,t,e,n){function r(i){return i instanceof e?i:new e(function(o){o(i)})}return new(e||(e=Promise))(function(i,o){function a(u){try{c(n.next(u))}catch(h){o(h)}}function l(u){try{c(n.throw(u))}catch(h){o(h)}}function c(u){u.done?i(u.value):r(u.value).then(a,l)}c((n=n.apply(s,[])).next())})}function Hs(s,t){var e={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},n,r,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(n)throw new TypeError("Generator is already executing.");for(;e;)try{if(n=1,r&&(i=c[0]&2?r.return:c[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,c[1])).done)return i;switch(r=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return e.label++,{value:c[1],done:!1};case 5:e.label++,r=c[1],c=[0];continue;case 7:c=e.ops.pop(),e.trys.pop();continue;default:if(i=e.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){e=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){e.label=c[1];break}if(c[0]===6&&e.label<i[1]){e.label=i[1],i=c;break}if(i&&e.label<i[2]){e.label=i[2],e.ops.push(c);break}i[2]&&e.ops.pop(),e.trys.pop();continue}c=t.call(s,e)}catch(u){c=[6,u],r=0}finally{n=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}function vk(s){var t=s.shape[2],e=ui(s,2),n=L(e,[-1]);return co(n,t)}function Xz(s,t){return F(s,t)}function Vh(s,t){return W(function(){return rt(un(s,gt(t)),"int32")})}function qz(s,t){var e=t.shape,n=e[0],r=e[1],i=e[2];return W(function(){var o=vk(t),a=we(Dr(0,i,1,"int32"),1),l=rt(Ct(o,a),"int32"),c=L(l,[n,r]),u=tt(c,gt(1,"int32"));return ct(Xz(u,s),gt(1,"int32"))})}function Kz(s){var t=s.shape,e=t[0],n=t[1],r=t[2];return W(function(){var i=vk(s),o=we(Dr(0,r,1,"int32"),1),a=rt(Ct(i,o),"int32");return L(a,[e,n])})}var Sk=(function(){function s(t,e){this.model=t,this.outputStride=e;var n=this.model.inputs[0].shape;$(n[1]===-1&&n[2]===-1,function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"})}return s.prototype.predict=function(t){var e=this;return W(function(){var n=e.preprocessInput(rt(t,"float32")),r=we(n,0),i=e.model.predict(r),o=i.map(function(l){return En(l,[0])}),a=e.nameOutputResults(o);return{heatmapScores:Zn(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd,segmentation:a.segmentation,partHeatmaps:a.partHeatmaps,longOffsets:a.longOffsets,partOffsets:a.partOffsets}})},s.prototype.dispose=function(){this.model.dispose()},s})();var Yz=(function(s){wk(t,s);function t(){return s!==null&&s.apply(this,arguments)||this}return t.prototype.preprocessInput=function(e){return W(function(){return ct(ft(e,127.5),1)})},t.prototype.nameOutputResults=function(e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7];return{offsets:n,segmentation:r,partHeatmaps:i,longOffsets:o,heatmap:a,displacementFwd:l,displacementBwd:c,partOffsets:u}},t})(Sk);var vm=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Cs=vm.length,jd=vm.reduce(function(s,t,e){return s[t]=e,s},{}),Zz=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]],Jz=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]];Zz.map(function(s){var t=s[0],e=s[1];return[jd[t],jd[e]]});function ex(s,t,e){var n=s[0],r=s[1],i=t[0],o=t[1],a=e.top,l=e.bottom,c=e.left,u=e.right,h=i/(a+l+n),d=o/(c+u+r);return[d,h]}function Ck(s,t,e,n){return{y:n.get(s,t,e),x:n.get(s,t,e+Cs)}}function Tk(s,t,e){var n=s.heatmapY,r=s.heatmapX,i=s.id,o=Ck(n,r,i,e),a=o.y,l=o.x;return{x:s.heatmapX*t+l,y:s.heatmapY*t+a}}function cv(s,t,e){return s<t?t:s>e?e:s}function Qz(s,t,e,n){var r=e-s,i=n-t;return r*r+i*i}function uv(s,t){return{x:s.x+t.x,y:s.y+t.y}}function tV(s,t,e){e===void 0&&(e=.3);for(var n=0,r=0,i=0;i<s.length;i++)t.keypoints[i].score>e&&(r+=1,n+=Math.pow(s[i].x-t.keypoints[i].position.x,2)+Math.pow(s[i].y-t.keypoints[i].position.y,2));return r===0?n=1/0:n=n/r,n}function eV(s,t,e,n){var r=t[0],i=t[1],o=e[0],a=e[1],l=Math.round(((r+s.y+1)*a-1)/n),c=Math.round(((i+s.x+1)*o-1)/n);return{x:c,y:l}}function nV(s,t,e,n,r,i,o){for(var a=o[0],l=o[1],c=e(s),u=c.y*n+c.x,h=r[Cs*(2*u)+t],d=r[Cs*(2*u+1)+t],p=s.y+h,f=s.x+d,m=0;m<i;m++){p=Math.min(p,a-1),f=Math.min(f,l-1);var g=e({x:f,y:p}),y=g.y*n+g.x;h=r[Cs*(2*y)+t],d=r[Cs*(2*y+1)+t],p=p+h,f=f+d}return{x:f,y:p}}function kk(s,t,e,n,r,i,o,a,l,c){for(var u=r[0],h=r[1],d=i[0],p=i[1],f=a[0],m=a[1],g=[],y=function(I){return eV(I,[u,h],[d,p],l)},b=0;b<n;b++){var w=nV(s,b,y,o,t,c,[f,m]);g.push(w)}for(var x=-1,v=1/0,C=0;C<e.length;C++){var k=tV(g,e[C]);k<v&&(x=C,v=k)}return x}function Ik(s,t){var e=s[0],n=s[1],r=Math.round((n-1)/t+1),i=Math.round((e-1)/t+1);return[r,i]}function sV(s,t,e,n,r,i,o,a,l,c){var u=o[0],h=o[1];c===void 0&&(c=5);for(var d=e.map(function(I){return new Uint8Array(n*r).fill(0)}),p=a.top,f=a.left,m=ex([n,r],[u,h],a),g=m[0],y=m[1],b=Ik([u,h],i)[0],w=0;w<n;w+=1)for(var x=0;x<r;x+=1){var v=w*r+x,C=s[v];if(C===1){var k=kk({x,y:w},t,e,c,[p,f],[g,y],b,[n,r],i,l);k>=0&&(d[k][v]=1)}}return d}function rV(s,t,e,n,r,i,o,a,l,c,u){var h=a[0],d=a[1];u===void 0&&(u=5);for(var p=n.map(function(N){return new Int32Array(r*i).fill(-1)}),f=l.top,m=l.left,g=ex([r,i],[h,d],l),y=g[0],b=g[1],w=Ik([h,d],o)[0],x=0;x<r;x+=1)for(var v=0;v<i;v+=1){var C=x*i+v,k=s[C];if(k===1){var I=kk({x:v,y:x},t,n,u,[f,m],[y,b],w,[r,i],o,c);I>=0&&(p[I][C]=e[C])}}return p}function Nk(s,t,e,n,r,i,o,a,l,c,u){for(var h=o[0],d=o[1],p=s.shape,f=p[0],m=p[1],g=t.shape.slice(0,2),y=g[0],b=g[1],w=L(t,[y,b,2,Cs]),x=new Float32Array(u*Cs*3).fill(0),v=0;v<e.length;v++)for(var C=v*Cs*3,k=e[v],I=0;I<Cs;I++){var N=k.keypoints[I],_=C+I*3;x[_]=N.score,x[_+1]=N.position.y,x[_+2]=N.position.x}var T=ex([n,r],[h,d],a),D=T[0],R=T[1],P=Yn(x,[u,Cs,3]),B=a.top,U=a.left,H={variableNames:["segmentation","longOffsets","poses"],outputShape:[f,m],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `.concat(B,", ").concat(R,", ").concat(i,`);
      float stridedW = convertToPositionInOutputFloat(
        w, `).concat(U,", ").concat(D,", ").concat(i,`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `).concat(u,`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `).concat(Cs,`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `).concat(l,`; s++) {
            int yRounded = round(min(y, float(`).concat(n-1,`)));
            int xRounded = round(min(x, float(`).concat(r-1,`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `).concat(B,", ").concat(R,", ").concat(i,`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `).concat(U,", ").concat(D,", ").concat(i,`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `).concat(c,`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `)},G=Af();return G.compileAndRun(H,[s,w,P])}function iV(s,t){return W(function(){return rt(Pn(s,gt(t)),"int32")})}function oV(s,t,e){return W(function(){return ct(F(rt(Pn(s,gt(e)),"int32"),tt(t,1)),1)})}function $k(){return u0()==="webgl"}function aV(s,t,e,n,r,i,o,a,l,c,u,h){var d=o[0],p=o[1];return l===void 0&&(l=.2),c===void 0&&(c=8),u===void 0&&(u=.3),h===void 0&&(h=10),js(this,void 0,void 0,function(){var f,m,g,y,b;return Hs(this,function(w){switch(w.label){case 0:return f=e.filter(function(x){return x.score>=l}),$k()?(g=W(function(){var x=Nk(s,t,f,n,r,i,[d,p],a,c,u,h),v=Gn().makeTensorFromDataId(x.dataId,x.shape,x.dtype);return f.map(function(C,k){return iV(v,k)})}),[4,Promise.all(g.map(function(x){return x.data()}))]):[3,2];case 1:return m=w.sent(),g.forEach(function(x){return x.dispose()}),[3,5];case 2:return[4,s.data()];case 3:return y=w.sent(),[4,t.data()];case 4:b=w.sent(),m=sV(y,b,f,n,r,i,[d,p],a,c),w.label=5;case 5:return[2,m.map(function(x,v){return{data:x,pose:f[v],width:r,height:n}})]}})})}function lV(s,t,e,n,r,i,o,a,l,c,u,h,d){var p=a[0],f=a[1];return c===void 0&&(c=.2),u===void 0&&(u=8),h===void 0&&(h=.3),d===void 0&&(d=10),js(this,void 0,void 0,function(){var m,g,y,b,w,x;return Hs(this,function(v){switch(v.label){case 0:return m=n.filter(function(C){return C.score>=c}),$k()?(y=W(function(){var C=Nk(s,t,m,r,i,o,[p,f],l,u,h,d),k=Gn().makeTensorFromDataId(C.dataId,C.shape,C.dtype);return m.map(function(I,N){return oV(k,e,N)})}),[4,Promise.all(y.map(function(C){return C.data()}))]):[3,2];case 1:return g=v.sent(),y.forEach(function(C){return C.dispose()}),[3,6];case 2:return[4,s.data()];case 3:return b=v.sent(),[4,t.data()];case 4:return w=v.sent(),[4,e.data()];case 5:x=v.sent(),g=rV(b,w,x,m,r,i,o,[p,f],l,u),v.label=6;case 6:return[2,g.map(function(C,k){return{pose:m[k],data:C,height:r,width:i}})]}})})}function cg(s){return Math.floor(s/2)}var cV=(function(){function s(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return s.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},s.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},s.prototype.empty=function(){return this.numberOfElements===-1},s.prototype.size=function(){return this.numberOfElements+1},s.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},s.prototype.max=function(){return this.priorityQueue[0]},s.prototype.swim=function(t){for(;t>0&&this.less(cg(t),t);)this.exchange(t,cg(t)),t=cg(t)},s.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},s.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},s.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},s.prototype.exchange=function(t,e){var n=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=n},s})();function uV(s,t,e,n,r,i){for(var o=i.shape,a=o[0],l=o[1],c=!0,u=Math.max(e-r,0),h=Math.min(e+r+1,a),d=u;d<h;++d){for(var p=Math.max(n-r,0),f=Math.min(n+r+1,l),m=p;m<f;++m)if(i.get(d,m,s)>t){c=!1;break}if(!c)break}return c}function hV(s,t,e){for(var n=e.shape,r=n[0],i=n[1],o=n[2],a=new cV(r*i*o,function(d){var p=d.score;return p}),l=0;l<r;++l)for(var c=0;c<i;++c)for(var u=0;u<o;++u){var h=e.get(l,c,u);h<s||uV(u,h,l,c,t,e)&&a.enqueue({score:h,part:{heatmapY:l,heatmapX:c,id:u}})}return a}var _k=Jz.map(function(s){var t=s[0],e=s[1];return[jd[t],jd[e]]}),ug=_k.map(function(s){var t=s[1];return t}),hv=_k.map(function(s){var t=s[0];return t});function dV(s,t,e){var n=e.shape[2]/2;return{y:e.get(t.y,t.x,s),x:e.get(t.y,t.x,n+s)}}function hg(s,t,e,n){return{y:cv(Math.round(s.y/t),0,e-1),x:cv(Math.round(s.x/t),0,n-1)}}function dv(s,t,e,n,r,i,o,a){a===void 0&&(a=2);for(var l=n.shape,c=l[0],u=l[1],h=hg(t.position,i,c,u),d=dV(s,h,o),p=uv(t.position,d),f=p,m=0;m<a;m++){var g=hg(f,i,c,u),y=Ck(g.y,g.x,e,r);f=uv({x:g.x*i,y:g.y*i},{x:y.x,y:y.y})}var b=hg(f,i,c,u),w=n.get(b.y,b.x,e);return{position:f,part:vm[e],score:w}}function pV(s,t,e,n,r,i){var o=t.shape[2],a=ug.length,l=new Array(o),c=s.part,u=s.score,h=Tk(c,n,e);l[c.id]={score:u,part:vm[c.id],position:h};for(var d=a-1;d>=0;--d){var p=ug[d],f=hv[d];l[p]&&!l[f]&&(l[f]=dv(d,l[p],f,t,e,n,i))}for(var d=0;d<a;++d){var p=hv[d],f=ug[d];l[p]&&!l[f]&&(l[f]=dv(d,l[p],f,t,e,n,r))}return l}function Ek(s,t,e,n){var r=e.x,i=e.y;return s.some(function(o){var a=o.keypoints,l=a[n].position;return Qz(i,r,l.y,l.x)<=t})}function fV(s,t,e){var n=e.reduce(function(r,i,o){var a=i.position,l=i.score;return Ek(s,t,a,o)||(r+=l),r},0);return n/=e.length}var mV=1;function Wh(s,t,e,n,r,i,o,a){o===void 0&&(o=.5),a===void 0&&(a=20);for(var l=[],c=hV(o,mV,s),u=a*a;l.length<i&&!c.empty();){var h=c.dequeue(),d=Tk(h.part,r,t);if(!Ek(l,u,d,h.part.id)){var p=pV(h,s,t,r,e,n),f=fV(l,u,p);l.push({keypoints:p,score:f})}}return l}var gV=[-123.15,-115.9,-103.06],yV=(function(s){wk(t,s);function t(){return s!==null&&s.apply(this,arguments)||this}return t.prototype.preprocessInput=function(e){return tt(e,gV)},t.prototype.nameOutputResults=function(e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],l=e[5],c=e[6],u=e[7];return{offsets:a,segmentation:c,partHeatmaps:l,longOffsets:o,heatmap:i,displacementFwd:r,displacementBwd:n,partOffsets:u}},t})(Sk);var pv="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",fv="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function bV(s,t){var e="model-stride".concat(s,".json");return t===4?pv+"float/"+e:pv+"quant".concat(t,"/")+e}function xV(s,t,e){var n={1:"100",.75:"075",.5:"050"},r="model-stride".concat(s,".json");return e===4?fv+"float/".concat(n[t],"/")+r:fv+"quant".concat(e,"/").concat(n[t],"/")+r}var Ro;function wV(s){if("offsetHeight"in s&&s.offsetHeight!==0&&"offsetWidth"in s&&s.offsetWidth!==0)return[s.offsetHeight,s.offsetWidth];if(s.height!=null&&s.width!=null)return[s.height,s.width];throw new Error("HTMLImageElement must have height and width attributes set.")}function vV(s){return s.hasAttribute("height")&&s.hasAttribute("width")?[s.height,s.width]:[s.videoHeight,s.videoWidth]}function zl(s){if(typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)return wV(s);if(typeof ImageData<"u"&&s instanceof ImageData)return[s.height,s.width];if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)return vV(s);if(s instanceof Lt)return[s.shape[0],s.shape[1]];throw new Error("error: Unknown input type: ".concat(s,"."))}function SV(s,t){return(s-1)%t===0}function mv(s,t){return SV(s,t)?s:Math.floor(s/t)*t+1}var Vl={low:"low",medium:"medium",high:"high",full:"full"},CV=(Ro={},Ro[Vl.low]=.25,Ro[Vl.medium]=.5,Ro[Vl.high]=.75,Ro[Vl.full]=1,Ro),gv=.1,yv=2;function TV(s){if(typeof s=="string"){var t=CV[s];return $(typeof t=="number",function(){return"string value of inputResolution must be one of ".concat(Object.values(Vl).join(",")," but was ").concat(s,".")}),t}else return $(typeof s=="number"&&s<=yv&&s>=gv,function(){return"inputResolution must be a string or number between ".concat(gv," and ").concat(yv,", but ")+"was ".concat(s)}),s}function Uh(s,t,e){var n=e[0],r=e[1],i=TV(s);return[mv(n*i,t),mv(r*i,t)]}function kV(s){return s instanceof Lt?s:OT(s)}function Fo(s,t,e,n,r){var i=t[0],o=t[1],a=e[0],l=e[1],c=n[0],u=c[0],h=c[1],d=n[1],p=d[0],f=d[1];return W(function(){var m=Dn.resizeBilinear(s,[a,l],!0);return m=Zn(m),IV(m,[i,o],[[u,h],[p,f]])})}function IV(s,t,e){var n=t[0],r=t[1],i=e[0],o=i[0],a=i[1],l=e[1],c=l[0],u=l[1];return W(function(){var h=we(s);return En(Dn.cropAndResize(h,[[o/(n+o+a-1),c/(r+c+u-1),(o+n-1)/(n+o+a-1),(c+r-1)/(r+c+u-1)]],[0],[n,r]),[0])})}function Gh(s,t){var e=t[0],n=t[1],r=zl(s),i=r[0],o=r[1],a=n/e,l=o/i,c=[0,0,0,0],u=c[0],h=c[1],d=c[2],p=c[3];l<a?(u=0,h=0,d=Math.round(.5*(a*i-o)),p=Math.round(.5*(a*i-o))):(u=Math.round(.5*(1/a*o-i)),h=Math.round(.5*(1/a*o-i)),d=0,p=0);var f=W(function(){var m=kV(s);return m=Q0(m,[[u,h],[d,p],[0,0]]),Dn.resizeBilinear(m,[e,n])});return{resized:f,padding:{top:u,left:d,right:p,bottom:h}}}function jh(s){return js(this,void 0,void 0,function(){return Hs(this,function(t){return[2,Promise.all(s.map(function(e){return e.buffer()}))]})})}function NV(s,t,e,n,r){return n===void 0&&(n=0),r===void 0&&(r=0),{score:s.score,keypoints:s.keypoints.map(function(i){var o=i.score,a=i.part,l=i.position;return{score:o,part:a,position:{x:l.x*e+r,y:l.y*t+n}}})}}function $V(s,t,e,n,r){return n===void 0&&(n=0),r===void 0&&(r=0),e===1&&t===1&&n===0&&r===0?s:s.map(function(i){return NV(i,t,e,n,r)})}function Hh(s,t,e,n,r){var i=t[0],o=t[1],a=e[0],l=e[1],c=(i+n.top+n.bottom)/a,u=(o+n.left+n.right)/l,h=$V(s,c,u,-n.top,-n.left);return h}var Dk={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},bv=["MobileNetV1","ResNet50"],xv={MobileNetV1:[8,16,32],ResNet50:[32,16]},wv={MobileNetV1:[.5,.75,1],ResNet50:[1]},vv=[1,2,4];function _V(s){if(s=s||Dk,s.architecture==null&&(s.architecture="MobileNetV1"),bv.indexOf(s.architecture)<0)throw new Error("Invalid architecture ".concat(s.architecture,". ")+"Should be one of ".concat(bv));if(s.outputStride==null&&(s.outputStride=16),xv[s.architecture].indexOf(s.outputStride)<0)throw new Error("Invalid outputStride ".concat(s.outputStride,". ")+"Should be one of ".concat(xv[s.architecture]," ")+"for architecture ".concat(s.architecture,"."));if(s.multiplier==null&&(s.multiplier=1),wv[s.architecture].indexOf(s.multiplier)<0)throw new Error("Invalid multiplier ".concat(s.multiplier,". ")+"Should be one of ".concat(wv[s.architecture]," ")+"for architecture ".concat(s.architecture,"."));if(s.quantBytes==null&&(s.quantBytes=4),vv.indexOf(s.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(s.quantBytes,". ")+"Should be one of ".concat(vv," ")+"for architecture ".concat(s.architecture,"."));return s}var Xh={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},qh={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function Sv(s){var t=s.segmentationThreshold,e=s.maxDetections,n=s.scoreThreshold,r=s.nmsRadius;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(e<=0)throw new Error("Invalid maxDetections ".concat(e,". ")+"Should be > 0");if(n<0||n>1)throw new Error("Invalid scoreThreshold ".concat(n,". ")+"Should be in range [0.0, 1.0]");if(r<=0)throw new Error("Invalid nmsRadius ".concat(r,"."))}function Cv(s){var t=s.segmentationThreshold,e=s.maxDetections,n=s.scoreThreshold,r=s.nmsRadius,i=s.minKeypointScore,o=s.refineSteps;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(e<=0)throw new Error("Invalid maxDetections ".concat(e,". ")+"Should be > 0");if(n<0||n>1)throw new Error("Invalid scoreThreshold ".concat(n,". ")+"Should be in range [0.0, 1.0]");if(r<=0)throw new Error("Invalid nmsRadius ".concat(r,"."));if(i<0||i>1)throw new Error("Invalid minKeypointScore ".concat(i,".")+"Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps ".concat(o,".")+"Should be in range [1, 20]")}var Ak=(function(){function s(t){this.baseModel=t}return s.prototype.predictForPersonSegmentation=function(t){var e=this.baseModel.predict(t),n=e.segmentation,r=e.heatmapScores,i=e.offsets,o=e.displacementFwd,a=e.displacementBwd;return{segmentLogits:n,heatmapScores:r,offsets:i,displacementFwd:o,displacementBwd:a}},s.prototype.predictForPersonSegmentationAndPart=function(t){var e=this.baseModel.predict(t),n=e.segmentation,r=e.partHeatmaps,i=e.heatmapScores,o=e.offsets,a=e.displacementFwd,l=e.displacementBwd;return{segmentLogits:n,partHeatmapLogits:r,heatmapScores:i,offsets:o,displacementFwd:a,displacementBwd:l}},s.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(t){var e=this.baseModel.predict(t),n=e.segmentation,r=e.longOffsets,i=e.heatmapScores,o=e.offsets,a=e.displacementFwd,l=e.displacementBwd,c=e.partHeatmaps;return{segmentLogits:n,longOffsets:r,heatmapScores:i,offsets:o,displacementFwd:a,displacementBwd:l,partHeatmaps:c}},s.prototype.segmentPersonActivation=function(t,e,n){var r=this;n===void 0&&(n=.5);var i=zl(t),o=i[0],a=i[1],l=Uh(e,this.baseModel.outputStride,[o,a]),c=Gh(t,l),u=c.resized,h=c.padding,d=W(function(){var b=r.predictForPersonSegmentation(u),w=b.segmentLogits,x=b.heatmapScores,v=b.offsets,C=b.displacementFwd,k=b.displacementBwd,I=u.shape,N=I[0],_=I[1],T=Fo(w,[o,a],[N,_],[[h.top,h.bottom],[h.left,h.right]]);return{segmentation:Vh(En(T),n),heatmapScores:x,offsets:v,displacementFwd:C,displacementBwd:k}}),p=d.segmentation,f=d.heatmapScores,m=d.offsets,g=d.displacementFwd,y=d.displacementBwd;return u.dispose(),{segmentation:p,heatmapScores:f,offsets:m,displacementFwd:g,displacementBwd:y,padding:h,internalResolutionHeightAndWidth:l}},s.prototype.segmentPerson=function(t,e){return e===void 0&&(e=Xh),js(this,void 0,void 0,function(){var n,r,i,o,a,l,c,u,h,d,p,f,m,g,y,b,w,x;return Hs(this,function(v){switch(v.label){case 0:return e=Ls(Ls({},Xh),e),Sv(e),n=this.segmentPersonActivation(t,e.internalResolution,e.segmentationThreshold),r=n.segmentation,i=n.heatmapScores,o=n.offsets,a=n.displacementFwd,l=n.displacementBwd,c=n.padding,u=n.internalResolutionHeightAndWidth,h=r.shape,d=h[0],p=h[1],[4,r.data()];case 1:return f=v.sent(),r.dispose(),[4,jh([i,o,a,l])];case 2:return m=v.sent(),g=m[0],y=m[1],b=m[2],w=m[3],x=Wh(g,y,b,w,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),x=Hh(x,[d,p],u,c),i.dispose(),o.dispose(),a.dispose(),l.dispose(),[2,{height:d,width:p,data:f,allPoses:x}]}})})},s.prototype.segmentMultiPerson=function(t,e){return e===void 0&&(e=qh),js(this,void 0,void 0,function(){var n,r,i,o,a,l,c,u,h,d,p,f,m,g,y,b,w,x,v,C,k,I=this;return Hs(this,function(N){switch(N.label){case 0:return e=Ls(Ls({},qh),e),Cv(e),n=zl(t),r=n[0],i=n[1],o=Uh(e.internalResolution,this.baseModel.outputStride,[r,i]),a=Gh(t,o),l=a.resized,c=a.padding,u=W(function(){var _=I.predictForMultiPersonInstanceSegmentationAndPart(l),T=_.segmentLogits,D=_.longOffsets,R=_.heatmapScores,P=_.offsets,B=_.displacementFwd,U=_.displacementBwd,H=Fo(T,[r,i],o,[[c.top,c.bottom],[c.left,c.right]]),G;G=D;var X=Vh(En(H),e.segmentationThreshold);return{segmentation:X,longOffsets:G,heatmapScoresRaw:R,offsetsRaw:P,displacementFwdRaw:B,displacementBwdRaw:U}}),h=u.segmentation,d=u.longOffsets,p=u.heatmapScoresRaw,f=u.offsetsRaw,m=u.displacementFwdRaw,g=u.displacementBwdRaw,[4,jh([p,f,m,g])];case 1:return y=N.sent(),b=y[0],w=y[1],x=y[2],v=y[3],C=Wh(b,w,x,v,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),C=Hh(C,[r,i],o,c),[4,aV(h,d,C,r,i,this.baseModel.outputStride,o,c,e.scoreThreshold,e.refineSteps,e.minKeypointScore,e.maxDetections)];case 2:return k=N.sent(),l.dispose(),h.dispose(),d.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),[2,k]}})})},s.prototype.segmentPersonPartsActivation=function(t,e,n){var r=this;n===void 0&&(n=.5);var i=zl(t),o=i[0],a=i[1],l=Uh(e,this.baseModel.outputStride,[o,a]),c=Gh(t,l),u=c.resized,h=c.padding,d=W(function(){var b=r.predictForPersonSegmentationAndPart(u),w=b.segmentLogits,x=b.partHeatmapLogits,v=b.heatmapScores,C=b.offsets,k=b.displacementFwd,I=b.displacementBwd,N=u.shape,_=N[0],T=N[1],D=Fo(w,[o,a],[_,T],[[h.top,h.bottom],[h.left,h.right]]),R=Fo(x,[o,a],[_,T],[[h.top,h.bottom],[h.left,h.right]]),P=Vh(En(D),n);return{partSegmentation:qz(P,R),heatmapScores:v,offsets:C,displacementFwd:k,displacementBwd:I}}),p=d.partSegmentation,f=d.heatmapScores,m=d.offsets,g=d.displacementFwd,y=d.displacementBwd;return u.dispose(),{partSegmentation:p,heatmapScores:f,offsets:m,displacementFwd:g,displacementBwd:y,padding:h,internalResolutionHeightAndWidth:l}},s.prototype.segmentPersonParts=function(t,e){return e===void 0&&(e=Xh),js(this,void 0,void 0,function(){var n,r,i,o,a,l,c,u,h,d,p,f,m,g,y,b,w,x;return Hs(this,function(v){switch(v.label){case 0:return e=Ls(Ls({},Xh),e),Sv(e),n=this.segmentPersonPartsActivation(t,e.internalResolution,e.segmentationThreshold),r=n.partSegmentation,i=n.heatmapScores,o=n.offsets,a=n.displacementFwd,l=n.displacementBwd,c=n.padding,u=n.internalResolutionHeightAndWidth,h=r.shape,d=h[0],p=h[1],[4,r.data()];case 1:return f=v.sent(),r.dispose(),[4,jh([i,o,a,l])];case 2:return m=v.sent(),g=m[0],y=m[1],b=m[2],w=m[3],x=Wh(g,y,b,w,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),x=Hh(x,[d,p],u,c),i.dispose(),o.dispose(),a.dispose(),l.dispose(),[2,{height:d,width:p,data:f,allPoses:x}]}})})},s.prototype.segmentMultiPersonParts=function(t,e){return e===void 0&&(e=qh),js(this,void 0,void 0,function(){var n,r,i,o,a,l,c,u,h,d,p,f,m,g,y,b,w,x,v,C,k,I,N=this;return Hs(this,function(_){switch(_.label){case 0:return e=Ls(Ls({},qh),e),Cv(e),n=zl(t),r=n[0],i=n[1],o=Uh(e.internalResolution,this.baseModel.outputStride,[r,i]),a=Gh(t,o),l=a.resized,c=a.padding,u=W(function(){var T=N.predictForMultiPersonInstanceSegmentationAndPart(l),D=T.segmentLogits,R=T.longOffsets,P=T.heatmapScores,B=T.offsets,U=T.displacementFwd,H=T.displacementBwd,G=T.partHeatmaps,X=Fo(D,[r,i],o,[[c.top,c.bottom],[c.left,c.right]]),Z=Fo(G,[r,i],o,[[c.top,c.bottom],[c.left,c.right]]),J=R,et=Vh(En(X),e.segmentationThreshold),Q=Kz(Z);return{segmentation:et,longOffsets:J,heatmapScoresRaw:P,offsetsRaw:B,displacementFwdRaw:U,displacementBwdRaw:H,partSegmentation:Q}}),h=u.segmentation,d=u.longOffsets,p=u.heatmapScoresRaw,f=u.offsetsRaw,m=u.displacementFwdRaw,g=u.displacementBwdRaw,y=u.partSegmentation,[4,jh([p,f,m,g])];case 1:return b=_.sent(),w=b[0],x=b[1],v=b[2],C=b[3],k=Wh(w,x,v,C,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),k=Hh(k,[r,i],o,c),[4,lV(h,d,y,k,r,i,this.baseModel.outputStride,o,c,e.scoreThreshold,e.refineSteps,e.minKeypointScore,e.maxDetections)];case 2:return I=_.sent(),l.dispose(),h.dispose(),d.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),y.dispose(),[2,I]}})})},s.prototype.dispose=function(){this.baseModel.dispose()},s})();function EV(s){return js(this,void 0,void 0,function(){var t,e,n,r,i,o;return Hs(this,function(a){switch(a.label){case 0:if(t=s.outputStride,e=s.quantBytes,n=s.multiplier,mk==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=xV(t,n,e),[4,xk(s.modelUrl||r)];case 1:return i=a.sent(),o=new Yz(i,t),[2,new Ak(o)]}})})}function DV(s){return js(this,void 0,void 0,function(){var t,e,n,r,i;return Hs(this,function(o){switch(o.label){case 0:if(t=s.outputStride,e=s.quantBytes,mk==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return n=bV(t,e),[4,xk(s.modelUrl||n)];case 1:return r=o.sent(),i=new yV(r,t),[2,new Ak(i)]}})})}function AV(s){return s===void 0&&(s=Dk),js(this,void 0,void 0,function(){return Hs(this,function(t){return s=_V(s),s.architecture==="ResNet50"?[2,DV(s)]:s.architecture==="MobileNetV1"?[2,EV(s)]:[2,null]})})}function OV(s,t,e,n,r){if(t===void 0&&(t={r:0,g:0,b:0,a:0}),e===void 0&&(e={r:0,g:0,b:0,a:255}),n===void 0&&(n=!1),r===void 0&&(r=[1]),Array.isArray(s)&&s.length===0)return null;var i;Array.isArray(s)?i=s:i=[s];var o=i[0],a=o.width,l=o.height,c=new Uint8ClampedArray(a*l*4);function u(m,g,y,b,w,x){x===void 0&&(x={r:0,g:255,b:255,a:255});for(var v=-w;v<=w;v++)for(var C=-w;C<=w;C++)if(v!==0&&C!==0){var k=(g+v)*b+(y+C);m[4*k+0]=x.r,m[4*k+1]=x.g,m[4*k+2]=x.b,m[4*k+3]=x.a}}function h(m,g,y,b,w,x){w===void 0&&(w=[1]),x===void 0&&(x=1);for(var v=0,C=-x;C<=x;C++)for(var k=function(N){if(C!==0&&N!==0){var _=(g+C)*b+(y+N);w.some(function(T){return T===m[_]})||(v+=1)}},I=-x;I<=x;I++)k(I);return v>0}for(var d=0;d<l;d+=1)for(var p=function(m){var g=d*a+m;c[4*g+0]=e.r,c[4*g+1]=e.g,c[4*g+2]=e.b,c[4*g+3]=e.a;for(var y=function(w){if(r.some(function(v){return v===i[w].data[g]})){c[4*g]=t.r,c[4*g+1]=t.g,c[4*g+2]=t.b,c[4*g+3]=t.a;var x=h(i[w].data,d,m,a,r);n&&d-1>=0&&d+1<l&&m-1>=0&&m+1<a&&x&&u(c,d,m,a,1)}},b=0;b<i.length;b++)y(b)},f=0;f<a;f+=1)p(f);return new ImageData(c,a,l)}const Ok={kernelName:Ic,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,To(rt(e,"float32"),-1))}}};const RV={kernelName:xa,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>{const n=jt(rt(e,"float32")),r=Me(ct(gt(1),n));return Zt(ft(s,r))}}}};const FV={kernelName:wa,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>{const n=Me(ct(jt(rt(e,"float32")),1));return ft(s,n)}}}};const PV={kernelName:vo,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{let a=s;const l=Te(e.shape,r);return l.length>0&&(a=ht(a,l)),L(a,e.shape)},b:()=>{let a=s;const l=Te(n.shape,r);return l.length>0&&(a=ht(a,l)),L(a,n.shape)}}}};const LV={kernelName:Nc,saveAllInputs:!0,gradFunc:(s,t)=>{const e={};return t.forEach((n,r)=>{e[r]=()=>s.clone()}),e}};const MV={kernelName:$c,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>Rt(e)}}};const BV={kernelName:_c,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>Rt(e)}}};const zV={kernelName:va,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,Me(ct(gt(1),jt(rt(e,"float32")))))}}};const VV={kernelName:Sa,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>{const n=Me(tt(gt(1),jt(rt(e,"float32"))));return ft(s,n)}}}};const WV={kernelName:ka,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{const a=tt(jt(e),jt(n));let l=F(s,ft(n,a));const c=Te(e.shape,r);return c.length>0&&(l=ht(l,c)),L(l,e.shape)},b:()=>{const a=tt(jt(e),jt(n));let l=Zt(F(s,ft(e,a)));const c=Te(n.shape,r);return c.length>0&&(l=ht(l,c)),L(l,n.shape)}}}};const UV={kernelName:Ca,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,tt(jt(rt(e,"float32")),1))}}};const GV={kernelName:Ta,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,ct(gt(1),jt(rt(e,"float32"))))}}};function jV(s,t,e,n,r,i){const o=E(s,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=L(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),$(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),$(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),cn("avgPool3dGrad",r,i);const h={dy:l,input:c},d={filterSize:e,strides:n,pad:r,dimRoundingMode:i},p=A.runKernel(Np,h,d);return u?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const HV=O({avgPool3dGrad_:jV});const XV={kernelName:Dc,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>HV(s,n,r,i,o,a)}}};function qV(s,t,e,n,r){const i=E(s,"dy","avgPoolGrad"),o=E(t,"input","avgPoolGrad");$(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),$(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:e,strides:n,pad:r},d=A.runKernel(Ip,u,h);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const KV=O({avgPoolGrad_:qV});const YV={kernelName:Ec,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>KV(s,n,r,i,o)}}};const ZV={kernelName:Ac,inputsToSave:["a","b"],gradFunc:(s,t,e)=>{const[n,r]=t,{transposeA:i,transposeB:o}=e;return!i&&!o?{a:()=>Ct(s,r,!1,!0),b:()=>Ct(n,s,!0,!1)}:!i&&o?{a:()=>Ct(s,r,!1,!1),b:()=>Ct(s,n,!0,!1)}:i&&!o?{a:()=>Ct(r,s,!1,!0),b:()=>Ct(n,s,!1,!1)}:{a:()=>Ct(r,s,!0,!0),b:()=>Ct(s,n,!0,!0)}}};const JV={kernelName:Oc,gradFunc:(s,t,e)=>{const{blockShape:n,crops:r}=e;return{x:()=>Wu(s,n,r)}}};const QV={kernelName:jS,gradFunc:(s,t,e)=>{const n=e,r=n.inputShape,i=n.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>ht(s,a,!0)}}};const tW={kernelName:Ia,gradFunc:s=>({x:()=>s.clone()})};const eW={kernelName:Na,gradFunc:s=>({x:()=>Rt(s)})};const nW={kernelName:$a,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>Ge(Es(zr(n,r),Ti(n,i)),s,Rt(s))}}};const sW={kernelName:Fc,inputsToSave:["x"],gradFunc:Ok.gradFunc};const rW={kernelName:Pc,saveAllInputs:!0,gradFunc:(s,t,e)=>{const n=t.map(l=>l.shape),{axis:r}=e,i=$t(r,t[0].shape)[0],o=n.map(l=>l[i]);return gn(s,o,i).map(l=>()=>l)}};const iW={kernelName:Lc,inputsToSave:["x","filter"],gradFunc:(s,t,e)=>{const[n,r]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return $(hi(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>R0(n.shape,s,r,o,a,l),filter:()=>yb(n,s,r.shape,o,a,l)}}};const oW={kernelName:Mc,inputsToSave:["dy","filter"],gradFunc:(s,t,e)=>{const[n,r]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Er(s,r,i,o,a,1,l),filter:()=>yb(s,n,r.shape,i,o,a,l)}}};function aW(s,t,e,n,r){let i=s;s.rank===4&&(i=L(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));let o=t;o.rank===4&&(o=L(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),$(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),$(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),$(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),$(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),$(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const a={x:i,dy:o},l={strides:n,pad:r,filterShape:e};return A.runKernel(Ap,a,l)}const lW=O({conv3DBackpropFilter_:aW});const cW={kernelName:Bc,inputsToSave:["x","filter"],gradFunc:(s,t,e)=>{const{dilations:n,strides:r,pad:i}=e;$(hi(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);const[o,a]=t;return{x:()=>IC(o.shape,s,a,r,i),filter:()=>lW(o,s,a.shape,r,i)}}};const uW={kernelName:_a,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(Zt(Jf(rt(e,"float32"))),s)}}};const hW={kernelName:Ea,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(Qf(rt(e,"float32")),s)}}};const dW={kernelName:zc,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const a=ce([r],n.rank);let l=Mf(s,r,i,!o);return a!=null&&(l=At(l,a)),l}}}};const pW={kernelName:Vc,inputsToSave:["x","filter"],gradFunc:(s,t,e)=>{const{dilations:n,strides:r,pad:i,dimRoundingMode:o}=e,a=n??[1,1];$(hi(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return $(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),$(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),$(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),$(Xe(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),cn("depthwiseConv2d",i,o),{x:()=>mT(l.shape,s,c,r,i,a,o),filter:()=>fT(l,s,c.shape,r,i,a,o)}}};const fW={kernelName:Wc,inputsToSave:["x","filter"],gradFunc:(s,t,e)=>{const[n,r]=t,i={x:n,filter:r,dy:s},o={x:n,filter:r,dy:s};return{x:()=>A.runKernel(Md,i,e),filter:()=>A.runKernel(Bd,o,e)}}};const mW={kernelName:Aa,outputsToSave:[!0],gradFunc:(s,t)=>{const[e]=t,n={dy:s,y:e};return{x:()=>A.runKernel(Up,n)}}};const gW={kernelName:Oa,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t,n=F(vn(Zt(jt(e))),2/Math.sqrt(Math.PI));return{x:()=>F(s,n)}}};const yW={kernelName:Ra,outputsToSave:[!0],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,e)}}};const bW={kernelName:Gc,inputsToSave:["input"],gradFunc:(s,t)=>{const[e]=t;return{input:()=>L(s,e.shape)}}};const xW={kernelName:Fa,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,vn(e))}}};const wW={kernelName:Pa,gradFunc:s=>({x:()=>Rt(s)})};const vW={kernelName:La,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{const a=ft(s,rt(n,"float32")),l=Te(e.shape,r);return l.length>0?L(ht(a,l),e.shape):a},b:()=>{let a=F(s,rt(e,"float32"));const l=Te(n.shape,r);l.length>0&&(a=L(ht(a,l),n.shape));const c=jt(n);return Zt(ft(a,rt(c,"float32")))}}}};const SW={kernelName:jc,inputsToSave:["x","mean","variance","scale"],gradFunc:(s,t,e)=>{const{varianceEpsilon:n}=e,[r,i,o,a]=t,l=a??gt(1),c=Te(i.shape,r.shape),u=[];if(i.rank===1){for(let x=0;x<r.shape.length-1;++x)u.push(r.shape[x]);u.push(1)}const h=ct(r,i),d=F(s,l),p=Kf(tt(o,gt(n))),f=F(F(F(p,p),p),gt(-.5));return{x:()=>i.rank===1?L(F(F(s,Xn(L(p,[1,1,1,i.shape[0]]),u)),l),r.shape):L(F(F(s,p),l),r.shape),mean:()=>{let x=F(F(p,gt(-1)),d);return i.rank===1&&(x=ht(x,c)),L(x,i.shape)},variance:()=>{let x=F(F(f,h),d);return i.rank===1&&(x=ht(x,c)),L(x,i.shape)},scale:()=>{const x=F(h,p);let v=F(s,x);return i.rank===1&&(v=ht(v,c)),L(v,i.shape)},offset:()=>{let x=s;return i.rank===1&&(x=ht(x,c)),L(x,i.shape)}}}};const CW={kernelName:Hc,inputsToSave:["x","indices"],gradFunc:(s,t,e)=>{const[n,r]=t,{axis:i,batchDims:o}=e,a=$t(i,n.shape)[0],l=(c,u,h)=>()=>{const d=c.shape,p=u.size,f=d.slice(0,a),m=f.length,g=d.slice(i,d.length).slice(1),y=g.length,b=Tv(0,m),w=Tv(m+1,m+1+y),x=kv([f,[p],g]),v=L(h,x),C=L(u,[p]),k=kv([[m],b,w]),I=At(v,k);let N=im(I,C,c.shape[a]);const _=Ci(k);return N=At(N,_),N};if(o===1){const c=n.shape[0],u=n.split(c,0);return{x:()=>Sn(u.map((p,f)=>l(p,r.slice(f,1),s.slice(f,1))())).reshape(n.shape),indices:()=>r}}else return{x:l(n,r,s),indices:()=>r}}};function Tv(s,t){const e=[];for(let n=s;n<t;++n)e.push(n);return e}function kv(s){const t=[];for(let e=0;e<s.length;++e)for(let n=0;n<s[e].length;++n)t.push(s[e][n]);return t}const TW={kernelName:Ma,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t;return{a:()=>Rt(e),b:()=>Rt(n)}}};const kW={kernelName:Ba,gradFunc:s=>({x:()=>rt(s,"float32")})};const IW={kernelName:za,gradFunc:s=>({x:()=>Rt(s)})};const NW={kernelName:Va,gradFunc:s=>({x:()=>Rt(s)})};const $W={kernelName:Wa,gradFunc:s=>({x:()=>Rt(s)})};const _W={kernelName:qc,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{alpha:r}=e,i=un(n,0);return{x:()=>Ge(i,s,F(s,r))}}};const EW={kernelName:Ga,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,tt(e,1))}}};const DW={kernelName:Ua,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,rt(e,"float32"))}}};const AW={kernelName:HS,inputsToSave:[],outputsToSave:[!0],gradFunc:(s,t,e)=>{const[n]=t,{axis:r}=e;return{logits:()=>{const o=vn(n);return ct(s,F(ht(s,r,!0),o))}}}};function OW(s,t,e,n=5,r=1,i=1,o=.5){const a={x:s,y:t,dy:e},l={depthRadius:n,bias:r,alpha:i,beta:o};return A.runKernel(Zp,a,l)}const RW=O({localResponseNormalizationBackprop_:OW});const FW={kernelName:tu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,e)=>{const[n,r]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>RW(n,r,s,i,o,a,l)}}};function Rk(s,t,e,n){return t.rank<e.rank&&(t=L(t,fe(t.shape,n))),s.rank<e.rank&&(s=L(s,fe(s.shape,n))),{x:()=>F(s,rt(Pn(e,t),s.dtype))}}const Iv={kernelName:eu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,e)=>{const n=e,{reductionIndices:r}=n,i=t[0],o=t[1],a=$t(r,i.shape),l=Rk(s,o,i,a);return{x:()=>l.x()}}};const PW={kernelName:ja,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t;return{a:()=>F(s,rt(zr(e,n),"float32")),b:()=>F(s,rt(na(e,n),"float32"))}}};function LW(s,t,e,n,r,i,o){const a=E(s,"dy","maxPool3dGrad"),l=E(t,"input","maxPool3dGrad"),c=E(e,"output","maxPool3dGrad");let u=a,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=L(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),$(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),$(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),$(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),cn("maxPool3dGrad",i,o);const f={dy:u,input:h,output:d},m={filterSize:n,strides:r,pad:i,dimRoundingMode:o},g=A.runKernel(Qp,f,m);return p?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const MW=O({maxPool3dGrad_:LW});const BW={kernelName:su,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,e)=>{const[n,r]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>MW(s,n,r,i,o,a,l)}}};function zW(s,t,e,n,r,i,o){const a=E(s,"dy","maxPoolGrad"),l=E(t,"input","maxPoolGrad"),c=E(e,"output","maxPoolGrad");$(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),$(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),$(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),cn("maxPoolGrad",i,o);const u={dy:a,input:l,output:c},h={filterSize:n,strides:r,pad:i,dimRoundingMode:o};return A.runKernel(Jp,u,h)}const VW=O({maxPoolGrad_:zW});const WW={kernelName:nu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,e)=>{const[n,r]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>VW(s,n,r,i,o,a)}}};const UW={kernelName:ru,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{axis:r}=e,i=$t(r,n.shape),a=ze(n.shape,i)[1],l=K(a);return{x:()=>{const u=n.shape.slice();i.forEach(p=>{u[p]=1});const h=L(s,u);return ft(F(h,mn(n.shape,"float32")),l)}}}};const GW={kernelName:iu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,t,e)=>{const n=e,{axis:r}=n,[i,o]=t,a=$t(r,i.shape),l=Rk(s,o,i,a);return{x:()=>l.x()}}};const jW={kernelName:Ha,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t;return{a:()=>F(s,rt(Ti(e,n),"float32")),b:()=>F(s,rt(un(e,n),"float32"))}}};const HW={kernelName:ou,inputsToSave:["x"],gradFunc:(s,t,e)=>{const n=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Ot(s,i,n.shape)}}};const XW={kernelName:Xa,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{const a=Te(e.shape,r);return a.length>0?L(ht(s,a),e.shape):s},b:()=>{const a=F(s,Zt(bl(ft(e,n)))),l=Te(n.shape,r);return l.length>0?L(ht(a,l),n.shape):a}}}};const qW={kernelName:qa,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{const a=F(s,rt(n,"float32")),l=Te(e.shape,r);return l.length>0?L(ht(a,l),e.shape):a},b:()=>{const a=F(s,rt(e,"float32")),l=Te(n.shape,r);return l.length>0?L(ht(a,l),n.shape):a}}}};const KW={kernelName:au,gradFunc:s=>({x:()=>Zt(s)})};const YW={kernelName:uu,inputsToSave:["indices"],gradFunc:(s,t)=>{const e=t[0];return{indices:()=>ve(e.shape,"float32")}}};const ZW={kernelName:cu,gradFunc:s=>({x:()=>Rt(s)})};const JW={kernelName:hu,saveAllInputs:!0,gradFunc:(s,t,e)=>{const{axis:n}=e;return ts(s,n).map(i=>()=>i)}};const Nv={kernelName:du,inputsToSave:["x"],gradFunc:(s,t,e)=>{const n=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Ot(s,i,n.shape)}}};const QW={kernelName:Ka,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(s,t)=>{const[e,n,r]=t,i=e,o=n,a=St(i.shape,o.shape);return{a:()=>{const u=rt(o,"float32");let h=F(s,F(u,nr(i,ct(u,gt(1)))));const d=Te(i.shape,a);return d.length>0&&(h=ht(h,d)),L(h,i.shape)},b:()=>{const u=un(i,0),h=Ge(u,Ln(i),Rt(i));let d=F(s,F(r,h));const p=Te(o.shape,a);return p.length>0&&(d=ht(d,p)),L(d,o.shape)}}}};const t4={kernelName:pu,inputsToSave:["x","alpha"],gradFunc:(s,t)=>{const[e,n]=t,r=un(e,0);return{x:()=>Ge(r,s,F(s,n)),alpha:()=>{let i=Ge(r,Rt(s),F(s,e));const o=Te(n.shape,s.shape);return o.length>0&&(i=ht(i,o)),L(i,n.shape)}}}};function e4(s,t,e){const n=s.shape.slice();n[e]=1;const r=L(t,n),i=fc(s,e,!0,!1),o=fc(s,e,!0,!0),a=F(i,o);return F(r,a)}function n4(s,t,e){const n=s.shape.length,r=n-e.length,i=ce(e,n);let o=s;i!=null&&(o=At(s,i));const a=o.shape.slice(),c=a.splice(n-e.length,e.length).reduce((d,p)=>d*p,1);a.push(c);const u=o.reshape(a);let h=e4(u,t,r);if(h=h.reshape(o.shape),i!=null){const d=Ci(i);h=At(h,d)}return h}const s4={kernelName:fu,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{axis:r}=e;let i=[];return r==null?i=n.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>n4(n,s,i)}}};const r4={kernelName:Da,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{const a=ft(s,rt(n,"float32")),l=Te(e.shape,r);return l.length>0?L(ht(a,l),e.shape):a},b:()=>{let a=F(s,rt(e,"float32"));const l=Te(n.shape,r);l.length>0&&(a=L(ht(a,l),n.shape));const c=jt(n);return Zt(ft(a,rt(c,"float32")))}}}};const i4={kernelName:Ya,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,Zt(jt(e)))}}};const o4={kernelName:Ja,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t,n=F(Ti(e,6),To(e));return{x:()=>F(s,rt(n,"float32"))}}};const a4={kernelName:Za,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,rt(To(e),"float32"))}}};const l4={kernelName:mu,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>L(s,e.shape)}}};const c4={kernelName:yu,inputsToSave:["images"],gradFunc:(s,t,e)=>{const[n]=t,r={dy:s,images:n};return{images:()=>A.runKernel(df,r,e)}}};const u4={kernelName:gu,inputsToSave:["images"],gradFunc:(s,t,e)=>{const[n]=t,r={dy:s,images:n};return{images:()=>A.runKernel(hf,r,e)}}};const h4={kernelName:bu,gradFunc:(s,t,e)=>{const{dims:n}=e,r=$t(n,s.shape);return{x:()=>Qn(s,r)}}};const d4={kernelName:Qa,gradFunc:s=>({x:()=>Rt(s)})};const p4={kernelName:tl,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>Zt(ft(s,F(nr(e,1.5),2)))}}};const f4={kernelName:xu,inputsToSave:["condition"],gradFunc:(s,t)=>{const[e]=t;return{condition:()=>rt(Rt(e),"float32"),t:()=>F(s,rt(e,s.dtype)),e:()=>F(s,rt(Bu(e),s.dtype))}}};const m4={kernelName:el,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>{const n=un(e,gt(0)),r=gt(xm),i=gt(wm),o=F(s,i),a=F(F(s,r),vn(rt(e,"float32")));return Ge(n,o,a)}}}};const g4={kernelName:il,outputsToSave:[!0],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,F(e,ct(gt(1),e)))}}};const y4={kernelName:rl,gradFunc:s=>({x:()=>Rt(s)})};const b4={kernelName:nl,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(Ru(rt(e,"float32")),s)}}};const x4={kernelName:sl,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(Lf(rt(e,"float32")),s)}}};const w4={kernelName:wu,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{begin:r,size:i}=e,o=n.shape,[a,l]=ym(n,r,i),c=[];for(let u=0;u<s.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>Vr(s,c)}}};const v4={kernelName:Tu,outputsToSave:[!0],gradFunc:(s,t,e)=>{const[n]=t,{dim:r}=e,i=!0,o=F(s,n);return{logits:()=>ct(o,F(ht(o,[r],i),n))}}};const S4={kernelName:ol,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,Zn(e))}}};const $v={kernelName:Su,gradFunc:(s,t,e)=>{const{blockShape:n,paddings:r}=e;return{x:()=>Ou(s,n,r)}}};const _v={kernelName:Cu,gradFunc:(s,t,e)=>{const{axis:n}=e;return{x:()=>pe(s,n)}}};const C4={kernelName:al,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,F(Me(rt(e,"float32")),2))}}};const T4={kernelName:vf,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(s,F(rt(e,"float32"),2))}}};const k4={kernelName:ll,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=gt(2);return{a:()=>F(s,F(r,ct(e,n))),b:()=>F(s,F(r,ct(n,e)))}}};const I4={kernelName:pl,gradFunc:s=>({x:()=>Rt(s)})};const N4={kernelName:cl,inputsToSave:["a","b"],gradFunc:(s,t)=>{const[e,n]=t,r=St(e.shape,n.shape);return{a:()=>{let a=s;const l=Te(e.shape,r);return l.length>0&&(a=ht(a,l)),L(a,e.shape)},b:()=>{let a=s;const l=Te(n.shape,r);return l.length>0&&(a=ht(a,l)),L(Zt(a),n.shape)}}}};const $4={kernelName:vu,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,r=n.shape.slice(),{axis:i}=e;$t(i,n.shape).forEach(c=>{r[c]=1});const a=L(s,r),l=F(a,mn(n.shape,"float32"));return{x:()=>l}}};const _4={kernelName:ul,inputsToSave:["x"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>ft(s,jt(Ru(e)))}}};const E4={kernelName:hl,outputsToSave:[!0],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F(ct(gt(1),jt(e)),s)}}};const D4={kernelName:dl,inputsToSave:["x"],gradFunc:(s,t,e)=>{const[n]=t,{reps:r}=e;return{x:()=>{let o=Rt(n);if(n.rank===1)for(let a=0;a<r[0];++a)o=tt(o,Ot(s,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=tt(o,Ot(s,[a*n.shape[0],l*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=tt(o,Ot(s,[a*n.shape[0],l*n.shape[1],c*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let u=0;u<r[3];++u)o=tt(o,Ot(s,[a*n.shape[0],l*n.shape[1],c*n.shape[2],u*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return o}}}};const A4={kernelName:Zi,gradFunc:(s,t,e)=>{const n=e,{perm:r}=n,i=Ci(r);return{x:()=>At(s,i)}}};const O4={kernelName:Iu,gradFunc:(s,t,e)=>{const n=e,{axis:r}=n;return{value:()=>Sn(s,r)}}};const R4={kernelName:Nu,inputsToSave:["segmentIds"],gradFunc:(s,t)=>{const[e]=t;return{x:()=>F4(s,e)}}};function F4(s,t){const e=ar(t,Rt(t)),n=xl(s,e);let r=zr(t,gt(0,"int32"));const i=n.rank-r.rank;for(let a=0;a<i;++a)r=we(r,a+1);r=Es(r,mn(n.shape,"bool"));const o=Rt(n);return Ge(r,n,o)}const P4={kernelName:$u,gradFunc:s=>({x:()=>Rt(s)})};const L4=[Ok,RV,FV,PV,LV,MV,BV,zV,VV,WV,UV,GV,XV,YV,ZV,JV,QV,tW,eW,nW,sW,rW,oW,iW,cW,uW,hW,dW,pW,fW,r4,mW,gW,yW,bW,xW,vW,wW,SW,CW,TW,kW,IW,NW,$W,_W,EW,DW,AW,FW,Iv,Iv,PW,BW,WW,UW,GW,jW,HW,XW,qW,KW,YW,ZW,JW,Nv,Nv,QW,t4,s4,i4,o4,a4,l4,c4,u4,h4,d4,p4,f4,m4,g4,y4,b4,x4,w4,v4,S4,$v,$v,_v,_v,C4,k4,T4,I4,N4,$4,_4,E4,D4,A4,O4,R4,P4];for(const s of L4)XS(s);Y().prototype.abs=function(){return this.throwIfDisposed(),be(this)};Y().prototype.acos=function(){return this.throwIfDisposed(),m0(this)};Y().prototype.acosh=function(){return this.throwIfDisposed(),g0(this)};Y().prototype.add=function(s){return this.throwIfDisposed(),tt(this,s)};Y().prototype.all=function(s,t){return this.throwIfDisposed(),Rf(this,s,t)};Y().prototype.any=function(s,t){return this.throwIfDisposed(),hc(this,s,t)};Y().prototype.argMax=function(s){return this.throwIfDisposed(),ui(this,s)};Y().prototype.argMin=function(s){return this.throwIfDisposed(),y0(this,s)};Y().prototype.asScalar=function(){return this.throwIfDisposed(),$(this.size===1,()=>"The array must have only 1 element."),L(this,[])};Y().prototype.asType=function(s){return this.throwIfDisposed(),rt(this,s)};Y().prototype.as1D=function(){return this.throwIfDisposed(),L(this,[this.size])};Y().prototype.as2D=function(s,t){return this.throwIfDisposed(),L(this,[s,t])};Y().prototype.as3D=function(s,t,e){return this.throwIfDisposed(),L(this,[s,t,e])};Y().prototype.as4D=function(s,t,e,n){return this.throwIfDisposed(),L(this,[s,t,e,n])};Y().prototype.as5D=function(s,t,e,n,r){return this.throwIfDisposed(),L(this,[s,t,e,n,r])};Y().prototype.asin=function(){return this.throwIfDisposed(),b0(this)};Y().prototype.asinh=function(){return this.throwIfDisposed(),x0(this)};Y().prototype.atan=function(){return this.throwIfDisposed(),w0(this)};Y().prototype.atan2=function(s){return this.throwIfDisposed(),v0(this,s)};Y().prototype.atanh=function(){return this.throwIfDisposed(),S0(this)};Y().prototype.avgPool=function(s,t,e,n){return this.throwIfDisposed(),Au(this,s,t,e,n)};Y().prototype.batchToSpaceND=function(s,t){return this.throwIfDisposed(),Ou(this,s,t)};Y().prototype.batchNorm=function(s,t,e,n,r){return this.throwIfDisposed(),fl(this,s,t,e,n,r)};Y().prototype.broadcastTo=function(s){return this.throwIfDisposed(),Ji(this,s)};Y().prototype.cast=function(s){return this.throwIfDisposed(),rt(this,s)};Y().prototype.ceil=function(){return this.throwIfDisposed(),_0(this)};Y().prototype.clipByValue=function(s,t){return this.throwIfDisposed(),wn(this,s,t)};Y().prototype.concat=function(s,t){return this.throwIfDisposed(),s instanceof Lt&&(s=[s]),pe([this,...s],t)};Y().prototype.conv1d=function(s,t,e,n,r,i){return this.throwIfDisposed(),Ff(this,s,t,e,n,r,i)};Y().prototype.conv2dTranspose=function(s,t,e,n,r){return this.throwIfDisposed(),Pf(this,s,t,e,n,r)};Y().prototype.conv2d=function(s,t,e,n,r,i){return this.throwIfDisposed(),Er(this,s,t,e,n,r,i)};Y().prototype.cos=function(){return this.throwIfDisposed(),Ru(this)};Y().prototype.cosh=function(){return this.throwIfDisposed(),Lf(this)};Y().prototype.cumprod=function(s,t,e){return this.throwIfDisposed(),fc(this,s,t,e)};Y().prototype.cumsum=function(s,t,e){return this.throwIfDisposed(),Mf(this,s,t,e)};Y().prototype.depthToSpace=function(s,t){return this.throwIfDisposed(),L0(this,s,t)};Y().prototype.depthwiseConv2d=function(s,t,e,n,r,i){return this.throwIfDisposed(),ml(this,s,t,e,n,r,i)};Y().prototype.dilation2d=function(s,t,e,n,r){return this.throwIfDisposed(),M0(this,s,t,e,n,r)};Y().prototype.divNoNan=function(s){return this.throwIfDisposed(),B0(this,s)};Y().prototype.div=function(s){return this.throwIfDisposed(),ft(this,s)};Y().prototype.dot=function(s){return this.throwIfDisposed(),z0(this,s)};Y().prototype.elu=function(){return this.throwIfDisposed(),gl(this)};Y().prototype.equal=function(s){return this.throwIfDisposed(),Pn(this,s)};Y().prototype.erf=function(){return this.throwIfDisposed(),Bf(this)};Y().prototype.euclideanNorm=function(s,t){return this.throwIfDisposed(),W0(this,s,t)};Y().prototype.exp=function(){return this.throwIfDisposed(),vn(this)};Y().prototype.expandDims=function(s){return this.throwIfDisposed(),we(this,s)};Y().prototype.expm1=function(){return this.throwIfDisposed(),U0(this)};Y().prototype.fft=function(){return this.throwIfDisposed(),Xu(this)};Y().prototype.flatten=function(){return this.throwIfDisposed(),L(this,[this.size])};Y().prototype.floor=function(){return this.throwIfDisposed(),bl(this)};Y().prototype.floorDiv=function(s){return this.throwIfDisposed(),Of(this,s)};Y().prototype.gather=function(s,t,e){return this.throwIfDisposed(),xl(this,s,t,e)};Y().prototype.greaterEqual=function(s){return this.throwIfDisposed(),zr(this,s)};Y().prototype.greater=function(s){return this.throwIfDisposed(),un(this,s)};Y().prototype.ifft=function(){return this.throwIfDisposed(),ia(this)};Y().prototype.irfft=function(){return this.throwIfDisposed(),em(this)};Y().prototype.isFinite=function(){return this.throwIfDisposed(),G0(this)};Y().prototype.isInf=function(){return this.throwIfDisposed(),j0(this)};Y().prototype.isNaN=function(){return this.throwIfDisposed(),H0(this)};Y().prototype.leakyRelu=function(s){return this.throwIfDisposed(),Pu(this,s)};Y().prototype.lessEqual=function(s){return this.throwIfDisposed(),Ti(this,s)};Y().prototype.less=function(s){return this.throwIfDisposed(),na(this,s)};Y().prototype.localResponseNormalization=function(s,t,e,n){return this.throwIfDisposed(),X0(this,s,t,e,n)};Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),q0(this)};Y().prototype.logSoftmax=function(s){return this.throwIfDisposed(),Wf(this,s)};Y().prototype.logSumExp=function(s,t){return this.throwIfDisposed(),Mu(this,s,t)};Y().prototype.log=function(){return this.throwIfDisposed(),Ln(this)};Y().prototype.log1p=function(){return this.throwIfDisposed(),Lu(this)};Y().prototype.logicalAnd=function(s){return this.throwIfDisposed(),Es(this,s)};Y().prototype.logicalNot=function(){return this.throwIfDisposed(),Bu(this)};Y().prototype.logicalOr=function(s){return this.throwIfDisposed(),Uf(this,s)};Y().prototype.logicalXor=function(s){return this.throwIfDisposed(),K0(this,s)};Y().prototype.matMul=function(s,t,e){return this.throwIfDisposed(),Ct(this,s,t,e)};Y().prototype.maxPool=function(s,t,e,n){return this.throwIfDisposed(),zu(this,s,t,e,n)};Y().prototype.max=function(s,t){return this.throwIfDisposed(),Jn(this,s,t)};Y().prototype.maximum=function(s){return this.throwIfDisposed(),ar(this,s)};Y().prototype.mean=function(s,t){return this.throwIfDisposed(),oe(this,s,t)};Y().prototype.min=function(s,t){return this.throwIfDisposed(),ea(this,s,t)};Y().prototype.minimum=function(s){return this.throwIfDisposed(),pi(this,s)};Y().prototype.mirrorPad=function(s,t){return this.throwIfDisposed(),Z0(this,s,t)};Y().prototype.mod=function(s){return this.throwIfDisposed(),J0(this,s)};Y().prototype.mul=function(s){return this.throwIfDisposed(),F(this,s)};Y().prototype.neg=function(){return this.throwIfDisposed(),Zt(this)};Y().prototype.norm=function(s,t,e){return this.throwIfDisposed(),yl(this,s,t,e)};Y().prototype.notEqual=function(s){return this.throwIfDisposed(),lo(this,s)};Y().prototype.oneHot=function(s,t=1,e=0){return this.throwIfDisposed(),co(this,s,t,e)};Y().prototype.onesLike=function(){return this.throwIfDisposed(),Mn(this)};Y().prototype.pad=function(s,t){return this.throwIfDisposed(),Vr(this,s,t)};Y().prototype.pool=function(s,t,e,n,r,i){return this.throwIfDisposed(),tb(this,s,t,e,n,r,i)};Y().prototype.pow=function(s){return this.throwIfDisposed(),nr(this,s)};Y().prototype.prelu=function(s){return this.throwIfDisposed(),Uu(this,s)};Y().prototype.prod=function(s,t){return this.throwIfDisposed(),eb(this,s,t)};Y().prototype.reciprocal=function(){return this.throwIfDisposed(),ib(this)};Y().prototype.relu=function(){return this.throwIfDisposed(),Fs(this)};Y().prototype.relu6=function(){return this.throwIfDisposed(),Xf(this)};Y().prototype.reshapeAs=function(s){return this.throwIfDisposed(),L(this,s.shape)};Y().prototype.reshape=function(s){return this.throwIfDisposed(),L(this,s)};Y().prototype.resizeBilinear=function(s,t,e){return this.throwIfDisposed(),xT(this,s,t,e)};Y().prototype.resizeNearestNeighbor=function(s,t,e){return this.throwIfDisposed(),wT(this,s,t,e)};Y().prototype.reverse=function(s){return this.throwIfDisposed(),Qn(this,s)};Y().prototype.rfft=function(){return this.throwIfDisposed(),qu(this)};Y().prototype.round=function(){return this.throwIfDisposed(),qf(this)};Y().prototype.rsqrt=function(){return this.throwIfDisposed(),Kf(this)};Y().prototype.selu=function(){return this.throwIfDisposed(),Yf(this)};Y().prototype.separableConv2d=function(s,t,e,n,r,i){return this.throwIfDisposed(),Zf(this,s,t,e,n,r,i)};Y().prototype.sigmoid=function(){return this.throwIfDisposed(),Zn(this)};Y().prototype.sign=function(){return this.throwIfDisposed(),ob(this)};Y().prototype.sin=function(){return this.throwIfDisposed(),Jf(this)};Y().prototype.sinh=function(){return this.throwIfDisposed(),Qf(this)};Y().prototype.slice=function(s,t){return this.throwIfDisposed(),Ot(this,s,t)};Y().prototype.softmax=function(s){return this.throwIfDisposed(),Hu(this,s)};Y().prototype.softplus=function(){return this.throwIfDisposed(),Co(this)};Y().prototype.spaceToBatchND=function(s,t){return this.throwIfDisposed(),Wu(this,s,t)};Y().prototype.split=function(s,t){return this.throwIfDisposed(),gn(this,s,t)};Y().prototype.sqrt=function(){return this.throwIfDisposed(),Me(this)};Y().prototype.square=function(){return this.throwIfDisposed(),jt(this)};Y().prototype.squaredDifference=function(s){return this.throwIfDisposed(),nm(this,s)};Y().prototype.squeeze=function(s){return this.throwIfDisposed(),En(this,s)};Y().prototype.stack=function(s,t){this.throwIfDisposed();const e=s instanceof Lt?[this,s]:[this,...s];return Sn(e,t)};Y().prototype.step=function(s){return this.throwIfDisposed(),To(this,s)};Y().prototype.stridedSlice=function(s,t,e,n,r,i,o,a){return this.throwIfDisposed(),ab(this,s,t,e,n,r,i,o,a)};Y().prototype.sub=function(s){return this.throwIfDisposed(),ct(this,s)};Y().prototype.sum=function(s,t){return this.throwIfDisposed(),ht(this,s,t)};Y().prototype.tan=function(){return this.throwIfDisposed(),lb(this)};Y().prototype.tanh=function(){return this.throwIfDisposed(),di(this)};Y().prototype.tile=function(s){return this.throwIfDisposed(),Xn(this,s)};Y().prototype.toBool=function(){return this.throwIfDisposed(),rt(this,"bool")};Y().prototype.toFloat=function(){return this.throwIfDisposed(),rt(this,"float32")};Y().prototype.toInt=function(){return this.throwIfDisposed(),rt(this,"int32")};Y().prototype.topk=function(s,t){return this.throwIfDisposed(),hb(this,s,t)};Y().prototype.transpose=function(s){return this.throwIfDisposed(),At(this,s)};Y().prototype.unique=function(s){return this.throwIfDisposed(),db(this,s)};Y().prototype.unsortedSegmentSum=function(s,t){return this.throwIfDisposed(),im(this,s,t)};Y().prototype.unstack=function(s){return this.throwIfDisposed(),ts(this,s)};Y().prototype.where=function(s,t){return this.throwIfDisposed(),Ge(s,this,t)};Y().prototype.zerosLike=function(){return this.throwIfDisposed(),Rt(this)};class Bs extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Bs.prototype)}}class ls extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ls.prototype)}}class M extends Error{constructor(t){super(t),Object.setPrototypeOf(this,M.prototype)}}class kt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,kt.prototype)}}class nx extends Error{constructor(t){super(t),Object.setPrototypeOf(this,nx.prototype)}}class Fk{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}}function po(s,t){if(Array.isArray(s)){let e=[];for(let n=0;n<t;n++)e=e.concat(s);return e}else{const e=new Array(t);return e.fill(s),e}}function zs(s,t){if(!s)throw new nx(t)}function Ev(s,t){let e=0;for(const n of s)n===t&&e++;return e}function fn(s){return s.length===1?s[0]:s}function zt(s){return Array.isArray(s)?s:[s]}function gr(s){const e=s.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Wi(s){return s.length<=1||s.indexOf("_")===-1?s:s.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let ss={};function sx(s){if(s==null)return null;const t={};return t.className=s.getClassName(),t.config=s.getConfig(),t}function yy(s){if(!(s==null||typeof s!="object"))if(Array.isArray(s))s.forEach(t=>yy(t));else{const t=Object.keys(s);for(const e of t){const n=s[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?s[e]=n.value:yy(n))}}}function Ju(s,t={},e={},n="object",r=!1){if(typeof s=="string"){const i=s;let o;if(i in e)o=e[i];else if(i in ss)o=ss[i];else if(o=t[i],o==null)throw new M(`Unknown ${n}: ${s}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=s;if(i.className==null||i.config==null)throw new M(`${n}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in ss?[a,l]=ss.className:o in t&&([a,l]=t[o]),a==null)throw new M(`Unknown ${n}: ${o}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const p of Object.keys(ss))c[p]=ss[p];for(const p of Object.keys(e))c[p]=e[p];const u=i.config;u.customObjects=c;const h=Object.assign({},ss);for(const p of Object.keys(e))ss[p]=e[p];yy(i.config);const d=l(a,i.config,e,r);return ss=Object.assign({},h),d}else{const c=Object.assign({},ss);for(const h of Object.keys(e))ss[h]=e[h];const u=new a(i.config);return ss=Object.assign({},c),u}}}function M4(s,t){return s<t?-1:s>t?1:0}function Kh(s,t){return-1*M4(s,t)}function ni(s){if(s==null)return s;const t=[];for(const e of s)t.indexOf(e)===-1&&t.push(e);return t}function B4(s){if(s==null)throw new M(`Invalid value in obj: ${JSON.stringify(s)}`);for(const t in s)if(s.hasOwnProperty(t))return!1;return!0}function Io(s,t,e){if(e!=null&&s.indexOf(e)<0)throw new M(`${e} is not a valid ${t}.  Valid values are ${s} or null/undefined.`)}function rx(s,t,e=0,n=1/0){return zs(e>=0),zs(n>=e),Array.isArray(s)&&s.length>=e&&s.length<=n&&s.every(r=>typeof r===t)}function Re(s,t){Array.isArray(s)?($(s.length>0,()=>`${t} is unexpectedly an empty array.`),s.forEach((e,n)=>Re(e,`element ${n+1} of ${t}`))):$(Number.isInteger(s)&&s>0,()=>`Expected ${t} to be a positive integer, but got ${Pk(s)}.`)}function Pk(s){return s===null?"null":Array.isArray(s)?"["+s.map(t=>Pk(t)).join(",")+"]":typeof s=="string"?`"${s}"`:`${s}`}function z4(s,t,e){let n=e!=null?e():en(),r;return(...o)=>{const a=e!=null?e():en();return a-n<t||(n=a,r=s(...o)),r}}function Lk(s){return s==="relu"?"relu":s==="linear"?"linear":s==="elu"?"elu":null}let V4=0;function Mk(){return V4++}const Yh={};function Sm(s=""){return s in Yh||(Yh[s]=0),Yh[s]+=1,s+Yh[s].toString()}const W4=["channelsFirst","channelsLast"],U4=["nearest","bilinear"],G4=["valid","same","causal"],j4=["max","avg"],H4=["sum","mul","concat","ave"];const Po=new Map;function ge(s){Io(W4,"DataFormat",s)}function X4(s){Io(U4,"InterpolationFormat",s)}function es(s){Io(G4,"PaddingMode",s)}function Bk(s){Io(j4,"PoolMode",s)}const Yl=[],Dv="/";function Qi(s,t){Yl.push(s);try{const e=t();return Yl.pop(),e}catch(e){throw Yl.pop(),e}}function q4(){return Yl.length===0?"":Yl.join(Dv)+Dv}function zk(s){if(!Wk(s))throw new Error("Not a valid tensor name: '"+s+"'");return q4()+s}function Vk(s){if(!Wk(s))throw new Error("Not a valid tensor name: '"+s+"'");Po.has(s)||Po.set(s,0);const t=Po.get(s);if(Po.set(s,Po.get(s)+1),t>0){const e=`${s}_${t}`;return Po.set(e,1),e}else return s}const K4=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Wk(s){return!!s.match(K4)}function Y4(s){return s===parseInt(s.toString(),10)}function si(s,t,e){t==null&&(t=0),e==null&&(e=s.length);let n=1;for(let r=t;r<e;++r)n*=s[r];return n}function oa(s){if(s.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<s.length;e++){const n=s[e];n<t&&(t=n)}return t}function fi(s){if(s.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<s.length;e++){const n=s[e];n>t&&(t=n)}return t}function Ds(s,t){if(t<s)throw new M(`end (${t}) < begin (${s}) is forbidden.`);const e=[];for(let n=s;n<t;++n)e.push(n);return e}let dg;function Ne(){return dg==null&&(dg=Af().epsilon()),dg}function As(){return"channelsLast"}function Zs(s,t){return rt(s,t)}function Qu(s,t=-1){const e=s.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),L(s,e)}function Z4(s,t){return W(()=>{if(s.shape.length!==2)throw new M(`repeat() expects a rank-2 tensor, but received a rank-${s.shape.length} tensor.`);const e=Qu(s,1);return by(e,[1,t,1])})}function J4(s){const t=[si(s.shape)];return L(s,t)}function Q4(s){if(s.rank<=1)throw new M(`batchFlatten requires a minimum rank of 2. Got rank: ${s.rank}.`);const t=[s.shape[0],si(s.shape,1)];return L(s,t)}function to(s,t,e){return W(()=>{switch(s.rank){case 1:return Gu(s,t,e);case 2:return tm(s,[t,0],[e,s.shape[1]]);case 3:return ju(s,[t,0,0],[e,s.shape[1],s.shape[2]]);case 4:return ra(s,[t,0,0,0],[e,s.shape[1],s.shape[2],s.shape[3]]);case 5:return Ot(s,[t,0,0,0,0],[e,s.shape[1],s.shape[2],s.shape[3],s.shape[4]]);case 6:return Ot(s,[t,0,0,0,0,0],[e,s.shape[1],s.shape[2],s.shape[3],s.shape[4],s.shape[5]]);default:throw new M(`sliceAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}})}function pg(s,t,e){return W(()=>{switch(s.rank){case 1:return Gu(s,t,e);case 2:return tm(s,[0,t],[s.shape[0],e]);case 3:return ju(s,[0,0,t],[s.shape[0],s.shape[1],e]);case 4:return ra(s,[0,0,0,t],[s.shape[0],s.shape[1],s.shape[2],e]);default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function Zh(s,t,e,n){return W(()=>{switch(s.rank){case 1:return Gu(s,t,e);case 2:switch(n){case 1:return to(s,t,e);case 2:return pg(s,t,e);default:throw new M(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return to(s,t,e);case 2:return ju(s,[0,t,0],[s.shape[0],e,s.shape[2]]);case 3:return pg(s,t,e);default:throw new M(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return to(s,t,e);case 2:return ra(s,[0,t,0,0],[s.shape[0],e,s.shape[2],s.shape[3]]);case 3:return ra(s,[0,0,t,0],[s.shape[0],s.shape[1],e,s.shape[3]]);case 4:return pg(s,t,e);default:throw new M(`The axis is not within the rank of the tensor ${n}`)}default:throw new M(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function ix(s,t=-1){let e;return t<0&&(e=s[0].rank,e!==0?t=e:t=0),t===s[0].rank&&(t=-1),pe(s,t)}function Av(s,t){switch(s.rank){case 1:return E0([s,t]);case 2:return D0([s,t],0);case 3:return A0([s,t],0);case 4:return O0([s,t],0);default:throw new M(`concatAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}}function by(s,t){if(Array.isArray(t)||(t=[t]),s.rank!==t.length)throw new M(`The length of input n (${t.length}) does not match the number of dimensions in input x (${s.rank})`);return Xn(s,t)}function Cm(s,t=0,e=1,n,r){return Hf(s,t,e,n,r)}function Js(s,t,e,n){if(s.rank<2||t.rank<2)throw new kt(`dot requires both inputs to be rank >= 2 but got x shape = ${s.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=s.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new kt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${s.shape} and  y shape = ${t.shape}`)}if(s.rank===2&&t.rank===2)return ty({a:s,b:t,transposeA:!1,transposeB:!1,bias:n?xy(s.rank,n,As()):null,activation:e});{const r=s.shape.slice(),i=r.pop();s=L(s,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=L(At(t,u),[l,-1]);const h=[...r,...c];return L(ty({a:s,b:t,transposeA:!1,transposeB:!1,bias:n?xy(s.rank,n,As()):null,activation:e}),h)}}function Uk(s,t,e){return W(()=>(Array.isArray(t)?t=Je(t,"int32"):t=rt(t,"int32"),xl(s,t,e)))}function th(s){return F(s,s)}function xy(s,t,e){const n=t.shape;if(t.rank!==1&&t.rank!==s)throw new M(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${s}`);if(s===5){if(e==="channelsFirst")return n.length===1?L(t,[1,n[0],1,1,1]):L(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?L(t,[1,1,1,1,n[0]]):L(t,[1].concat(n))}else if(s===4){if(e==="channelsFirst")return n.length===1?L(t,[1,n[0],1,1]):L(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?L(t,[1,1,1,n[0]]):L(t,[1].concat(n))}else if(s===3){if(e==="channelsFirst")return n.length===1?L(t,[1,n[0],1]):L(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?L(t,[1,1,n[0]]):L(t,[1].concat(n))}else if(s<3)return t;throw new M(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ps(s,t,e){return W(()=>(e==null&&(e=As()),ge(e),tt(s,xy(s.rank,t,e))))}function tU(s,t=1){if(t!==1)throw new kt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return gl(s)}function eU(s){return W(()=>ft(s,tt(be(s),1)))}function Gk(s,t,e,n){return W(()=>mb(s,t,e,n))}function nU(s){return W(()=>{const t=tt(.5,F(.2,s));return wn(t,0,1)})}function eh(s,t,e=!1){return e?s():t()}const sU=["fanIn","fanOut","fanAvg"],rU=["normal","uniform","truncatedNormal"];function iU(s){Io(sU,"FanMode",s)}function oU(s){Io(rU,"Distribution",s)}class ps extends ko{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class jk extends ps{apply(t,e){return ve(t,e)}}jk.className="Zeros";nt(jk);class ox extends ps{apply(t,e){return mn(t,e)}}ox.className="Ones";nt(ox);class Hk extends ps{constructor(t){if(super(),typeof t!="object")throw new M(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new M(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return W(()=>F(gt(this.value),mn(t,e)))}getConfig(){return{value:this.value}}}Hk.className="Constant";nt(Hk);class Xk extends ps{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ki(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Xk.className="RandomUniform";nt(Xk);class qk extends ps{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new kt(`randomNormal does not support dType ${e}.`);return Cm(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qk.className="RandomNormal";nt(qk);class Kk extends ps{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new kt(`truncatedNormal does not support dType ${e}.`);return rm(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Kk.className="TruncatedNormal";nt(Kk);class Yk extends ps{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return W(()=>{if(t.length!==2||t[0]!==t[1])throw new M("Identity matrix initializer can only be used for 2D square matrices.");return F(this.gain,zf(t[0]))})}getConfig(){return{gain:this.gain}}}Yk.className="Identity";nt(Yk);function aU(s,t="channelsLast"){let e,n;if(ge(t),s.length===2)e=s[0],n=s[1];else if([3,4,5].indexOf(s.length)!==-1){if(t==="channelsFirst"){const r=si(s,2);e=s[1]*r,n=s[0]*r}else if(t==="channelsLast"){const r=si(s,0,s.length-2);e=s[s.length-2]*r,n=s[s.length-1]*r}}else{const r=si(s);e=Math.sqrt(r),n=Math.sqrt(r)}return[e,n]}class Bn extends ps{constructor(t){if(super(),t.scale<0)throw new M(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,iU(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,oU(this.distribution),this.seed=t.seed}apply(t,e){const n=aU(t),r=n[0],i=n[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new kt(`${this.getClassName()} does not support dType ${e}.`);return rm(t,0,a,e,this.seed)}else{const a=Math.sqrt(3*o);return ki(t,-a,a,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Bn.className="VarianceScaling";nt(Bn);class ax extends Bn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}ax.className="GlorotUniform";nt(ax);class lx extends Bn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}lx.className="GlorotNormal";nt(lx);class cx extends Bn{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}cx.className="HeNormal";nt(cx);class ux extends Bn{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}ux.className="HeUniform";nt(ux);class hx extends Bn{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}hx.className="LeCunNormal";nt(hx);class dx extends Bn{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Bn.className}}dx.className="LeCunUniform";nt(dx);class Zk extends ps{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return W(()=>{if(t.length<2)throw new kt("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const n=K(t.slice(0,-1)),r=t[t.length-1],i=n*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,n),Math.min(r,n)],a=Cm(o,0,1,e,this.seed),l=xb.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return c=F(c,h.sign()),n<r&&(c=c.transpose()),F(gt(this.gain),c.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Zk.className="Orthogonal";nt(Zk);const Ov={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Rv(s,t={}){return Ju(s,Hn.getMap().classNameMap,t,"initializer")}function ae(s){return sx(s)}function ee(s){if(typeof s=="string"){const t=s in Ov?Ov[s]:s;if(t==="GlorotNormal")return new lx;if(t==="GlorotUniform")return new ax;if(t==="HeNormal")return new cx;if(t==="HeUniform")return new ux;if(t==="LeCunNormal")return new hx;if(t==="LeCunUniform")return new dx;{const e={};return e.className=t,e.config={},Rv(e)}}else return s instanceof ps?s:Rv(s)}function wy(s){return Array.isArray(s)&&Array.isArray(s[0])}function Hd(s){return s.length===0?[]:Array.isArray(s[0])?s:[s]}function vt(s){let t;if(Array.isArray(s)){if(s.length!==1)throw new M(`Expected Tensor length to be 1; got ${s.length}`);t=s[0]}else t=s;return t}function Pt(s){if(Array.isArray(s)&&Array.isArray(s[0])){if(s.length===1)return s=s,s[0];throw new M(`Expected exactly 1 Shape; got ${s.length}`)}else return s}function Xd(s){let t=0;for(const e of s)e.shape.length===0?t+=1:t+=e.shape.reduce((n,r)=>n*r);return t}const Fv="Variable";class lU{constructor(t,e="float32",n=Fv,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Mk(),n=n??Fv,this.originalName=zk(n),this.name=Vk(this.originalName),this.trainable_=r,this.constraint=i,this.val=pb(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),cU(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function cU(s,t){if(s.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(s.shape)+" vs. "+JSON.stringify(t.shape))}function vy(s){return s.map(t=>t.read())}function px(s){s.forEach(t=>{t[0].write(t[1])})}class $e{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class rr{constructor(t,e,n,r,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=Mk(),o!=null&&(this.originalName=zk(o),this.name=Vk(this.originalName)),this.rank=e.length}}let uU=0;class Tm{constructor(t,e){this.callArgs=e,this.id=uU++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)n?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hU=0;class _t extends ko{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hU++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const n=this.getClassName();e=gr(n)+"_"+Sm(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),n=[i].concat(t.inputShape)}this.batchInputShape=n;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new ls(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new M(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return fn(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return fn(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Bs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Bs(`Layer ${this.name} is not connected, no input to return.`);return fn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Bs(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Bs(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return fn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=zt(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const n=zt(this.inputSpec);if(e.length!==n.length)throw new M(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){const i=e[r],o=n[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new M(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],d=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(d)===-1)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=i.shape[l];if(c!=null&&u!=null&&c!==u)throw new M(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=zt(t),r=fU(t),i=mU(t);if(r===i)throw new M("Arguments to apply() must be all SymbolicTensors or all Tensors");return Qi(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of zt(t))o.push(a.shape);this.build(fn(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const a=zt(o),l=[];for(let c of a)n.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=fn(l),this.activityRegularizer!=null)throw new kt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=dU(t),a=this.computeOutputShape(o);let l;const c=pU(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new rr(c,u,this,zt(t),e,this.name,h)):l=new rr(c,a,this,zt(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,this.activityRegularizer!=null)throw new kt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&t[r]!=null&&t[r]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Bs(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Bs(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ls(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Xd(this.weights)}build(t){this.built=!0}getWeights(t=!1){return vy(t?this.trainableWeights:this.weights)}setWeights(t){W(()=>{const e=this.weights;if(e.length!==t.length)throw new M(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const n=[],r=vy(e);for(let i=0;i<r.length;++i){const o=r[i],a=e[i],l=t[i];if(!Dt(o.shape,l.shape))throw new M(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);n.push([a,l])}px(n)})}addWeight(t,e,n,r,i,o,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new M(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():ee("zeros"));const c=r.apply(e,n),u=new lU(c,n,t,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=zt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const r=this.computeMask(t,n),i=zt(e),o=zt(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(t,e,n,r,i,o,a=null){const l=zt(t);e=zt(e),n=zt(n),r=zt(r),i=Hd(i),o=Hd(o);const c=[],u=[],h=[];for(const d of l)c.push(d.sourceLayer),u.push(d.nodeIndex),h.push(d.tensorIndex);new Tm({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let d=0;d<e.length;d++)e[d].sourceLayer=this,e[d].nodeIndex=this.inboundNodes.length-1,e[d].tensorIndex=d}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function dU(s){s=zt(s);const t=[];for(const e of s)t.push(e.shape);return fn(t)}function pU(s){return"float32"}function Jk(s,t,e){if((t==null||e!=null&&e>0)&&(t=s.sourceLayer,e=s.nodeIndex),t.inboundNodes.length===0)return[s];{const n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{const r=[];for(let i=0;i<n.inboundLayers.length;i++){const o=n.inputTensors[i],a=n.inboundLayers[i],l=n.nodeIndices[i],c=Jk(o,a,l);for(const u of c)r.indexOf(u)===-1&&r.push(u)}return r}}}function fU(s){let t=!0;for(const e of zt(s))if(!(e instanceof rr)){t=!1;break}return t}function mU(s){let t=!0;for(const e of zt(s))if(e instanceof rr){t=!1;break}return t}class nh extends _t{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:Sm("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new M("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new M("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new M("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new rr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Tm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new M(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}nh.className="InputLayer";nt(nh);function gU(s){if(s.batchShape==null&&s.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(s.batchShape!=null&&s.shape!=null)throw new M("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=s.batchShape;s.shape!=null&&t==null&&(t=[null].concat(s.shape));let e=s.dtype;return e==null&&(e="float32"),new nh({batchInputShape:t,name:s.name,dtype:e,sparse:s.sparse}).inboundNodes[0].outputTensors[0]}function yU(s,t){if(s.dtype==null||s.dtype===t.dtype)return t;try{return rt(t,s.dtype)}catch{throw new M(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${s.name}' (${s.dtype}).`)}}class Qr{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Qr)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=yU(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new M(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof rr){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof rr){if(this.id2Value[t.id]==null)throw new M(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new M(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Nt(this.id2Mask)}}const qd=new Fk,Kd=new Fk;function bU(s){qd?.setMaxEntries(s),Kd?.setMaxEntries(s)}function Wl(s,t,e,n){const r=e==null?!1:e.training,i=Array.isArray(s),o=i?s:[s],a=o.map(f=>f.name),l=[],c=t.names();for(const f of a)c.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);const u=a.join(",")+"|"+t.names().sort().join(",");let h=qd.get(u),d;if(h==null){const f=xU(o,t);h=f.sorted,d=f.recipientCounts,qd.put(u,h),Kd.put(u,d)}d={},r||Object.assign(d,Kd.get(u));const p=new Qr(t);for(let f=0;f<h.length;++f){const m=h[f],g=m.sourceLayer;if(g instanceof nh)continue;const y=[],b=[],w=[];let x=!1;for(const N of m.inputs){const _=p.getValue(N),T=p.getMask(N);y.push(_),b.push(T),T!=null&&(x=!0),r||(d[N.name]--,d[N.name]===0&&!t.hasKey(N)&&a.indexOf(N.name)===-1&&!_.isDisposed&&N.sourceLayer.stateful!==!0&&w.push(_))}x&&(e=e||{},e.mask=b[0]);const v=zt(g.apply(y,e));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const k=vU(m),I=Array.isArray(k)?k:[k];for(let N=0;N<I.length;++N){p.hasKey(I[N])||p.add(I[N],v[N],Array.isArray(C)?C[0]:C);const _=a.indexOf(I[N].name);_!==-1&&(l[_]=v[N])}r||Nt(w)}return p.disposeMasks(),i?l:l[0]}function xU(s,t){$(s!=null&&s.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(s.length===1){const r=Pv(s[0],t);e=r.sorted,n=r.recipientMap}else{const r=new Set;for(const i of s){const{sorted:o,recipientMap:a}=Pv(i,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in a)n[l]==null&&(n[l]=new Set),a[l].forEach(c=>n[l].add(c))}}return{sorted:e,recipientCounts:wU(n)}}function wU(s){const t={};for(const e in s)t[e]=s[e].size;return t}function Pv(s,t){const e=new Set,n=[],r={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(s);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),n.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:n,recipientMap:r}}function vU(s){let t;if(s.sourceLayer.inboundNodes.length===1)t=s.sourceLayer.output;else{let e=null;for(let n=0;n<s.sourceLayer.inboundNodes.length;++n)for(const r of s.sourceLayer.inboundNodes[n].outputTensors)if(r.id===s.id){e=n;break}t=s.sourceLayer.getOutputAt(e)}return t}const SU=j();SU.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,bU);function fx(s,t){return W(()=>Me(ht(F(s,s),t,!0)))}class sh extends ko{getConfig(){return{}}}class Qk extends sh{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return W(()=>{const e=fx(t,this.axis),n=wn(e,0,this.maxValue);return F(t,ft(n,tt(Ne(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Qk.className="MaxNorm";nt(Qk);class tI extends sh{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return W(()=>ft(t,tt(Ne(),fx(t,this.axis))))}getConfig(){return{axis:this.axis}}}tI.className="UnitNorm";nt(tI);class eI extends sh{apply(t){return Fs(t)}}eI.className="NonNeg";nt(eI);class nI extends sh{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return W(()=>{const e=fx(t,this.axis),n=tt(F(this.rate,wn(e,this.minValue,this.maxValue)),F(1-this.rate,e));return F(t,ft(n,tt(Ne(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}nI.className="MinMaxNorm";nt(nI);const Lv={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _e(s){return sx(s)}function Mv(s,t={}){return Ju(s,Hn.getMap().classNameMap,t,"constraint")}function Ee(s){if(s==null)return null;if(typeof s=="string"){const e={className:s in Lv?Lv[s]:s,config:{}};return Mv(e)}else return s instanceof sh?s:Mv(s)}async function Ai(s){if(s==null)return;const t=[],e=[],n=[];for(const r in s){const i=s[r];if(typeof i!="number"){const o=i;t.push(o.data()),e.push(r),n.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)s[e[i]]=r[i][0];Nt(n)}}function sI(s){if(s!=null)for(const t in s){const e=s[t];typeof e!="number"&&e.dispose()}}var Bv;(function(s){s[s.SILENT=0]="SILENT",s[s.VERBOSE=1]="VERBOSE"})(Bv||(Bv={}));const CU=125;class mc{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class TU{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class kU extends mc{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const n=e.size==null?0:e.size;this.seen+=n;for(const r in e){const i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*n;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=W(()=>tt(this.totals[r],F(i,n)));this.totals[r]=a,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:W(()=>{const r=F(ft(1,this.seen),this.totals[n]);e[n]=r,this.totals[n].dispose(),Ie(e[n])}))}}class IU extends mc{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];t.push(l.data()),e.push(i),n.push(a)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][n[i]].dispose(),this.history[e[i]][n[i]]=r[i][0]}}class NU extends mc{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Rb,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=CU),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Pd(this.yieldEvery)&&(this.maybeWait=z4(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];this.yield!=null&&(await Ai(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ai(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];this.epochEnd!=null&&(await Ai(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ai(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];this.batchEnd!=null&&(await Ai(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):Pd(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await Ai(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ai(t),await this.trainEnd(t))}}function rI(s,t){return s==null&&(s={}),s instanceof mc?[s]:Array.isArray(s)&&s[0]instanceof mc?s:zt(s).map(n=>new NU(n,t))}class is{constructor(){}static registerCallbackConstructor(t,e){$(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),is.checkForDuplicate(e),is.constructors[t]==null&&(is.constructors[t]=[]),is.constructors[t].push(e)}static checkForDuplicate(t){for(const e in is.constructors)is.constructors[+e].forEach(r=>{if(r===t)throw new M("Duplicate callback constructor.")})}static clear(){is.constructors={}}static createCallbacks(t){const e=[];for(const n in is.constructors){const r=+n;t>=r&&e.push(...is.constructors[r])}return e.map(n=>new n)}}is.constructors={};function iI(s,t,e,n,r,i,o,a,l){const c=new IU,u=[new kU,...is.createCallbacks(t)];s!=null&&u.push(...s),u.push(c);const h=new TU(u);return h.setParams({epochs:e,initialEpoch:n,samples:r,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:h,history:c}}function Cr(s,t={},e=!1){return Ju(s,Hn.getMap().classNameMap,t,"layer",e)}function Yd(s,t){return W(()=>{s.dtype!=="float32"&&(s=rt(s,"float32"));const e=ht(th(s),t,!0),n=So(e.shape,Ne()),r=Me(ar(e,n));return ft(s,r)})}function km(s,t){return W(()=>oe(th(ct(t,s)),-1))}function mx(s,t){return W(()=>oe(be(ct(t,s)),-1))}function gx(s,t){return W(()=>{const e=ct(s,t),n=wn(be(s),Ne(),Number.MAX_VALUE),r=be(ft(e,n));return F(100,oe(r,-1))})}function $U(s,t){return W(()=>{const e=wn(t,Ne(),Number.MAX_VALUE),n=Ln(tt(1,e)),r=wn(s,Ne(),Number.MAX_VALUE),i=Ln(tt(1,r));return oe(th(ct(n,i)),-1)})}function _U(s,t){return W(()=>{const e=ar(0,ct(1,F(s,t)));return oe(th(e),-1)})}function EU(s,t){return W(()=>{const e=ar(0,ct(1,F(s,t)));return oe(e,-1)})}function DU(s,t){return W(()=>{const e=ht(F(s,t),-1),n=Jn(F(ct(1,s),t),-1);return ar(0,tt(1,ct(n,e)))})}function AU(s,t){return W(()=>{const e=Math.log(2),n=ct(t,s),r=ct(tt(n,Co(F(-2,n))),e);return oe(r,-1)})}function gc(s,t,e=!1){return W(()=>{if(e)t=Hu(t);else{const n=ht(t,t.shape.length-1,!0);t=ft(t,n)}return t=wn(t,Ne(),1-Ne()),Zt(ht(F(rt(s,"float32"),Ln(t)),t.shape.length-1))})}function Zd(s,t,e=!1){return W(()=>{const n=rt(bl(J4(s)),"int32");t=wn(t,Ne(),1-Ne());const r=t.shape,i=L(co(n,r[r.length-1]),r);return gc(i,t,e)})}function OU(s,t){if(!Dt(s.shape,t.shape))throw new M(`logits and labels must have the same shape, but got shapes ${JSON.stringify(s.shape)} and ${JSON.stringify(t.shape)}`);return W(()=>{const e=Fs(t),n=Zt(be(t));return tt(ct(e,F(t,s)),Lu(vn(n)))})}function Im(s,t){return W(()=>{let e;return e=wn(t,Ne(),1-Ne()),e=Ln(ft(e,ct(1,e))),oe(OU(s,e),-1)})}function RU(s,t){return W(()=>{const e=wn(s,Ne(),1),n=wn(t,Ne(),1);return ht(F(s,Ln(ft(e,n))),-1)})}function FU(s,t){return W(()=>{const e=Ln(tt(Ne(),t));return oe(ct(t,F(s,e)),-1)})}function oI(s,t){return W(()=>{const e=Yd(s,-1),n=Yd(t,-1),r=F(e,n);return Zt(ht(r,-1))})}const Jd={meanSquaredError:km,meanAbsoluteError:mx,meanAbsolutePercentageError:gx,meanSquaredLogarithmicError:$U,squaredHinge:_U,hinge:EU,categoricalHinge:DU,logcosh:AU,categoricalCrossentropy:gc,sparseCategoricalCrossentropy:Zd,binaryCrossentropy:Im,kullbackLeiblerDivergence:RU,poisson:FU,cosineProximity:oI};function fg(s){if(typeof s=="string"){if(s in Jd)return Jd[s];let t=`Unknown loss ${s}`;throw s.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${s}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new M(t)}else return s}function aI(s,t){return W(()=>{const e=F(.5,Mn(t)),n=Zs(un(t,e),s.dtype);return oe(Pn(s,n),-1)})}function lI(s,t){return W(()=>Zs(Pn(ui(s,-1),ui(t,-1)),"float32"))}function PU(s,t){return W(()=>rt(ht(Es(Pn(s,1),Pn(t,1))),"float32"))}function LU(s,t){return W(()=>rt(ht(Es(Pn(s,0),Pn(t,1))),"float32"))}function MU(s,t){return W(()=>{const e=PU(s,t),n=LU(s,t),r=tt(e,n);return rt(Ge(un(r,0),ft(e,r),0),"float32")})}function BU(s,t){return Im(s,t)}function zU(s,t){return s.rank===t.rank&&(s=En(s,[s.rank-1])),t=ui(t,-1),t.dtype!==s.dtype&&(t=rt(t,s.dtype)),rt(Pn(s,t),"float32")}const VU=km,WU=km,UU=mx,GU=mx,jU=gx,HU=gx,cI=gc,XU=oI,uI=Zd,Qd={binaryAccuracy:aI,categoricalAccuracy:lI,precision:MU,categoricalCrossentropy:cI,sparseCategoricalCrossentropy:uI,mse:VU,MSE:WU,mae:UU,MAE:GU,mape:jU,MAPE:HU,cosine:XU};function qU(s){if(typeof s=="string"&&s in Qd)return Qd[s];if(typeof s!="string"&&s!=null)return s;throw new M(`Unknown metric ${s}`)}function Jh(s){if(zs(s!==null,`Unknown LossOrMetricFn ${s}`),typeof s=="string")return s;{let t;for(const e of Object.keys(Jd))if(Jd[e]===s){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(Qd))if(Qd[e]===s){t=e;break}return t!==void 0?t:s.name}}function KU(s){const t={Adagrad:()=>Fi.adagrad(.01),Adadelta:()=>Fi.adadelta(1,.95,Ne()),Adam:()=>Fi.adam(.001,.9,.999,Ne()),Adamax:()=>Fi.adamax(.002,.9,.999,Ne(),0),RMSProp:()=>Fi.rmsprop(.001,.9,0,Ne()),SGD:()=>Fi.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,s in t)return t[s]();throw new M(`Unknown Optimizer ${s}`)}const zv=1*1024*1024;function Vv(s,t,e=!1){if(s==null||typeof s!="object"||Object.getPrototypeOf(s)!==Object.prototype||!Sy(s))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const n=JSON.stringify(s);n.length>zv&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${zv}.`)}}function Sy(s){if(s===null)return!0;if(typeof s=="object")if(Object.getPrototypeOf(s)===Object.prototype){const t=Object.keys(s);for(const e of t)if(typeof e!="string"||!Sy(s[e]))return!1;return!0}else if(Array.isArray(s)){for(const t of s)if(!Sy(t))return!1;return!0}else return!1;else{const t=typeof s;return t==="string"||t==="number"||t==="boolean"}}function YU(s,t,e,n=console.log){const r=JU(s),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u)));let o;if(!r){i.push("Receives inputs"),o=[];for(const u in s.nodesByDepth)o.push(...s.nodesByDepth[u])}n("_".repeat(t)),tp(i,e,n),n("=".repeat(t));const a=s.layers;for(let u=0;u<a.length;++u)r?QU(a[u],e,n):tG(a[u],e,o,n),n((u===a.length-1?"=":"_").repeat(t));s.checkTrainableWeightsConsistency();const l=ZU(s),c=Xd(s.nonTrainableWeights);n(`Total params: ${l+c}`),n(`Trainable params: ${l}`),n(`Non-trainable params: ${c}`),n("_".repeat(t))}function ZU(s){let t;return s.collectedTrainableWeights!=null?t=Xd(s.collectedTrainableWeights):t=Xd(s.trainableWeights),t}function JU(s){let t=!0;const e=[],n=[];for(const r in s.nodesByDepth)e.push(s.nodesByDepth[r]);for(const r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}n.push(...r)}if(t)for(const r of s.layers){let i=!1;for(const o of r.inboundNodes)if(n.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function tp(s,t,e=console.log){let n="";for(let r=0;r<s.length;++r)r>0&&(n=n.slice(0,n.length-1)+" "),n+=s[r],n=n.slice(0,t[r]),n+=" ".repeat(t[r]-n.length);e(n)}function QU(s,t,e){let n,r;try{r=s.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{n=JSON.stringify(s.outputShape)}catch{n="multiple"}const i=s.name,o=s.getClassName(),a=[`${i} (${o})`,r,n,s.countParams().toString()];tp(a,t,e)}function tG(s,t,e,n){let r,i;try{i=s.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(s.outputShape)}catch{r="multiple"}const o=[];for(const h of s.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];o.push(`${p}[${f}][${m}]`)}const a=s.name,l=s.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,i,r,s.countParams().toString(),c];tp(u,t,n);for(let h=1;h<o.length;++h)tp(["","","","",o[h]],t,n)}function hI(s,t,e){return(s==="inboundNodes"||s==="outputLayers"||s==="inputLayers")&&t===0&&typeof e=="string"}function Cy(s,t){if(s===null)return null;if(typeof s=="string")return Wi(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const e=[],n=s.length;for(let r=0;r<n;++r){const i=s[r];hI(t,r,i)?e.push(i):e.push(Cy(i,t))}return e}else{const e={};for(const n of Object.keys(s)){const r=s[n];if(n==="name"&&typeof r=="string")e[n]=r;else{const i=Wi(n);e[i]=Cy(r,i)}}return e}}function Ty(s,t){if(s==null)return null;if(typeof s=="string")return gr(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const e=[],n=s.length;for(let r=0;r<n;++r){const i=s[r];hI(t,r,i)?e.push(i):e.push(Ty(i,t))}return e}else{const e={};for(const n of Object.keys(s)){const r=s[n],i=gr(n);(n==="name"||n==="className")&&typeof r=="string"?e[i]=r:e[i]=Ty(r,n)}return e}}const dI="4.22.0";const eG=s=>{const t=Object.keys(s);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class xs extends _t{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=Sm(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ni(this.inputs).length!==this.inputs.length)throw new M(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);ni(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const w=b.sourceLayer,x=b.nodeIndex,v=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(v)}for(const b of this.inputs){const w=b.sourceLayer,x=b.nodeIndex,v=b.tensorIndex;zs(x===0,"input layer has >1 nodes"),zs(v===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const w=this.inputLayers[b];if(!(w instanceof nh))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},n={},r={},i={},o={},a=[],l=(b,w,x,v,C,k)=>{(v==null||C==null||k==null)&&(v=b.sourceLayer,C=b.nodeIndex,k=b.tensorIndex);const I=v.inboundNodes[C];if(x.indexOf(I)!==-1)throw new ls(`The tensor ${b.name} at layer "${v.name}" is part of a cycle.`);if(w.indexOf(I)!==-1)return;this.containerNodes.add(xs.nodeKey(v,C)),v.id in o||(o[v.id]=Object.keys(o).length),x.indexOf(I)===-1&&x.push(I);const N=I.inboundLayers.length;for(let _=0;_<N;_++){const T=I.inputTensors[_],D=I.inboundLayers[_],R=I.nodeIndices[_],P=I.tensorIndices[_];l(T,w,x,D,R,P)}for(w.push(I);x.indexOf(I)>=0;)x.splice(x.indexOf(I),1);a.push(I)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=a.slice().reverse();for(const b of h){n[b.id]=b,b.id in e||(e[b.id]=0);let w=e[b.id];const x=r[b.outboundLayer.id]==null?0:r[b.outboundLayer.id];w=Math.max(w,x),r[b.outboundLayer.id]=w,i[b.outboundLayer.id]=b.outboundLayer,e[b.id]=w;for(let v=0;v<b.inboundLayers.length;v++){const C=b.inboundLayers[v],k=b.nodeIndices[v],I=C.inboundNodes[k],N=e[I.id]==null?0:e[I.id];e[I.id]=Math.max(w+1,N),n[I.id]=I}}const d={};for(const b in e){const w=e[b];w in d||(d[w]=[]),d[w].push(n[b])}const p={};for(const b in r){const w=r[b];w in p||(p[w]=[]),p[w].push(i[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Kh);this.layers=[];for(const b of f){const w=p[b];w.sort((x,v)=>{const C=o[x.id],k=o[v.id];return C<k?-1:C>k?1:0});for(const x of w)x instanceof xs&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(d).map(b=>parseInt(b,10)).sort(Kh);const m=this.inputs.slice(),g=[];for(const b of f)for(const w of d[b]){const x=w.outboundLayer;if(x!=null){for(const v of w.inputTensors)if(m.indexOf(v)===-1)throw new ls(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${x.name}". The following previous layers were accessed without issue: ${g}`);for(const v of w.outputTensors)m.push(v);g.push(x.name)}}this.nodesByDepth=d;const y=this.layers.map(b=>b.name);for(const b of y){const w=y.filter(x=>x===b).length;if(w!==1)throw new ls(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Tm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new M("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;const i=eG(t);i&&this.parseWeights(t);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(n[u]!=null)throw new M(`Duplicate weight name: ${u}`);n[u]=c,r++}const o=[];for(const a in t){let l=a;if(n[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(n[l]!=null)o.push([n[l],t[a]]);else if(e)throw new M(`Provided weight data has no target variable: ${a}`);delete n[l]}if(e){const a=[];for(const l in n)a.push(l);if(a.length>0)throw new M(`${a.length} of ${r} weights are not set: ${a}`)}px(o)}parseWeights(t){for(const e in Object.keys(t)){const n=e.split("/"),r=["vars","layer_checkpoint_dependencies"],i=n.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==e&&(t[i]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${dI}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=Ty(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return W(()=>{t=zt(t);const n=new Qr;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],t[r]);return Wl(this.outputs,n,e)})}computeMask(t,e){return W(()=>{t=zt(t);let n;return e==null?n=po(null,t.length):n=zt(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=Hd(t);if(e.length!==this.inputLayers.length)throw new M(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<e.length;a++){const l=this.inputLayers[a],c=e[a],u=l.name+"_0_0";n[u]=c}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Kh);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;const h=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],w=`${g.name}_${y}_${b}`,x=n[w];h.push(x)}const d=u.computeOutputShape(fn(h)),p=Hd(d),f=u.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){const g=`${u.name}_${f}_${m}`;n[g]=p[m]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];zs(l in n),i.push(n[l])}return fn(i)}runInternalGraph(t,e){e==null&&(e=po(null,t.length));const n={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=t[l],h=e[l];n[c.id]=[u,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Kh);for(const l of r){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(const m of d)m.id in n&&f.push(n[m.id]);if(f.length===d.length){let m={},g,y,b,w;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){const[x,v]=f[0];m.mask==null&&(m.mask=v),b=zt(h.call(x,m)),w=zt(h.computeMask(x,v)),g=[x],y=[v]}else g=f.map(x=>x[0]),y=f.map(x=>x[1]),m.mask==null&&(m.mask=y),b=zt(h.call(g,m)),w=zt(h.computeMask(g,y));if(h.activityRegularizer)throw new kt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x){const v=p[x],C=b[x],k=w[x];n[v.id]=[C,k]}}}}const i=[],o=[],a=[];for(const l of this.outputs){zs(l.id in n,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=n[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof xs?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=xs.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=n,n+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new M("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const n of this.layers)if(n.name===t)return n;throw new M(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new M(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return W(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=xs.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],p=xs.nodeKey(o,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const m=[];for(let g=0;g<d.inboundLayers.length;g++){const y=d.inboundLayers[g],b=d.nodeIndices[g],w=d.tensorIndices[g],x=xs.nodeKey(y,b);let v=e[x];v==null&&(v=0),m.push([y.name,v,w,f])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,n.push(u)}t.layers=n;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=xs.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];r.push([a.name,u,h])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=xs.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,u,h])}return t.outputLayers=i,t}static fromConfig(t,e,n={},r=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let w;for(const x of y){const v=x[0],C=x[1],k=x[2];if(w=x[3]==null?{}:x[3],!(v in i)){a(g,y);return}const I=i[v];if(I.inboundNodes.length<=C){a(g,y);return}const N=I.inboundNodes[C];b.push(N.outputTensors[k])}b.length>0&&g.apply(fn(b),w)}function c(g){const y=g.name,b=Cr(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(r),i[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new M(`Corrupted configuration, expected array for nodeData: ${x}`);a(b,x)})}const u=e.name,h=e.layers;for(const g of h)c(g);for(;!B4(o);)for(const g of h){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const w of b)l(y,w)}}const d=[],p=[],f=e.inputLayers;for(const g of f){const y=g[0],b=g[1],w=g[2];zs(y in i);const v=i[y].inboundNodes[b].outputTensors;d.push(v[w])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],w=g[2];zs(y in i);const v=i[y].inboundNodes[b].outputTensors;p.push(v[w])}return new t({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new M("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){W(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function nG(s,t,e){const n=t.length;if(s==null||Array.isArray(s)&&s.length===0)return t.map(r=>null);if(n===1)return Array.isArray(s)&&s.length===1?s:typeof s=="object"&&t[0]in s?[s[t[0]]]:[s];if(Array.isArray(s)){if(s.length!==n)throw new Error(`Provided ${e} is an array of ${s.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return s}else if(typeof s=="object"&&Object.keys(s).length>0&&typeof s[Object.keys(s)[0]]=="object"){const r=[];return t.forEach(i=>{i in s?r.push(s[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(s)}`)}function pI(s,t){return nG(s,t,"classWeight")}async function fI(s,t,e,n){if(e!=null){const r=W(()=>{if(s.shape.length===1)return Ks(s);if(s.shape.length===2){if(s.shape[1]>1)return ui(s,1);if(s.shape[1]===1)return L(s,[s.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${s.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${s.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Nt(r);const o=[];return i.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),Je(o,"float32")}else return null}function sG(s,t){return F(s,t)}const rG=32;function mI(s,t){let e,n;const r=t;e=r.xs,n=r.ys,$(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=Wv("input",s.inputNames,e),o=Wv("output",s.outputNames,n),a=i[0].shape[0];$(i.length===s.inputs.length,()=>`LayersModel has ${s.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(s.inputNames)})`),$(o.length===s.outputs.length,()=>`LayersModel has ${s.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(s.outputNames)})`);for(let l=0;l<i.length;l++)$(i[l].shape[0]===a,()=>`Batch size mismatch: input ${s.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${s.inputNames[0]}.`);for(let l=0;l<o.length;l++)$(o[l].shape[0]===a,()=>`Batch size mismatch: output ${s.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${s.inputNames[0]}.`);return{xs:i,ys:o}}function Wv(s,t,e){if(e instanceof Lt)return[e];if(Array.isArray(e))return $(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${s} keys ${t}.`),e;{const n=[];for(const r of t){if(e[r]==null)throw new M(`The feature data generated by the dataset lacks the required ${s} key '${r}'.`);n.push(e[r])}return n}}function iG(s){if(s.length===3)throw new kt("Validation with sample weights is not implemented yet.");return{xs:s[0],ys:s[1]}}async function oG(s,t,e){const n=e.batchesPerEpoch!=null;if($(s.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),$(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),$(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),$(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),$(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");s.isTraining=!0;try{const r=e.validationData!=null;let i,o;if(r)if(Uv(e.validationData))$(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=iG(e.validationData);i=g.xs,o=g.ys}const a=s.makeTrainFunction(),l=s.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();const u=rI(e.callbacks,e.yieldEvery),h=e.verbose==null?1:e.verbose,{callbackList:d,history:p}=iI(u,h,e.epochs,null,null,aG(t,e),null,r,c);d.setModel(s),s.history=p,await d.onTrainBegin(),s.stopTraining_=!1;let f=e.initialEpoch==null?0:e.initialEpoch,m=await t.iterator();for(;f<e.epochs;){const g={};await d.onEpochBegin(f);let y=0,b=0;for(n||(m=await t.iterator());!n||y<e.batchesPerEpoch;){const w=await m.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){const{xs:x,ys:v}=mI(s,w.value),C={};C.batch=b,C.size=x[0].shape[0],await d.onBatchBegin(b,C);const k=[];if(e.classWeight!=null){const _=pI(e.classWeight,s.outputNames);for(let T=0;T<_.length;++T)k.push(await fI(v[T],null,_[T]))}const I=x.concat(v).concat(k),N=a(I);Nt(I);for(let _=0;_<l.length;++_){const T=l[_],D=N[_];C[T]=D,Ie(D)}await d.onBatchEnd(b,C),sI(C),b++,y++}if(n?y>=e.batchesPerEpoch:w.done){if(r){let x;Uv(e.validationData)?x=zt(await s.evaluateDataset(e.validationData,{batches:e.validationBatches})):x=zt(s.evaluate(i,o,{batchSize:e.validationBatchSize==null?rG:e.validationBatchSize,verbose:0}));for(let v=0;v<s.metricsNames.length;++v)g[`val_${s.metricsNames[v]}`]=x[v]}break}if(s.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,s.stopTraining_)break}return await d.onTrainEnd(),await s.history.syncData(),s.history}finally{s.isTraining=!1}}function aG(s,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(s.size)&&(e=s.size),e}function Uv(s){return typeof s.iterator=="function"}function lG(s){return typeof s.next=="function"}async function cG(s,t,e){e=e||{};const n=e.batches!=null,r=s.testFunction;let i=[];if(e.verbose>0)throw new kt("Verbose mode is not implemented yet.");$(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=lG(t)?t:await t.iterator();let a=0,l=0;for(;!n||l<e.batches;){const c=await o.next();if(i=W(()=>{if(c.value){const{xs:u,ys:h}=mI(s,c.value),d=u.concat(h),p=W(()=>r(d));if(Nt(d),l===0)for(let m=0;m<p.length;++m)i.push(gt(0));const f=d[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=i[m];i[m]=W(()=>tt(i[m],F(f,g))),l>0&&Nt(y)}Nt(p),a+=f,++l}return i}),c.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=ft(i[c],a),Nt(u)}return fn(i)}function mg(s){$(s>0&&Number.isInteger(s),()=>`batchSize is required to be a positive integer, but got ${s}`)}function Fl(s,t,e){return s==null?[null]:Array.isArray(s)?s.map(n=>to(n,t,e-t)):to(s,t,e-t)}function ky(s,t){return W(()=>s==null?null:Array.isArray(s)?s.map(e=>ky(e,t)):Uk(s,t.dtype==="int32"?t:rt(t,"int32")))}function gg(s,t){const e=[];let n=0,r=null;for(;n<s;)r=n+t,r>=s&&(r=s),e.push([n,r]),n=r;return e}function gI(s){const t=[];s instanceof Lt&&(s=[s]);for(let e=0;e<s.length;++e){const n=s[e];if(n.rank===1)t.push(Qu(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function ys(s,t){if(s==null)return;const e=[];if(t instanceof Lt)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(const r in t){const i=t[r];e.push(i.id)}const n=[];if(s instanceof Lt)e.indexOf(s.id)===-1&&n.push(s);else if(Array.isArray(s))s.forEach(r=>{e.indexOf(r.id)===-1&&n.push(r)});else if(s!=null)for(const r in s){const i=s[r];e.indexOf(i.id)===-1&&n.push(i)}n.forEach(r=>{r.isDisposed||r.dispose()})}function uG(s){return s instanceof Lt}function Iy(s){return Array.isArray(s)}function Gv(s){return!uG(s)&&!Iy(s)}function jv(s,t,e,n=!0,r=""){if(t==null||t.length===0){if(s!=null){let o=!1;if(Iy(s)&&s.length>0)o=!0;else if(Gv(s)){for(const a in s)if(s.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new M(`Error when checking model ${r} expected no data, but got ${s}`)}return[]}if(s==null)return t.map(o=>null);let i;if(Gv(s)){s=s,i=[];for(const o of t){if(s[o]==null)throw new M(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(s[o])}}else if(Iy(s)){if(s=s,s.length!==t.length)throw new M(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${s}`);i=s}else{if(s=s,t.length>1)throw new M(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${s.shape}`);i=[s]}if(i=gI(i),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new M(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(l===0&&!n)continue;const c=a.shape[l],u=e[o][l];if(u!=null&&u>=0&&c!==u)throw new M(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function hG(s,t,e){const n=ni(s.map(i=>i.shape[0]));n.sort();const r=ni(t.map(i=>i.shape[0]));if(r.sort(),n.length>1)throw new M(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(i=>i.shape))}`);if(r.length>1)throw new M(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(n.length>0&&r.length>0&&!Dt(n,r))throw new M(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}function dG(s,t,e){const n=[km,Im,gc];for(let r=0;r<s.length;++r){const i=s[r],o=t[r],a=e[r];if(o!=null){if(o===gc&&i.shape[i.shape.length-1]===1)throw new M(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],d=c[u];if(d!=null&&h!==d)throw new M(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Hv(s,t,e,n=!0,r=""){let i;if(Array.isArray(s)){if(s.length!==t.length)throw new M(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${s.length} Tensors(s).`);i=s}else{if(t.length>1)throw new M(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(s.shape)}.`);i=[s]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const a=i[o];if(a.shape.length!==e[o].length)throw new M(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(l===0&&!n)continue;const c=a.shape[l],u=e[o][l];if(u!=null&&u!==c)throw new M(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function pG(s,t){if(s==null||Array.isArray(s)&&s.length===0)return t.map(n=>[]);let e;if(typeof s=="string"||typeof s=="function")e=[s];else if(Array.isArray(s)||typeof s=="object")e=s;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${s}`);if(Array.isArray(e))return t.map(n=>e);{const n=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),n.push(i)}return n}}const fG="layers-model";class Yo extends xs{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new M("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");YU(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=KU(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Ur))throw new M("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new M(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(fg(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new M(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>fg(a))}else{const o=fg(t.loss);this.outputs.forEach(a=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Qi("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=pG(t.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Qi("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;const a=r[o];(c=>{let h,d,p;for(const f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===Im?["accuracy","acc"].indexOf(f)!==-1?d=aI:["crossentropy","ce"].indexOf(f)!==-1&&(d=BU):this.lossFunctions[o]===Zd?["accuracy","acc"].indexOf(f)!==-1?d=zU:["crossentropy","ce"].indexOf(f)!==-1&&(d=uI):["accuracy","acc"].indexOf(f)!==-1?d=lI:["crossentropy","ce"].indexOf(f)!==-1&&(d=cI);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=d,h=""+y}else p=qU(f),h=""+Jh(f);let m;Qi(h,()=>{m=p}),i(o,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=n.batchSize==null?32:n.batchSize;mg(r);const o=this.standardizeUserDataXY(t,e,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,r,n.verbose,n.steps);return fn(c)}finally{ys(o[0],t),ys(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),cG(this,t,e)}checkNumSamples(t,e,n,r="steps"){let i;if(n!=null){if(i=null,e!=null)throw new M(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new M(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new M("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],i=this.retrieveSymbolicTensors(r),o=new Qr;if(t instanceof Lt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new M(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],t[l])}else for(const l of this.inputs){const c=t[l.name];if(c==null)throw new M(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=Wl(i,o);return n?a:a[0]}retrieveSymbolicTensors(t){const e=po(null,t.length);let n=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<t.length;++a){const l=o.indexOf(t[a]);if(l!==-1&&(e[a]=i[l],n--),n===0)break}if(n===0)break}if(n>0){const r=[];throw e.forEach((i,o)=>{i==null&&r.push(t[o])}),new M(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,n=!1){return W(()=>{const r=this.checkNumSamples(t);if(n)throw new kt("Verbose predictLoop() is not implemented yet.");const i=gg(r,e),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)W(()=>{const c=i[a][0],u=i[a][1],h=Fl(t,c,u),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});const p=new Qr(d);return Wl(this.outputs,p)}).forEach((c,u)=>o[u].push(c));return fn(o.map(a=>pe(a,0)))})}predict(t,e={}){const n=gI(t);Hv(n,this.inputNames,this.feedInputShapes,!1);try{const r=e.batchSize==null?32:e.batchSize;return mg(r),this.predictLoop(n,r)}finally{ys(n,t)}}predictOnBatch(t){Hv(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(this.optimizer_==null)throw new ls("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===Zd?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(t=jv(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=jv(e,this.feedOutputNames,i,!1,"target"),hG(t,e),dG(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new M(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(t,e,i,o);if(n!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const u=pI(r,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await fI(l[h],null,u[h]))}return[a,l,c]}testLoop(t,e,n,r=0,i){return W(()=>{const o=this.checkNumSamples(e,n,i,"steps"),a=[];if(r>0)throw new kt("Verbose mode is not implemented yet.");if(i!=null)throw new kt("steps mode in testLoop() is not implemented yet");{const l=gg(o,n),c=Je(Ds(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],d=l[u][1],p=to(c,h,d-h),f=ky(e,p),m=t(f);if(u===0)for(let g=0;g<m.length;++g)a.push(gt(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=tt(a[g],F(d-h,y))}}for(let u=0;u<a.length;++u)a[u]=ft(a[u],o)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let i=r;if(Ev(t,r)>1){const o=Ev(t.slice(0,n),r);i+=`_${o}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:n[m]});const d=new Qr(h),p=Wl(this.outputs,d,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(r[m],p[m]);i[m]!=null&&(y=sG(y,i[m]));const b=oe(y);e.push(b),m===0?f=y:f=tt(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=e[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=oe(y(r[b],p[b]))}Ie(g),o.push(g)}return f=oe(f),this.calculateLosses().forEach(m=>{f=tt(f,m)}),f},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=t=>W(()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const a=new Qr(o),l=Wl(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=oe(u(i[c],l[c]));c===0?n=h:n=tt(n,h),e.push(n)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],d=oe(u(i[h],l[h]));e.push(d)}return e})}async fit(t,e,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,c,u,h,d;try{const p=n.batchSize==null?32:n.batchSize;mg(p);const m=await this.standardizeUserData(t,e,n.sampleWeight,n.classWeight,!1,p);r=m[0],i=m[1],d=m[2];let g=!1,y;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)l=n.validationData[0],c=n.validationData[1];else throw n.validationData.length===3?new kt("validationData including sample weights is not supported yet."):new M(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);const _=await this.standardizeUserData(l,c,null,null,!0,p);u=_[0],h=_[1],y=u.concat(h)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;const N=Math.floor(r[0].shape[0]*(1-n.validationSplit)),_=r[0].shape[0];u=Fl(r,N,_),o=r,r=Fl(r,0,N),h=Fl(i,N,_),a=i,i=Fl(i,0,N),y=u.concat(h)}else n.validationSteps!=null&&(g=!0);const b=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();const w=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,C;g?(this.makeTestFunction(),v=this.testFunction,C=x.slice().concat(x.map(N=>"val_"+N))):(v=null,y=[],C=x.slice());const k=rI(n.callbacks,n.yieldEvery);return await this.fitLoop(w,b,x,p,n.epochs,n.verbose,k,v,y,n.shuffle,C,n.initialEpoch,null,null)}finally{this.isTraining=!1,ys(r,t),ys(i,e),ys(o,t),ys(a,e),ys(u,l),ys(h,c),d!=null&&Nt(d)}}async fitLoop(t,e,n,r,i,o,a,l,c,u,h,d,p,f){r==null&&(r=32),i==null&&(i=1),u==null&&(u=!0),d==null&&(d=0);let m=!1;if(l!=null&&c!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new M("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(e,r,p,"steps_per_epoch");let y;g!=null&&(y=Ds(0,g)),o==null&&(o=1);const{callbackList:b,history:w}=iI(a,o,i,d,g,p,r,m,h);b.setModel(this),this.history=w,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<i;++x){await b.onEpochBegin(x);const v={};if(p!=null)throw new kt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new kt("batch shuffling is not implemneted yet");u&&Qy(y);const C=Je(y),k=gg(g,r);for(let I=0;I<k.length;++I){const N={};if(await b.onBatchBegin(I,N),W(()=>{const _=k[I][0],T=k[I][1],D=to(C,_,T-_);N.batch=I,N.size=T-_;const R=ky(e,D),P=t(R);for(let B=0;B<n.length;++B){const U=n[B],H=P[B];N[U]=H,Ie(H)}if(I===k.length-1&&m){const B=this.testLoop(l,c,r);for(let U=0;U<n.length;++U){const H=n[U],G=B[U];Ie(G),v["val_"+H]=G}}}),await b.onBatchEnd(I,N),sI(N),this.stopTraining_)break}C.dispose()}if(await b.onEpochEnd(x,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return oG(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],i=n[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return Nt(a),ys(n[0],t),ys(n[1],e),fn(l)}getNamedWeights(t){const e=[],n=t!=null&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let o=0;o<r.length;++o)n&&!r[o].trainable||e.push({name:r[o].originalName,tensor:i[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=Hg().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-Hg().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=gr(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>gr(e))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e)if(typeof n[r]=="string")t[r]=gr(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[gr(Jh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>gr(Jh(t)));{const t={};for(const e in this.metrics)t[e]=gr(Jh(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=Cy(t.optimizer_config),n=Cr(e);let r;if(typeof t.loss=="string")r=Wi(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>Wi(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=Wi(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>Wi(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=Wi(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:n})}async save(t,e){if(typeof t=="string"){const c=fC(t);if(c.length===0)throw new M(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new M(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new M("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Xg(this.getNamedWeights(e)),a={modelTopology:this.toJSON(null,!1),format:fG,generatedBy:`TensorFlow.js tfjs-layers v${dI}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await Xg(await this.optimizer.getWeights(),c);n.specs.push(...h),n.data=hC([n.data,u])}return this.userDefinedMetadata!=null&&(Vv(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)}setUserDefinedMetadata(t){Vv(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yo.className="Model";nt(Yo);class yI extends Yo{}yI.className="Functional";nt(yI);class yc extends Yo{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Sm("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new M(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof yc||t instanceof Yo;let n;if(e){if(n=t,n.outputs.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new M("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new M("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=gU({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new M(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new M("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=Jk(this.outputs[0])}this.inboundNodes=[],new Tm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:po(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Pt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new ls("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new ls("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new ls("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new ls("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let i,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new M("Legacy serialization format not supported yet.");i=e}else $(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof yc))throw new kt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const u=Cr(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(t){if(this.model==null)throw new M("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new M("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}yc.className="Sequential";nt(yc);let Qe=class extends ko{getConfig(){return{}}};class bI extends Qe{apply(t,e=1){return tU(t,e)}}bI.className="elu";nt(bI);class xI extends Qe{apply(t){return Yf(t)}}xI.className="selu";nt(xI);class wI extends Qe{apply(t){return Fs(t)}}wI.className="relu";nt(wI);class vI extends Qe{apply(t){return W(()=>pi(6,Fs(t)))}}vI.className="relu6";nt(vI);class SI extends Qe{apply(t){return t}}SI.className="linear";nt(SI);class CI extends Qe{apply(t){return Zn(t)}}CI.className="sigmoid";nt(CI);class TI extends Qe{apply(t){return nU(t)}}TI.className="hardSigmoid";nt(TI);class kI extends Qe{apply(t){return Co(t)}}kI.className="softplus";nt(kI);class II extends Qe{apply(t){return eU(t)}}II.className="softsign";nt(II);class NI extends Qe{apply(t){return di(t)}}NI.className="tanh";nt(NI);let yx=class extends Qe{apply(t,e=-1){return Hu(t,e)}};yx.className="softmax";nt(yx);class $I extends Qe{apply(t,e=-1){return Wf(t,e)}}$I.className="logSoftmax";nt($I);class _I extends Qe{apply(t){return W(()=>W(()=>{const e=Math.sqrt(2),n=F(.5,tt(1,Bf(ft(t,e))));return F(t,n)}))}}_I.className="gelu";nt(_I);class EI extends Qe{apply(t){return W(()=>F(.5,F(t,tt(1,di(F(Me(ft(2,Math.PI)),tt(t,F(.044715,nr(t,3)))))))))}}EI.className="gelu_new";nt(EI);class DI extends Qe{apply(t){return W(()=>F(t,di(Co(t))))}}DI.className="mish";nt(DI);class AI extends Qe{apply(t,e=1){return W(()=>F(Zn(F(t,e)),t))}}AI.className="swish";nt(AI);function mi(s){return s.getClassName()}function yg(s,t={}){return Ju(s,Hn.getMap().classNameMap,t,"activation")}function gi(s){if(s==null){const t={};return t.className="linear",t.config={},yg(t)}if(typeof s=="string"){const t={};return t.className=s,t.config={},yg(t)}else return s instanceof Qe?s:yg(s)}function mG(s){if(s!=null&&typeof s!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${s}`)}class OI extends ko{}class RI extends OI{constructor(t){super(),mG(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return W(()=>{let e=ve([1]);return this.hasL1&&(e=tt(e,ht(F(this.l1,be(t))))),this.hasL2&&(e=tt(e,ht(F(this.l2,th(t))))),L(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}RI.className="L1L2";nt(RI);const Xv={l1l2:"L1L2"};function Xt(s){return sx(s)}function qv(s,t={}){return Ju(s,Hn.getMap().classNameMap,t,"regularizer")}function ne(s){if(s==null)return null;if(typeof s=="string"){const e={className:s in Xv?Xv[s]:s,config:{}};return qv(e)}else return s instanceof OI?s:qv(s)}class FI extends _t{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=vt(t);let n=Fs(t);return this.maxValue!=null&&(n=wn(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}FI.className="ReLU";nt(FI);class PI extends _t{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vt(t);return Pu(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}PI.className="LeakyReLU";nt(PI);class LI extends _t{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=ee(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ne(t.alphaRegularizer),this.alphaConstraint=Ee(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new M(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Pt(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new $e({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=vt(t),Uu(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ae(this.alphaInitializer),alphaRegularizer:Xt(this.alphaRegularizer),alphaConstraint:_e(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}LI.className="PReLU";nt(LI);let MI=class extends _t{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new kt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=vt(t);return gl(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};MI.className="ELU";nt(MI);class BI extends _t{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const n=vt(t);return F(n,rt(un(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}BI.className="ThresholdedReLU";nt(BI);class zI extends _t{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new yx().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return W(()=>{let n=vt(t);const r=e.mask;if(r!=null){const i=F(ct(mn(n.shape),rt(r,n.dtype)),gt(-1e9));n=tt(n,i)}return this.axis instanceof Array?this.axis.length>1?vn(ct(n,Mu(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}zI.className="Softmax";nt(zI);function Zo(s,t,e){if(typeof s=="number")return po(s,t);if(s.length!==t)throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${s.length} elements.`);for(let n=0;n<t;++n){const r=s[n];if(!Y4(r))throw new M(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(s)} including a non-integer number ${r}`)}return s}function _s(s,t,e,n,r=1){if(s==null)return s;const i=t+(t-1)*(r-1);let o;return e==="same"?o=s:o=s-i+1,Math.floor((o+n-1)/n)}function Vs(s,t,e,n){if(s==null)return null;if(n==="valid")s=s*t+fi([e-t,0]);else if(n==="same")s=s*t;else throw new M(`Unsupport padding mode: ${n}.`);return s}function bx(s,t){return W(()=>(ge(t),t==="channelsFirst"?At(s,[0,2,3,1]):s))}function VI(s,t){return W(()=>(ge(t),t==="channelsFirst"?At(s,[0,2,3,4,1]):s))}function gG(s,t,e,n=1,r="valid",i,o=1){return W(()=>{if(i==null&&(i=As()),ge(i),s.shape.length!==3)throw new M(`The input of a conv1dWithBias operation should be 3, but is ${s.shape.length} instead.`);if(t.shape.length!==3)throw new M(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new M(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(s=At(s,[0,2,1])),r==="causal")throw new kt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Ff(s,t,n,r==="same"?"same":"valid","NWC",o);return e!=null&&(a=Ps(a,e)),a})}function Kv(s,t,e,n=[1,1],r="valid",i,o,a=null){return W(()=>{if(i==null&&(i=As()),ge(i),s.rank!==3&&s.rank!==4)throw new M(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${s.rank}.`);if(t.rank!==3&&t.rank!==4)throw new M(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${s.rank}.`);let l=bx(s,i);if(r==="causal")throw new kt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=pT({x:l,filter:t,strides:n,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),i==="channelsFirst"&&(l=At(l,[0,3,1,2])),l})}function yG(s,t,e,n=[1,1,1],r="valid",i,o){return W(()=>{if(i==null&&(i=As()),ge(i),s.rank!==4&&s.rank!==5)throw new M(`conv3dWithBias expects input to be of rank 4 or 5, but received ${s.rank}.`);if(t.rank!==4&&t.rank!==5)throw new M(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${s.rank}.`);let a=VI(s,i);if(r==="causal")throw new kt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=F0(a,t,n,r==="same"?"same":"valid","NDHWC",o),e!=null&&(a=Ps(a,e)),i==="channelsFirst"&&(a=At(a,[0,4,1,2,3])),a})}class Nm extends _t{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Nm.verifyArgs(e),this.rank=t,Re(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new kt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Zo(e.kernelSize,t,"kernelSize"),this.strides=Zo(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,es(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ge(this.dataFormat),this.activation=gi(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=ee(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ee(e.biasConstraint),this.biasRegularizer=ne(e.biasRegularizer),this.activityRegularizer=ne(e.activityRegularizer),this.dilationRate=Zo(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new M(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new M(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new M(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(zs("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!rx(t.kernelSize,"number",1,3))throw new M(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mi(this.activation),useBias:this.useBias,biasInitializer:ae(this.biasInitializer),biasRegularizer:Xt(this.biasRegularizer),activityRegularizer:Xt(this.activityRegularizer),biasConstraint:_e(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class vl extends Nm{constructor(t,e){super(t,e),this.kernel=null,vl.verifyArgs(e),this.filters=e.filters,Re(this.filters,"filters"),this.kernelInitializer=ee(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ee(e.kernelConstraint),this.kernelRegularizer=ne(e.kernelRegularizer)}build(t){t=Pt(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return W(()=>{t=vt(t);let n;const r=this.bias==null?null:this.bias.read(),i=Lk(this.activation.getClassName());if(i!=null&&this.rank===2)n=Kv(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)n=gG(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=Kv(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=yG(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new kt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Pt(t);const e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<n.length;++i){const o=_s(n[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:ae(this.kernelInitializer),kernelRegularizer:Xt(this.kernelRegularizer),kernelConstraint:_e(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new M(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class rh extends vl{constructor(t){super(2,t),rh.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!rx(t.kernelSize,"number",1,2))throw new M(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}rh.className="Conv2D";nt(rh);class ih extends vl{constructor(t){super(3,t),ih.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new M(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}ih.className="Conv3D";nt(ih);class WI extends rh{constructor(t){if(super(t),this.inputSpec=[new $e({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Pt(t),t.length!==4)throw new M("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new $e({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return W(()=>{let n=vt(t);if(n.shape.length!==4)throw new M(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const r=n.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],c=r[a],u=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=Vs(l,d,u,this.padding),m=Vs(c,p,h,this.padding),g=[i,f,m,this.filters];this.dataFormat!=="channelsLast"&&(n=At(n,[0,2,3,1]));let y=Pf(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=At(y,[0,3,1,2])),this.bias!=null&&(y=Ps(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=Pt(t);const e=t.slice();let n,r,i;this.dataFormat==="channelsFirst"?(n=1,r=2,i=3):(n=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return e[n]=this.filters,e[r]=Vs(e[r],l,o,this.padding),e[i]=Vs(e[i],c,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}WI.className="Conv2DTranspose";nt(WI);class UI extends ih{constructor(t){if(super(t),this.inputSpec=[new $e({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new M(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Pt(t),t.length!==5)throw new M("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new M("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new $e({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return W(()=>{let n=vt(t);if(n.shape.length!==5)throw new M(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const r=n.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=r[l],u=r[o],h=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=Vs(c,m,d,this.padding),w=Vs(u,g,p,this.padding),x=Vs(h,y,f,this.padding),v=[i,b,w,x,this.filters];this.dataFormat!=="channelsLast"&&(n=At(n,[0,2,3,4,1]));let C=P0(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=At(C,[0,4,1,2,3])),this.bias!==null&&(C=Ps(C,this.bias.read(),this.dataFormat)),this.activation!==null&&(C=this.activation.apply(C)),C})}computeOutputShape(t){t=Pt(t);const e=t.slice();let n,r,i,o;this.dataFormat==="channelsFirst"?(n=1,r=2,i=3,o=4):(n=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],d=this.strides[2];return e[n]=this.filters,e[r]=Vs(e[r],u,a,this.padding),e[i]=Vs(e[i],h,l,this.padding),e[o]=Vs(e[o],d,c,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}UI.className="Conv3DTranspose";nt(UI);class GI extends vl{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new M("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new M("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new M(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ee(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ne(e.depthwiseRegularizer),this.depthwiseConstraint=Ee(e.depthwiseConstraint),this.pointwiseInitializer=ee(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ne(e.pointwiseRegularizer),this.pointwiseConstraint=Ee(e.pointwiseConstraint)}build(t){if(t=Pt(t),t.length<this.rank+2)throw new M(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new $e({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return W(()=>{t=vt(t);let n;if(this.rank===1)throw new kt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=At(t,[0,2,3,1])),n=Zf(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Ps(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=At(n,[0,3,1,2])),n})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.pointwiseInitializer=ae(this.pointwiseInitializer),t.depthwiseRegularizer=Xt(this.depthwiseRegularizer),t.pointwiseRegularizer=Xt(this.pointwiseRegularizer),t.depthwiseConstraint=_e(this.depthwiseConstraint),t.pointwiseConstraint=_e(this.pointwiseConstraint),t}}GI.className="SeparableConv";class jI extends GI{constructor(t){super(2,t)}}jI.className="SeparableConv2D";nt(jI);class $m extends vl{constructor(t){super(1,t),$m.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!rx(t.kernelSize,"number",1,1))throw new M(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}$m.className="Conv1D";nt($m);class HI extends _t{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return W(()=>{if(t=vt(t),this.dataFormat==="channelsLast"){const n=Zh(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Zh(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const n=Zh(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Zh(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}HI.className="Cropping2D";nt(HI);class XI extends _t{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ge(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,X4(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{const e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return W(()=>{let n=vt(t);const r=n.shape;if(this.dataFormat==="channelsFirst"){n=At(n,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?Dn.resizeNearestNeighbor(n,[i,o]):Dn.resizeBilinear(n,[i,o]);return At(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Dn.resizeNearestNeighbor(n,[i,o]):Dn.resizeBilinear(n,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}XI.className="UpSampling2D";nt(XI);function bG(s,t,e=[1,1],n="valid",r,i){return W(()=>{r==null&&(r=As()),ge(r);let o=bx(s,r);if(s.rank!==4)throw new M(`Input for depthwiseConv2d is required to be 4-D, but is instead ${s.rank}-D`);if(t.rank!==4)throw new M(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=ml(o,t,e,n==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=At(o,[0,3,1,2])),o})}class qI extends Nm{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ee(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ee(t.depthwiseConstraint),this.depthwiseRegularizer=ne(t.depthwiseRegularizer)}build(t){if(t=Pt(t),t.length<4)throw new M(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new M(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return W(()=>{t=vt(t);let n=bG(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Ps(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=Pt(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=_s(e,this.kernelSize[0],this.padding,this.strides[0]),o=_s(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ae(this.depthwiseInitializer),t.depthwiseRegularizer=Xt(this.depthwiseRegularizer),t.depthwiseConstraint=_e(this.depthwiseRegularizer),t}}qI.className="DepthwiseConv2D";nt(qI);function KI(s,t,e,n){if(Array.isArray(s)){if(t!=null||e!=null)throw new M("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=s.slice(s.length-n,s.length),s=s.slice(0,s.length-n)),s.length>1&&(t=s.slice(1,s.length)),s=s[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),e=r(e),{inputs:s,initialState:t,constants:e}}function YI(s,t,e,n=!1,r,i,o=!1,a=!1){return W(()=>{const l=t.shape.length;if(l<3)throw new M(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Ds(2,l));t=At(t,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=rt(rt(r,"bool"),"float32"),r.rank===l-1&&(r=we(r,-1)),r=At(r,c)),n&&(t=Qn(t,0),r!=null&&(r=Qn(r,0)));const u=[];let h,d=e;const p=t.shape[0],f=ts(t);let m;r!=null&&(m=ts(r));for(let y=0;y<p;++y){const b=f[y],w=W(()=>s(b,d));if(r==null)h=w[0],d=w[1];else{const x=W(()=>{const v=m[y],C=ct(Mn(v),v),k=tt(F(w[0],v),F(d[0],C)),I=d.map((N,_)=>tt(F(w[1][_],v),F(N,C)));return{output:k,newStates:I}});h=x.output,d=x.newStates}a&&u.push(h)}let g;return a&&(g=Sn(u,1)),[h,g,d]})}class Ni extends _t{constructor(t){super(t);let e;if(t.cell==null)throw new M("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new vx({cells:t.cell}):e=t.cell,e.stateSize==null)throw new M("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new $e({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ds(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){wy(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(this.returnSequences?r=[t[0],t[1],n]:r=[t[0],n],this.returnState){const i=[];for(const o of e)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,e){return W(()=>{Array.isArray(e)&&(e=e[0]);const n=this.returnSequences?e:null;if(this.returnState){const r=this.states.map(i=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new kt("Constants support is not implemented in RNN yet.");wy(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new $e({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Dt(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new M(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new $e({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){W(()=>{if(!this.stateful)throw new Bs("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(n==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>ve([n,r])):this.states_=[ve([n,this.cell.stateSize])];else if(t==null)Nt(this.states_),this.keptStates!=null&&(Nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>ve([n,r])):this.states_[0]=ve([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Nt(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[n,o];if(!Dt(i.shape,a))throw new M(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>Ie(r.clone()))})}apply(t,e){let n=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=KI(t,n,r,this.numConstants);t=i.inputs,n=i.initialState,r=i.constants;let o=[],a=[];if(n!=null){e.initialState=n,o=o.concat(n),this.stateSpec=[];for(const c of n)this.stateSpec.push(new $e({shape:c.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(e.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof rr){const c=[t].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,e);return this.inputSpec=h,d}else return super.apply(t,e)}call(t,e){return W(()=>{const n=e==null?null:e.mask,r=e==null?null:e.training;let i=e==null?null:e.initialState;t=vt(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new M(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},c=YI((f,m)=>{const g=this.cell.call([f].concat(m),a);return[g[0],g.slice(1)]},t,i,this.goBackwards,n,null,this.unroll,this.returnSequences),u=c[0],h=c[1],d=c[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?h:u;return this.returnState?[p].concat(d):p})}getInitialState(t){return W(()=>{let e=ve(t.shape);return e=ht(e,[1,2]),e=Qu(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?by(e,[1,n]):e):this.cell.stateSize>1?[by(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Ni.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),e)}static fromConfig(t,e,n={}){const r=e.cell,i=Cr(r,n);return new t(Object.assign(e,{cell:i}))}}Ni.className="RNN";nt(Ni);class _m extends _t{}class xx extends _m{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Re(this.units,"units"),this.activation=gi(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ee(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ee(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ee(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ne(t.kernelRegularizer),this.recurrentRegularizer=ne(t.recurrentRegularizer),this.biasRegularizer=ne(t.biasRegularizer),this.kernelConstraint=Ee(t.kernelConstraint),this.recurrentConstraint=Ee(t.recurrentConstraint),this.biasConstraint=Ee(t.biasConstraint),this.dropout=oa([1,fi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=oa([1,fi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Pt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return W(()=>{if(t=t,t.length!==2)throw new M(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yi({ones:()=>Mn(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yi({ones:()=>Mn(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=Js(F(t,o),this.kernel.read()):i=Js(t,this.kernel.read()),this.bias!=null&&(i=Ps(i,this.bias.read())),a!=null&&(n=F(n,a));let l=tt(i,Js(n,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:mi(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Xt(this.kernelRegularizer),recurrentRegularizer:Xt(this.recurrentRegularizer),biasRegularizer:Xt(this.biasRegularizer),activityRegularizer:Xt(this.activityRegularizer),kernelConstraint:_e(this.kernelConstraint),recurrentConstraint:_e(this.recurrentConstraint),biasConstraint:_e(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}xx.className="SimpleRNNCell";nt(xx);class ZI extends Ni{constructor(t){t.cell=new xx(t),super(t)}call(t,e){return W(()=>{this.cell.dropoutMask!=null&&(Nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}}ZI.className="SimpleRNN";nt(ZI);class wx extends _m{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new M("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Re(this.units,"units"),this.activation=gi(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=gi(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ee(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ee(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ee(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ne(t.kernelRegularizer),this.recurrentRegularizer=ne(t.recurrentRegularizer),this.biasRegularizer=ne(t.biasRegularizer),this.kernelConstraint=Ee(t.kernelConstraint),this.recurrentConstraint=Ee(t.recurrentConstraint),this.biasConstraint=Ee(t.biasConstraint),this.dropout=oa([1,fi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=oa([1,fi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Pt(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return W(()=>{if(t=t,t.length!==2)throw new M(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training==null?!1:e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yi({ones:()=>Mn(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yi({ones:()=>Mn(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(t=F(t,i[0]));let u=Js(t,this.kernel.read());this.useBias&&(u=Ps(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=F(r,o[0]));const h=this.recurrentKernel.read(),[d,p]=gn(h,[2*this.units,this.units],h.rank-1),f=Js(r,d),[m,g,y]=gn(u,3,u.rank-1),[b,w]=gn(f,2,f.rank-1);a=this.recurrentActivation.apply(tt(m,b)),l=this.recurrentActivation.apply(tt(g,w));const x=Js(F(l,r),p);c=this.activation.apply(tt(y,x));const v=tt(F(a,r),F(tt(1,Zt(a)),c));return[v,v]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:mi(this.activation),recurrentActivation:mi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Xt(this.kernelRegularizer),recurrentRegularizer:Xt(this.recurrentRegularizer),biasRegularizer:Xt(this.biasRegularizer),activityRegularizer:Xt(this.activityRegularizer),kernelConstraint:_e(this.kernelConstraint),recurrentConstraint:_e(this.recurrentConstraint),biasConstraint:_e(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}wx.className="GRUCell";nt(wx);class JI extends Ni{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new wx(t),super(t)}call(t,e){return W(()=>{this.cell.dropoutMask!=null&&(Nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}JI.className="GRU";nt(JI);class Em extends _m{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Re(this.units,"units"),this.activation=gi(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=gi(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ee(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ee(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ee(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ne(t.kernelRegularizer),this.recurrentRegularizer=ne(t.recurrentRegularizer),this.biasRegularizer=ne(t.biasRegularizer),this.kernelConstraint=Ee(t.kernelConstraint),this.recurrentConstraint=Ee(t.recurrentConstraint),this.biasConstraint=Ee(t.biasConstraint),this.dropout=oa([1,fi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=oa([1,fi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Pt(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(e=class extends ps{apply(l,c){const u=i.apply([o]),h=new ox().apply([o]),d=i.apply([o*2]);return Av(Av(u,h),d)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return W(()=>{const n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new M(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yi({ones:()=>Mn(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yi({ones:()=>Mn(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(t=F(t,o[0]));let d=Js(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=F(r,a[0])),d=tt(d,Js(r,this.recurrentKernel.read())),this.useBias&&(d=Ps(d,this.bias.read()));const[p,f,m,g]=gn(d,4,d.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),u=tt(F(c,i),F(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=F(h,this.activation.apply(u));return[y,y,u]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:mi(this.activation),recurrentActivation:mi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),recurrentInitializer:ae(this.recurrentInitializer),biasInitializer:ae(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Xt(this.kernelRegularizer),recurrentRegularizer:Xt(this.recurrentRegularizer),biasRegularizer:Xt(this.biasRegularizer),activityRegularizer:Xt(this.activityRegularizer),kernelConstraint:_e(this.kernelConstraint),recurrentConstraint:_e(this.recurrentConstraint),biasConstraint:_e(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}Em.className="LSTMCell";nt(Em);class QI extends Ni{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Em(t),super(t)}call(t,e){return W(()=>{this.cell.dropoutMask!=null&&(Nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}QI.className="LSTM";nt(QI);class vx extends _m{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return W(()=>{t=t;let n=t.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(n.splice(0,a.stateSize.length)):r.push(n.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];n=r[a],a===0?o=[t[0]].concat(n):o=[o[0]].concat(n),o=l.call(o,e),i.push(o.slice(1))}n=[];for(const a of i.slice().reverse())n.push(...a);return[o[0]].concat(n)})}build(t){wy(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,r)=>{Qi(`RNNCell_${r}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,e,n={}){const r=[];for(const i of e.cells)r.push(Cr(i,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return vy(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,i=t.splice(r);for(let o=0;o<n.weights.length;++o)e.push([n.weights[o],i[o]])}px(e)}}vx.className="StackedRNNCells";nt(vx);function yi(s){const{ones:t,rate:e,training:n=!1,count:r=1,dropoutFunc:i}=s,o=()=>i!=null?i(t(),e):Gk(t(),e),a=()=>eh(o,t,n);return!r||r<=1?Ie(a().clone()):Array(r).fill(void 0).map(a).map(c=>Ie(c.clone()))}var xG=function(s,t){var e={};for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&t.indexOf(n)<0&&(e[n]=s[n]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,n=Object.getOwnPropertySymbols(s);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(s,n[r])&&(e[n[r]]=s[n[r]]);return e};class t2 extends Ni{constructor(t){if(t.unroll)throw new kt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new kt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new $e({ndim:5})]}call(t,e){return W(()=>{if(this.cell.dropoutMask!=null&&(Nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new M("ConvRNN2D cell does not support constants");const n=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return W(()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)],o=ve(i);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){W(()=>{if(!this.stateful)throw new Bs("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(n[0]==null)throw new M("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ve(i)):this.states_=[ve(i)];else if(t==null)Nt(this.states_),this.keptStates!=null&&(Nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ve(i)):this.states_[0]=ve(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new M(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Nt(this.states_);for(let a=0;a<this.states_.length;++a){const l=t[a],c=i;if(!Dt(l.shape,c))throw new M(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Ie(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=e==="channelsFirst",c=t[l?3:2],u=t[l?4:3],h=_s(c,r[0],i,o[0],a[0]),d=_s(u,r[1],i,o[1],a[1]);return[...t.slice(0,2),...l?[n,h,d]:[h,d,n]]}}t2.className="ConvRNN2D";class Sx extends Em{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:i,dataFormat:o,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Re(this.filters,"filters"),this.kernelSize=Zo(n,2,"kernelSize"),this.kernelSize.forEach(l=>Re(l,"kernelSize")),this.strides=Zo(r||1,2,"strides"),this.strides.forEach(l=>Re(l,"strides")),this.padding=i||"valid",es(this.padding),this.dataFormat=o||"channelsLast",ge(this.dataFormat),this.dilationRate=Zo(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Re(l,"dilationRate"))}build(t){var e;t=Pt(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new M(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(e=class extends ps{apply(d,p){const f=c.apply([u]),m=mn([u]),g=c.apply([u*2]);return ix([f,m,g])}},e.className="CustomInit",e)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return W(()=>{if(t.length!==3)throw new M(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,r=t[0],i=t[1],o=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yi({ones:()=>Mn(r),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(Z,J,et)=>!J||!J[et]?Z:F(J[et],Z);let u=c(r,l,0),h=c(r,l,1),d=c(r,l,2),p=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yi({ones:()=>Mn(i),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=c(i,f,0),g=c(i,f,1),y=c(i,f,2),b=c(i,f,3);const w=3,[x,v,C,k]=gn(this.kernel.read(),a,w),[I,N,_,T]=this.useBias?gn(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,x,I,this.padding),h=this.inputConv(h,v,N,this.padding),d=this.inputConv(d,C,_,this.padding),p=this.inputConv(p,k,T,this.padding);const[D,R,P,B]=gn(this.recurrentKernel.read(),a,w);m=this.recurrentConv(m,D),g=this.recurrentConv(g,R),y=this.recurrentConv(y,P),b=this.recurrentConv(b,B);const U=this.recurrentActivation.apply(tt(u,m)),H=this.recurrentActivation.apply(tt(h,g)),G=tt(F(H,o),F(U,this.activation.apply(tt(d,y)))),X=F(this.recurrentActivation.apply(tt(p,b)),this.activation.apply(G));return[X,X,G]})}getConfig(){const t=super.getConfig(),{units:e}=t,n=xG(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,e,n,r){const i=Er(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Ps(i,n,this.dataFormat):i}recurrentConv(t,e){return Er(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Sx.className="ConvLSTM2DCell";nt(Sx);class e2 extends t2{constructor(t){const e=new Sx(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}e2.className="ConvLSTM2D";nt(e2);class Cx extends _t{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return n}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t);if(0<this.rate&&this.rate<1){const r=e.training==null?!1:e.training,i=this.getNoiseShape(n);return eh(()=>Gk(n,this.rate,i,this.seed),()=>n,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}Cx.className="Dropout";nt(Cx);class n2 extends Cx{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}n2.className="SpatialDropout1D";nt(n2);class s2 extends _t{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Re(this.units,"units"),this.activation=gi(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=ee(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ee(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ee(t.kernelConstraint),this.biasConstraint=Ee(t.biasConstraint),this.kernelRegularizer=ne(t.kernelRegularizer),this.biasRegularizer=ne(t.biasRegularizer),this.activityRegularizer=ne(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Pt(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Pt(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t),r=Lk(this.activation.getClassName());let i;return r!=null?i=Js(n,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Js(n,this.kernel.read()),this.bias!=null&&(i=Ps(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:mi(this.activation),useBias:this.useBias,kernelInitializer:ae(this.kernelInitializer),biasInitializer:ae(this.biasInitializer),kernelRegularizer:Xt(this.kernelRegularizer),biasRegularizer:Xt(this.biasRegularizer),activityRegularizer:Xt(this.activityRegularizer),kernelConstraint:_e(this.kernelConstraint),biasConstraint:_e(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}s2.className="Dense";nt(s2);class r2 extends _t{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Pt(t);for(const e of t.slice(1))if(e==null)throw new M(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],si(t,1)]}call(t,e){return W(()=>{this.invokeCallHook(t,e);let n=vt(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){const r=[0];for(let i=2;i<n.rank;++i)r.push(i);r.push(1),n=At(n,r)}return Q4(n)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}r2.className="Flatten";nt(r2);class i2 extends _t{constructor(t){super(t),this.supportsMasking=!0,this.activation=gi(t.activation)}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t);return this.activation.apply(n)})}getConfig(){const t={activation:mi(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}i2.className="Activation";nt(i2);class o2 extends _t{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return W(()=>(t=vt(t),Z4(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}o2.className="RepeatVector";nt(o2);class a2 extends _t{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(o===null)o=l;else throw new M("Can only specifiy one unknown dimension.");else i*=c}const a=si(t);if(o!==null){if(i===0||a%i!==0)throw new M(n);r[o]=a/i}else if(a!==i)throw new M(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return L(n,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}a2.className="Reshape";nt(a2);class l2 extends _t{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=Ds(1,t.dims.length+1);if(!Dt(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new $e({ndim:this.dims.length+1})]}computeOutputShape(t){t=Pt(t);const e=t.slice();return this.dims.forEach((n,r)=>{e[r+1]=t[n]}),e}call(t,e){return At(vt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}l2.className="Permute";nt(l2);class c2 extends _t{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=vt(t);return hc(lo(n,this.maskValue),-1)}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t),o=hc(lo(n,this.maskValue),-1,!0);return F(n,rt(o,n.dtype))})}}c2.className="Masking";nt(c2);class u2 extends _t{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(zt(t.inputLength))}this.inputDim=t.inputDim,Re(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Re(this.outputDim,"outputDim"),this.embeddingsInitializer=ee(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ne(t.embeddingsRegularizer),this.activityRegularizer=ne(t.activityRegularizer),this.embeddingsConstraint=Ee(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return W(()=>this.maskZero?(t=vt(t),lo(t,Rt(t))):null)}computeOutputShape(t){if(t=Pt(t),this.inputLength==null)return[...t,this.outputDim];const e=zt(this.inputLength);if(e.length!==t.length-1)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let r=0;r<e.length;++r){const i=e[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new M(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[n]=o),n++}}return[t[0],...e,this.outputDim]}call(t,e){return W(()=>{this.invokeCallHook(t,e);let n=vt(t);n.dtype!=="int32"&&(n=Zs(n,"int32"));const r=Uk(this.embeddings.read(),L(n,[n.size]));return L(r,Pt(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ae(this.embeddingsInitializer),embeddingsRegularizer:Xt(this.embeddingsRegularizer),activityRegularizer:Xt(this.activityRegularizer),embeddingsConstraint:_e(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}u2.className="Embedding";nt(u2);class No extends _t{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new kt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(i==null||o==null||i<0||o<0)n.push(null);else if(i===1)n.push(o);else if(o===1)n.push(i);else{if(i!==o)throw new M("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Pt(t)]),t=t,t.length<2)throw new M(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=ni(e),e.length>1)throw new M(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&ni(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return W(()=>{if(t=t,this.reshapeRequired){const n=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=fi(r);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=Qu(o,1);n.push(o)}return this.mergeFunction(n)}else{let i=!1;for(const l of t){const c=l.rank;if(c==null){const u=l.shape,h=u[0],d=u.slice(1).concat([h]);let p=L(l,[h].concat(si(u.slice(1))));p=At(p,[1,0]),p=L(p,d),n.push(p),i=!0}else if(c>1){const u=Ds(1,c).concat([0]);n.push(At(l,u)),i=!0}else n.push(l)}let o=this.mergeFunction(n);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=L(At(L(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Ds(0,a-1));o=At(o,l)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let n=[];for(const r of t)r!=null&&r[0]!==null&&n.push(r[0]);return n=ni(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return W(()=>{if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an Array");if(!Array.isArray(t))throw new M("`inputs` should be an Array");if(e.length!==t.length)throw new M(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:we(r,0));let n=e[0];for(let r=1;r<e.length-1;++r)n=Es(n,e[r]);return n})}}class h2 extends No{constructor(t){super(t)}mergeFunction(t){return W(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=tt(e,t[n]);return e})}}h2.className="Add";nt(h2);class d2 extends No{constructor(t){super(t)}mergeFunction(t){return W(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=F(e,t[n]);return e})}}d2.className="Multiply";nt(d2);class p2 extends No{constructor(t){super(t)}mergeFunction(t){return W(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=tt(e,t[n]);return F(1/t.length,e)})}}p2.className="Average";nt(p2);class f2 extends No{constructor(t){super(t)}mergeFunction(t){return W(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ar(e,t[n]);return e})}}f2.className="Maximum";nt(f2);class m2 extends No{constructor(t){super(t)}mergeFunction(t){return W(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=pi(e,t[n]);return e})}}m2.className="Minimum";nt(m2);class g2 extends No{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new M("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(r!=null){e=!1;break}if(e)return;const n=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const a of n)if(Dt(a,i)){o=!0;break}o||n.push(i)}if(n.length>1)throw new M("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return W(()=>ix(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new M("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const i of e.slice(1)){if(n[r]==null||i[r]==null){n[r]=null;break}n[r]+=i[r]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new M("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new M("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new M(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return W(()=>{let n=!0;if(e.forEach(o=>{if(o!=null){n=!1;return}}),n)return null;const r=[];for(let o=0;o<t.length;++o)e[o]==null?r.push(rt(Mn(t[o]),"bool")):e[o].rank<t[o].rank?r.push(we(e[o],-1)):r.push(e[o]);const i=pe(r,this.axis);return Rf(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}g2.className="Concatenate";nt(g2);function Pl(s,t){for(;s<0;)s+=t;return s}function wG(s,t,e){if(s.shape.length>3||t.shape.length>3)throw new kt("batchDot is not implemented for tensors of 4D or higher rank yet");if($(s.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${s.shape.length}`),$(s.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),s.dtype==="complex64"||t.dtype==="complex64")throw new kt("batchDot is not implemented for complex64-type Tensors yet.");const n=s.shape.length,r=t.shape.length;e==null&&(e=[n-1,r-2]);const i=e;return W(()=>{let o;if(n>r){o=n-r;const l=[];for(let c=0;c<o;++c)l.push(1);t=L(t,t.shape.concat(l))}else if(r>n){o=r-n;const l=[];for(let c=0;c<o;++c)l.push(1);s=L(s,s.shape.concat(l))}else o=0;let a;if(s.shape.length===2&&t.shape.length===2)i[0]===i[1]?a=ht(F(s,t),i[0]):a=ht(F(At(s,[1,0]),t),i[1]);else{const l=i[0]!==s.shape.length-1,c=i[1]===t.shape.length-1;a=Ct(s,t,l,c)}if(o>0){let l;n>r?l=n+r-3:l=n-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=En(a,c)}return a.shape.length===1&&(a=we(a,1)),a})}class y2 extends No{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){$(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new kt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new M(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new M(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Pl(i,t[o].shape.length)):r=[Pl(this.axes,e.shape.length),Pl(this.axes,n.shape.length)],this.normalize&&(e=Yd(e,r[0]),n=Yd(n,r[1])),wG(e,n,r)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[Pl(this.axes,t.length),Pl(this.axes,e.length)],n}computeOutputShape(t){$(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new kt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=e.concat(n);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}y2.className="Dot";nt(y2);class b2 extends _t{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t);return eh(()=>tt(Cm(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}}b2.className="GaussianNoise";nt(b2);class x2 extends _t{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return W(()=>{this.invokeCallHook(t,e);const n=vt(t);return this.rate>0&&this.rate<1?eh(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return F(n,Cm(n.shape,1,i))},()=>n,e.training||!1):n})}}x2.className="GaussianDropout";nt(x2);class w2 extends _t{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||vt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return W(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return eh(()=>{const i=vt(t),a=-1.6732632423543772*1.0507009873554805;let l=zr(ki(n),this.rate);l=Zs(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,u=-c*a*this.rate,h=tt(F(i,l),F(tt(l,-1),a));return tt(F(h,c),u)},()=>vt(t),e.training||!1)}return t})}}w2.className="AlphaDropout";nt(w2);function bc(s,t,e,n,r,i=.001){let o;if(s.rank===2)o=k0(s,t,e,n,r,i);else if(s.rank===3)o=I0(s,t,e,n,r,i);else if(s.rank===4)o=N0(s,t,e,n,r,i);else throw new kt(`batchNormalization is not implemented for array of rank ${s.rank} yet`);return o}function vG(s,t,e,n,r=.001){return W(()=>{const i=Vu(s,n),o=i.mean,a=i.variance;return[bc(s,o,a,e,t,r),o,a]})}function SG(s,t,e,n,r=.001){return W(()=>{const i=Vu(s,n),o=i.mean,a=i.variance,l=[];for(const f of Ds(0,s.rank))n.indexOf(f)!==-1?l.push(1):l.push(s.shape[f]);const c=L(o,l),u=L(a,l),h=t==null?null:L(t,l),d=e==null?null:L(e,l);return[bc(s,c,u,d,h,r),o,a]})}function CG(s,t,e,n,r=.001){return Dt(n.slice().sort(),Ds(0,s.rank-1))?vG(s,t,e,n,r):SG(s,t,e,n,r)}class v2 extends _t{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ee(t.betaInitializer||"zeros"),this.gammaInitializer=ee(t.gammaInitializer||"ones"),this.movingMeanInitializer=ee(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ee(t.movingVarianceInitializer||"ones"),this.betaConstraint=Ee(t.betaConstraint),this.gammaConstraint=Ee(t.gammaConstraint),this.betaRegularizer=ne(t.betaRegularizer),this.gammaRegularizer=ne(t.gammaRegularizer)}build(t){t=Pt(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new M(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new $e({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return W(()=>{const n=e.training==null?!1:e.training,r=vt(t),i=r.shape,o=i.length,a=Ds(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=po(1,o);c[l]=i[l];const u=a.slice();u.sort();const h=!Dt(u,Ds(0,o).slice(0,o-1)),d=()=>{if(h){const b=L(this.movingMean.read(),c),w=L(this.movingVariance.read(),c),x=this.center?L(this.beta.read(),c):null,v=this.scale?L(this.gamma.read(),c):null;return bc(r,b,w,x,v,this.epsilon)}else return bc(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();const[p,f,m]=CG(r,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,w,x)=>{W(()=>{const v=1-x,C=b.read(),k=F(ct(C,w),v);b.write(ct(C,k))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),movingMeanInitializer:ae(this.movingMeanInitializer),movingVarianceInitializer:ae(this.movingVarianceInitializer),betaRegularizer:Xt(this.betaRegularizer),gammaRegularizer:Xt(this.gammaRegularizer),betaConstraint:_e(this.betaConstraint),gammaConstraint:_e(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}v2.className="BatchNormalization";nt(v2);class S2 extends _t{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ee(t.betaInitializer||"zeros"),this.gammaInitializer=ee(t.gammaInitializer||"ones"),this.betaRegularizer=ne(t.betaRegularizer),this.gammaRegularizer=ne(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Pt(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==ni(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){const n=vt(t),r=n.shape,i=r.length;return W(()=>{let{mean:a,variance:l}=Vu(n,this.axis,!0);const c=po(1,i);for(const m of this.axis)c[m]=r[m];const u=m=>m!=null&&m.shape.length!==i?L(m,c):m;let h=this.scale?u(this.gamma.read()):null,d=this.center?u(this.beta.read()):null;const p=[],f=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(p.push(r[m]),f.push(1)):(p.push(1),f.push(r[m]));return a=Xn(a,p),l=Xn(l,p),h!=null&&(h=Xn(h,f)),d!=null&&(d=Xn(d,f)),bc(n,a,l,d,h,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ae(this.betaInitializer),gammaInitializer:ae(this.gammaInitializer),betaRegularizer:Xt(this.betaRegularizer),gammaRegularizer:Xt(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}S2.className="LayerNormalization";nt(S2);function TG(s,t,e){return W(()=>{if(s.rank!==4)throw new M(`temporalPadding expects input tensor to be 4-D, but received a ${s.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new M("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=As()),e!=="channelsLast"&&e!=="channelsFirst")throw new M(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Vr(s,n)})}class C2 extends _t{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?As():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new M(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new M(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new M(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new $e({ndim:4})]}computeOutputShape(t){t=Pt(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return W(()=>TG(vt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}C2.className="ZeroPadding2D";nt(C2);function Dm(s,t,e,n,r,i){return W(()=>{ge(r),Bk(i),es(n),e==null&&(e=[1,1]),n==null&&(n="valid"),r==null&&(r=As()),i==null&&(i="max"),s=bx(s,r);let o;const a=n==="same"?"same":"valid";return i==="max"?o=zu(s,t,e,a):o=Au(s,t,e,a),r==="channelsFirst"&&(o=At(o,[0,3,1,2])),o})}function T2(s,t,e,n,r,i){return W(()=>{ge(r),Bk(i),es(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),r==null&&(r=As()),i==null&&(i="max"),s=VI(s,r);let o;const a=n==="same"?"same":"valid";return i==="max"?o=Y0(s,t,e,a):o=T0(s,t,e,a),r==="channelsFirst"&&(o=At(o,[0,4,1,2,3])),o})}class k2 extends _t{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new M(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Re(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new M(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Re(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,es(this.padding),this.inputSpec=[new $e({ndim:3})]}computeOutputShape(t){t=Pt(t);const e=_s(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return W(()=>{this.invokeCallHook(t,e),t=Qu(vt(t),2);const n=this.poolingFunction(vt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return En(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class I2 extends k2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),Dm(t,e,n,r,i,"max")}}I2.className="MaxPooling1D";nt(I2);class N2 extends k2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),Dm(t,e,n,r,i,"avg")}}N2.className="AveragePooling1D";nt(N2);class $2 extends _t{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new M(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Re(this.poolSize,"poolSize"),Re(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ge(this.dataFormat),es(this.padding),this.inputSpec=[new $e({ndim:4})]}computeOutputShape(t){t=Pt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=_s(e,this.poolSize[0],this.padding,this.strides[0]),n=_s(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return W(()=>(this.invokeCallHook(t,e),this.poolingFunction(vt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class _2 extends $2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),Dm(t,e,n,r,i,"max")}}_2.className="MaxPooling2D";nt(_2);class E2 extends $2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),Dm(t,e,n,r,i,"avg")}}E2.className="AveragePooling2D";nt(E2);class D2 extends _t{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new M(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Re(this.poolSize,"poolSize"),Re(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ge(this.dataFormat),es(this.padding),this.inputSpec=[new $e({ndim:5})]}computeOutputShape(t){t=Pt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=_s(e,this.poolSize[0],this.padding,this.strides[0]),n=_s(n,this.poolSize[1],this.padding,this.strides[1]),r=_s(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return W(()=>(this.invokeCallHook(t,e),this.poolingFunction(vt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class A2 extends D2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),T2(t,e,n,r,i,"max")}}A2.className="MaxPooling3D";nt(A2);class O2 extends D2{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return ge(i),es(r),T2(t,e,n,r,i,"avg")}}O2.className="AveragePooling3D";nt(O2);class R2 extends _t{constructor(t){super(t),this.inputSpec=[new $e({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new kt}}class F2 extends R2{constructor(t){super(t||{})}call(t,e){return W(()=>{const n=vt(t);return oe(n,1)})}}F2.className="GlobalAveragePooling1D";nt(F2);class P2 extends R2{constructor(t){super(t||{})}call(t,e){return W(()=>{const n=vt(t);return Jn(n,1)})}}P2.className="GlobalMaxPooling1D";nt(P2);class L2 extends _t{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ge(this.dataFormat),this.inputSpec=[new $e({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new kt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class M2 extends L2{call(t,e){return W(()=>{const n=vt(t);return this.dataFormat==="channelsLast"?oe(n,[1,2]):oe(n,[2,3])})}}M2.className="GlobalAveragePooling2D";nt(M2);class B2 extends L2{call(t,e){return W(()=>{const n=vt(t);return this.dataFormat==="channelsLast"?Jn(n,[1,2]):Jn(n,[2,3])})}}B2.className="GlobalMaxPooling2D";nt(B2);class z2 extends _t{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=e.layer,i=Cr(r,n);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}class V2 extends z2{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Pt(t),t.length<3)throw new M(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Pt(t);const e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return W(()=>(t=vt(t),YI((o,a)=>[vt(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}V2.className="TimeDistributed";nt(V2);function kG(s){Io(H4,"BidirectionalMergeMode",s)}const IG="concat";class W2 extends z2{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=Cr(n),e.goBackwards=e.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=Cr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?IG:t.mergeMode,kG(this.mergeMode),t.weights)throw new kt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,r,i;return this.returnState&&(i=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[n].concat(i).concat(i.slice()):fn(r)}apply(t,e){let n=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=KI(t,n,r,this.numConstants);if(t=i.inputs,n=i.initialState,r=i.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&r==null)return super.apply(t,e);const o=[],a=[];if(n!=null){const c=n.length;if(c%2>0)throw new M("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,o.push(...n);const u=n.map(h=>new $e({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(r!=null)throw new kt("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof rr;for(const c of o)if(c instanceof rr!==l)throw new M("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[t].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,e);return this.inputSpec=h,d}else return super.apply(t,e)}call(t,e){return W(()=>{const n=e.initialState;let r,i;if(n==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const l=n.slice(0,n.length/2),c=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:l})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Qn(i,1));let a;return this.mergeMode==="concat"?a=ix([r,i]):this.mergeMode==="sum"?a=tt(r,i):this.mergeMode==="ave"?a=F(.5,tt(r,i)):this.mergeMode==="mul"?a=F(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Qi(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Qi(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(n)?n.concat(i).concat(i):[n].concat(i).concat(i)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=Cr(e.layer);if(delete e.layer,e.numConstants!=null)throw new kt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}W2.className="Bidirectional";nt(W2);class U2 extends _t{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return W(()=>(t=vt(t),t.dtype!=="float32"&&(t=Zs(t,"float32")),tt(F(t,this.scale),this.offset)))}}U2.className="Rescaling";nt(U2);const{resizeBilinear:NG,cropAndResize:$G}=Dn;class G2 extends _t{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,n,r,i,o,a,l){return W(()=>{let c,u=!1;const h=e/o,d=n/a,p=(r+e)/o,f=(i+n)/a,m=[h,d,p,f],g=[];t.rank===3?(u=!0,c=Sn([t])):c=t;for(let v=0;v<c.shape[0];v++)g.push(m);const y=Yn(g,[g.length,4]),b=Dr(0,g.length,1,"int32"),x=$G(c,y,b,[r,i],"nearest");return Zs(u?vt(ts(x)):x,l)})}upsize(t,e,n,r){return W(()=>{const i=NG(t,[e,n]);return Zs(i,r)})}call(t,e){return W(()=>{const n=vt(t),r=n.dtype,i=n.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(n,l,c,this.height,this.width,o,a,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Pt(t);const e=t.length-3,n=t.length-2;return t[e]=this.height,t[n]=this.width,t}}G2.className="CenterCrop";nt(G2);function _G(s,t,e,n){let r=vt(s);if(r.dtype!=="int32"&&(r=Zs(r,"int32")),t==="int")return r;const i=r.shape;if(r.rank===0&&(r=we(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=we(r,-1)),r.rank>2)throw new M(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t),a=r;let l;if(typeof n<"u"&&t==="count"?l=Wd(a,n,e,o):l=Wd(a,[],e,o),t!=="tfIdf")return l;if(n)return F(l,n);throw new M("When outputMode is 'tfIdf', weights must be provided.")}class j2 extends _t{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=Pt(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return W(()=>{t=vt(t),t.dtype!=="int32"&&(t=Zs(t,"int32"));let n;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new M(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);n=vt(e.countWeights)}const r=Jn(t),i=ea(t),o=un(this.numTokens,r).bufferSync().get(0),a=zr(i,0).bufferSync().get(0);if(!(o&&a))throw new M(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return _G(t,this.outputMode,this.numTokens,n)})}}j2.className="CategoryEncoding";nt(j2);const EG=["bilinear","nearest"],Yv=new Set(EG);class H2 extends _t{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(Yv.has(t.interpolation))this.interpolation=t.interpolation;else throw new M(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=Pt(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return W(()=>{const n=[this.height,this.width];if(this.interpolation==="bilinear")return Dn.resizeBilinear(t,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Dn.resizeNearestNeighbor(t,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Yv]} are supported`)})}}H2.className="Resizing";nt(H2);class X2{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}X2.className="RandomSeed";class q2 extends _t{constructor(t){super(t),this.randomGenerator=new X2(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}q2.className="BaseRandomLayer";const DG=["bilinear","nearest"],Zv=new Set(DG);class K2 extends q2{constructor(t){super(t);const{factor:e,interpolation:n="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new M(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new M(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new M(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(Zv.has(n))this.interpolation=n;else throw new M(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=Pt(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return W(()=>{const n=vt(t);this.imgHeight=n.shape[n.shape.length-3];const r=n.shape[n.shape.length-2];this.widthFactor=ki([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Dn.resizeBilinear(t,o);case"nearest":return Dn.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Zv]} are supported`)}})}}K2.className="RandomWidth";nt(K2);var Jv;(function(s){s[s.FAIL=0]="FAIL",s[s.SHORTEST=1]="SHORTEST",s[s.LONGEST=2]="LONGEST"})(Jv||(Jv={}));function dt(s,t){Array.isArray(s)||(s=[s]),s.forEach(e=>{e!=null&&$(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const AG=om;class Am extends vp{nextDataId(){return Am.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Jy(this,Gn())}write(t,e,n){this.firstUse&&(this.firstUse=!1,j().get("IS_NODE")&&jn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if(e==="string"&&n!=null&&n.length>0&&Gs(n[0])){const i=n.map(o=>qs(o));r=this.write(i,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,n,r,i){this.data.set(t,{values:e,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){const r=this.readSync(n.real.dataId),i=this.readSync(n.imag.dataId);return Ar(r,i)}return WS(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const n=e.map(r=>$r(r));return Tt(t.shape,t.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Tt(t.shape,t.dtype,e)}makeOutput(t,e,n){return Gn().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=en();return t(),{kernelMs:en()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){dt([t],"where");const e=this.readSync(t.dataId);return AG(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Am.nextDataId=0;function Y2(s){const t=new Float32Array(s.length);for(let e=0;e<s.length;++e)t[e]=Math.abs(s[e]);return t}const OG=s=>{const{x:t}=s.inputs,e=s.backend;dt(t,"abs");let n=new Float32Array(K(t.shape));const r=e.data.get(t.dataId).values;return n=Y2(r),e.makeOutput(n,t.shape,t.dtype)},RG={kernelName:Ic,backendName:"cpu",kernelFunc:OG};function ye(s){return(t,e,n,r,i)=>{const o=St(t,e),a=o.length,l=yt(o),c=K(o),u=Le(i,c),h=t.length,d=e.length,p=yt(t),f=yt(e),m=ao(t,o),g=ao(e,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=s(n[y%n.length],r[y%r.length]);else for(let y=0;y<u.length;++y){const b=wo(y,a,l),w=b.slice(-h);m.forEach(k=>w[k]=0);const x=$s(w,h,p),v=b.slice(-d);g.forEach(k=>v[k]=0);const C=$s(v,d,f);u[y]=s(n[x],r[C])}return[u,o]}}function _n(s){const{inputs:t,backend:e}=s,{real:n,imag:r}=t,i=e.data.get(n.dataId).values,o=e.data.get(r.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",i),imag:e.makeTensorInfo(r.shape,"float32",o)},a}const FG={kernelName:Ep,backendName:"cpu",kernelFunc:_n};function ep(s,t,e="float32"){if(e==="complex64"){const r=ep(s,t,"float32"),i=ep(s,t,"float32");return _n({inputs:{real:r,imag:i},backend:s})}const n=je(K(t),e);return s.makeTensorInfo(t,e,n)}function ir(s){const{inputs:t,backend:e}=s,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const PG={kernelName:Ba,backendName:"cpu",kernelFunc:ir};function fo(s){const{inputs:t,backend:e}=s,{input:n}=t,r=e.data.get(n.dataId).complexTensorInfos.real,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const LG={kernelName:uf,backendName:"cpu",kernelFunc:fo};function Z2(s,t,e,n){if(n==="int32"){const r=Int32Array.from(s);return[t,"int32",r]}if(n==="bool"){const r=wi([0],e),[i,o]=ye((a,l)=>a!==l?1:0)(t,[],s,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${n}`)}function bi(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{dtype:i}=n;if(i==="complex64"){if(r.dtype==="complex64")return ir({inputs:{x:r},backend:e});const u=ep(e,r.shape,r.dtype),h=bi({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),d=_n({inputs:{real:h,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const u=fo({inputs:{input:r},backend:e}),h=bi({inputs:{x:u},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(u),h}if(!e0(r.dtype,i)){const u=ir({inputs:{x:r},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=e.data.get(r.dataId).values,[a,l,c]=Z2(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,c)}const MG={kernelName:Ia,backendName:"cpu",kernelFunc:bi};function De(s,t,e,n){return e==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;dt([o,a],s);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?Or(c):c,d=o.dtype==="string"?Or(u):u,p=n||o.dtype,[f,m]=t(o.shape,a.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=bi({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=bi({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=l.data.get(y.dataId).values,x=l.data.get(b.dataId).values,[v,C,k]=e(o.shape,a.shape,p,f,w,x),I=l.makeTensorInfo(k,"float32",v),N=l.makeTensorInfo(k,"float32",C),_=_n({inputs:{real:I,imag:N},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(N),_}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=n||o.dtype,[d,p]=t(o.shape,a.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function Tx(s){return(t,e,n,r,i,o)=>{const a=St(t,e),l=K(a),c=a.length,u=yt(a),h=Le("float32",l),d=Le("float32",l),p=ao(t,a),f=ao(e,a),m=Ar(n,r),g=Ar(i,o),y=t.length,b=yt(t),w=e.length,x=yt(e);if(p.length+f.length===0)for(let v=0;v<h.length;v++){const C=v%m.length,k=v%g.length,I=s(m[C*2],m[C*2+1],g[k*2],g[k*2+1]);h[v]=I.real,d[v]=I.imag}else for(let v=0;v<h.length;v++){const C=wo(v,c,u),k=C.slice(-y);p.forEach(D=>k[D]=0);const I=$s(k,y,b),N=C.slice(-w);f.forEach(D=>N[D]=0);const _=$s(N,w,x),T=s(m[I*2],m[I*2+1],g[_*2],g[_*2+1]);h[v]=T.real,d[v]=T.imag}return[h,d,a]}}const J2=ye(((s,t)=>s+t)),BG=Tx(((s,t,e,n)=>({real:s+e,imag:t+n}))),aa=De(vo,J2,BG),zG={kernelName:vo,backendName:"cpu",kernelFunc:aa};function kx(s,t,e,n,r){const i=K(n),o=je(r,e);for(let a=0;a<s.length;a++){const l=s[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=t[a]:o[l]+=1)}return o}function Q2(s,t,e,n=!1){const r=s.shape[0],i=s.shape[1],o=Tt([r,e],t.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const c=s.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||(n?o.set(1,a,c):t.size>0?o.set(o.get(a,c)+t.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}const tN=ye(((s,t)=>s&t)),VG=De(Rc,tN),WG={kernelName:Rc,backendName:"cpu",kernelFunc:VG};function lr(s){return(t,e,n)=>{const r=de(e,t.length);for(let i=0;i<t.length;++i)r[i]=s(t[i],n);return r}}function Wt(s,t,e){const n=lr(t);return $i(s,n,e)}function $i(s,t,e){return({inputs:n,attrs:r,backend:i})=>{const{x:o}=n;dt(o,s);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Or(l)}else c=l;const u=e||o.dtype,h=t(c,u,r);return a.makeTensorInfo(o.shape,u,h)}}const eN=lr(s=>Math.ceil(s)),UG=$i(Na,eN),GG={kernelName:Na,backendName:"cpu",kernelFunc:UG};function nN(s,t,e,n){const r=de(e,K(t));if(n&&e!=="string"){let i=0;s.forEach(o=>{const a=K(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;s.forEach(o=>{const a=e==="string"?Or(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*t[1]+i;for(let h=0;h<o.shape[1];++h)r[u+h]=a[l++]}i+=o.shape[1]})}return r}const sN=ye((s,t)=>s===t?1:0),rN=De(Uc,sN,null,"bool"),jG={kernelName:Uc,backendName:"cpu",kernelFunc:rN};const iN=lr(s=>Math.exp(s)),oN=$i(Ra,iN,"float32"),HG={kernelName:Ra,backendName:"cpu",kernelFunc:oN};const aN=lr(s=>Math.expm1(s)),XG=$i(Fa,aN),qG={kernelName:Fa,backendName:"cpu",kernelFunc:XG};const lN=lr(s=>Math.floor(s)),KG=$i(Pa,lN),YG={kernelName:Pa,backendName:"cpu",kernelFunc:KG};const cN=ye((s,t)=>Math.floor(s/t)),ZG=De(La,cN,null,"int32"),JG={kernelName:La,backendName:"cpu",kernelFunc:ZG};function uN(s,t,e,n,r,i,o,a,l){const c=Tt([n,i],e);for(let u=0;u<n;u++){const h=[];let d=0;for(let p=0;p<r;p++){const f=s[u*r+p];d+=f*o[p],h.push(f)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<i;p++)c.values[u*i+p]=t.get(...t.indexToLoc(d*i+p))}return c}function hN(s,t,e){const n=Tt(e,s.dtype);for(let r=0;r<n.size;++r){const o=n.indexToLoc(r).slice(),a=o[0],l=o[2],c=t.locToIndex([a,l]);o[2]=t.values[c];const u=s.locToIndex(o);0<=u&&u<s.values.length&&(n.values[r]=s.values[u])}return n}const dN=ye((s,t)=>s>t?1:0),QG=De(Xc,dN,null,"bool"),tj={kernelName:Xc,backendName:"cpu",kernelFunc:QG};const pN=ye((s,t)=>s>=t?1:0),ej=De(Ma,pN,null,"bool"),nj={kernelName:Ma,backendName:"cpu",kernelFunc:ej};const fN=ye((s,t)=>s<t?1:0),sj=De(Kc,fN,null,"bool"),rj={kernelName:Kc,backendName:"cpu",kernelFunc:sj};const mN=ye((s,t)=>s<=t?1:0),ij=De(Yc,mN,null,"bool"),oj={kernelName:Yc,backendName:"cpu",kernelFunc:ij};function gN(s,t,e){const n=(t-s)/(e-1),r=je(e,"float32");r[0]=s;for(let i=1;i<r.length;i++)r[i]=r[i-1]+n;return r}const yN=lr(s=>Math.log(s)),aj=$i(Ua,yN),lj={kernelName:Ua,backendName:"cpu",kernelFunc:aj};function bN(s,t,e,n){const r=Le(n,K(e));for(let i=0;i<r.length;++i){const o=i*t;let a=s[o];for(let l=0;l<t;++l){const c=s[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[i]=a}return r}const xN=ye(((s,t)=>Math.max(s,t))),cj=De(ja,xN),uj={kernelName:ja,backendName:"cpu",kernelFunc:cj};const wN=ye(((s,t)=>Math.min(s,t))),hj=De(Ha,wN),dj={kernelName:Ha,backendName:"cpu",kernelFunc:hj};const Ix=ye(((s,t)=>s*t)),pj=Tx(((s,t,e,n)=>({real:s*e-t*n,imag:s*n+t*e}))),Om=De(qa,Ix,pj),fj={kernelName:qa,backendName:"cpu",kernelFunc:Om};function vN(s,t,e){const n=Lr(-1,e);return Ix([],t,n,s,e)}function mj(s){const{inputs:t,backend:e}=s,{x:n}=t;dt(n,"neg");const r=e.data.get(n.dataId).values,[i,o]=vN(r,n.shape,n.dtype);return e.makeTensorInfo(o,n.dtype,i)}const gj={kernelName:au,backendName:"cpu",kernelFunc:mj};const SN=ye(((s,t)=>s!==t?1:0)),yj=De(lu,SN,null,"bool"),bj={kernelName:lu,backendName:"cpu",kernelFunc:yj};function Nx(s,t,e,n,r){const i=t.length,o=K(t),a=yt(t),l=yt(r),c=Le(e,K(r));for(let u=0;u<o;++u){const h=wo(u,i,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[n[f]];const p=$s(d,i,l);c[p]=s[u]}return c}function Cn(s){const{inputs:t,attrs:e,backend:n}=s,{x:r}=t,{perm:i}=e;dt(r,"transpose");const o=r.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=r.shape[i[h]];const l=n.data.get(r.dataId).values,c=Nx(l,r.shape,r.dtype,i,a);return{dataId:n.write(c,a,r.dtype),shape:a,dtype:r.dtype}}const xj={kernelName:Zi,backendName:"cpu",kernelFunc:Cn};function CN(s,t,e,n){const[r,i]=ze(s,n),o=bn(t,"int32"),a=je(K(r),o),l=K(i);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=e[u+d];a[c]=h}return{outVals:a,outShape:r,outDtype:o}}function wj(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;dt(r,"prod");const a=r.shape.length,l=$t(i,r.shape),c=ce(l,a);let u=l,h=r;const d=[];c!=null&&(h=Cn({inputs:{x:r},backend:e,attrs:{perm:c}}),d.push(h),u=me(u.length,a));const p=e.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=CN(h.shape,h.dtype,p,u);let y=m;return o&&(y=fe(m,l)),d.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,f)}const vj={kernelName:fu,backendName:"cpu",kernelFunc:wj};function Sj(s,t,e){s.forEach((n,r)=>{if(n<0||n>=e){const i=wo(r,t.length,yt(t)).join(",");throw new Error(`indices[${i}] = ${n} is not in [0, ${e})`)}})}function Cj(s,t){for(let e=0;e<s.length;++e){const n=s[e],r=e===s.length-1?t:s[e+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<n.length;++i)if(n[i-1]>n[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Tj(s,t,e,n){const r=[];let i=0;const o=t.length-1+e.length,a=new Array(o).fill(null).map(()=>[0]);Cj(e,n);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<s.length;++c){let u=s[c],h=s[c]+1;for(let d=0;d<e.length;++d){const p=e[d],f=d+t.length-1;if(f>=0){const m=a[f],g=m[m.length-1]-p[u];for(let y=u;y<h;++y)a[f].push(p[y+1]+g)}u=p[u],h=p[h]}h!==u&&(r.push([u,h]),i+=h-u)}return{outSplits:a,valueSlices:r,numValues:i}}function kj(s){const t=[];for(let e=0;e<s.length;++e){const n=s[e].length,r=de("int32",n);t.push(r),s[e].forEach((i,o)=>r[o]=i)}return t}function Qv(s,t){const e=s.slice(0,t);for(;e.length<t;)e.push(1);for(let n=t;n<s.length;n++)e[t-1]*=s[n];return e}function Ij(s,t,e,n,r,i){const o=Qv(t,2)[1],a=Qv(i,2)[1];let l=0;for(const c of e)for(let u=c[0];u<c[1];++u){for(let h=0;h<n;++h)r[l*a+h]=s[u*o+h];++l}}function Nj(s,t,e,n,r){const i=t.slice();i[0]=r;const o=de(e,K(i)),a=s.length,l=a===0?0:a/t[0];return Ij(s,t,n,l,o,i),[o,i]}function TN(s,t,e,n,r,i,o,a){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(Sj(i,o,l),n.length===0)throw new Error("params.rank must be nonzero");const c=n[0],{outSplits:u,valueSlices:h,numValues:d}=Tj(i,o,s,c),p=kj(u),f=Nj(e,n,r,h,d);return[p,f[0],f[1]]}const t1=2147483647;function kN(s,t,e,n,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=t.length===0,l=r.length===0,c=o.length===0,u=[];a||u.push(t[0]),l||u.push(r[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],d=de("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const y=a?s[0]:s[g],b=l?n[0]:n[g],w=c?i[0]:i[g];if(w===0)throw new Error("Requires delta != 0");let x;if(w>0&&b<y||w<0&&b>y)x=0;else if(x=Math.ceil(Math.abs((b-y)/w)),x>t1)throw new Error(`Requires ((limit - start) / delta) <= ${t1}`);d[g+1]=d[g]+x}const p=d[h],f=de(e,p);let m=0;for(let g=0;g<h;++g){const y=d[g+1]-d[g];let b=a?s[0]:s[g];const w=c?i[0]:i[g];for(let x=0;x<y;++x)f[m++]=b,b+=w}return[d,f]}var rs=Ss;class np{constructor(t,e,n,r,i,o,a,l,c,u){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=jT(u),this.raggedRank=HT(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===rs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===rs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case rs.VALUE_ROWIDS:return np.getMaxWidthValueRowID(e);case rs.ROW_SPLITS:return np.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${rs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let n=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>n&&(n=i)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let n=0,r=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==r&&(r=a,i=Math.max(o-n,i),n=o)}return Math.max(e-n,i)}tensorShapeFromTensor(t,e,n=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return n1(t,n)}calculateOutputSize(t){const e=this.valuesShape,n=this.defaultValueShape;XT(n,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=GT(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,n){const r=Math.min(t,n),i=[];let o=0;for(let a=0;a<r;++a,o+=e)i.push(o);for(let a=r;a<t;++a)i.push(-1);return $(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,n,r){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(r,l),u=e[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=n;for(let h=0;h<l-c;++h)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,n,r){const i=t.length,o=[];if(i===0)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let u=1;u<i;++u){const h=t[u];if(h===l)c>=0&&(++a,a<r?c+=n:c=-1);else{if(a=0,l=h,h>=e.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${e.length}`);c=e[h]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,n,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case rs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,n,r);case rs.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,n,r);default:throw new Error(`Unsupported partition type: ${rs[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case rs.FIRST_DIM_SIZE:return t[0];case rs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case rs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${rs[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*n[l+1];const i=n1(n,!1),o=de(this.valuesDType,K(i));if(r[0]*n[0]>0){let l=this.calculateFirstParentOutputIndex(e,r[0],n[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],n[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,n,r){if(n.length===0)return;const i=this.values,o=n;let a=r.slice();a=a.slice(t+1);const l=K(a),c=e.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const f=this.defaultValueShape;W(()=>{const m=L(u,f);u=Ji(m,a).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=c;++f){let m=f<c?e[f]:-1;if(m===p){++p;continue}if(d<p){const g=i.subarray(h*l),y=o.subarray(d*l),b=(p-d)*l;e1(y,g,b)}if(f>=c){const g=n.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)o.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=o.slice(p*l);e1(g,u,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function e1(s,t,e){for(let n=0;n<e;n++)s[n]=t[n]}function n1(s,t){const e=[];for(let n of s){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}e.push(n)}return e}function IN(s,t,e,n,r,i,o,a,l,c){return new np(s,t,e,n,r,i,o,a,l,c).compute()}function NN(s,t,e,n){const r=s===t,i=s<t&&e<0,o=t<s&&e>1;if(r||i||o)return je(0,n);const a=Math.abs(Math.ceil((t-s)/e)),l=je(a,n);t<s&&e===1&&(e=-1),l[0]=s;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const $N=lr(s=>1/Math.sqrt(s)),$j=$i(tl,$N),_j={kernelName:tl,backendName:"cpu",kernelFunc:$j};function qi(s,t,e,n,r,i,o,a,l,c){const u=[n/r,r],h=s.values,d=t.values;if(n===0)return Tt(e,t.dtype);const p=l instanceof Ce?l:Tt(u,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<i;f++){const m=[];let g=0;for(let y=0;y<o;y++){const b=h[f*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=n/r)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<r;y++)c?p.values[g*r+y]+=d[f*r+y]:p.values[g*r+y]=t.rank===0?d[0]:d[f*r+y]}return p}const Ej=lr(s=>1/(1+Math.exp(-s))),_N=Wt(il,s=>1/(1+Math.exp(-s))),Dj={kernelName:il,backendName:"cpu",kernelFunc:_N};function EN(s,t,e,n,r){const i=Db(n,t,e),o=K(e),a=yt(n);if(i){const h=Ab(t,a);return r==="string"?s.slice(h,h+o):s.subarray(h,h+o)}const l=r==="string"?Or(s):s,c=Tt(n,r,l),u=Tt(e,r);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),p=d.map((f,m)=>f+t[m]);u.set(c.get(...p),...d)}return r==="string"?pk(u.values):u.values}function mo(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{begin:i,size:o}=n;dt(r,"slice");const[a,l]=ym(r,i,o);_b(r,a,l);const c=e.data.get(r.dataId).values,u=EN(c,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,u)}const Aj={kernelName:wu,backendName:"cpu",kernelFunc:mo};function DN(s,t,e,n,r,i,o){const a=t[0],l=i[0],c=new Array(l),u=new Array(a),h=t[1];if(l===0){if(a!==0)throw new Error(tk(a));const g=de(e,0),y=de(r,0);return[g,[0,h],y,c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<a;++g){const y=s[g*h];if(y<0)throw new Error(ek(g,y));if(y>=l)throw new Error(nk(g,y,l));++f[y],d=d&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=f[g]===0;c[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const g=s,y=n;for(let b=0;b<a;++b)u[b]=b;return[g,[a,h],y,c,u]}else{const g=f[l-1],y=de(e,g*h),b=de(r,g),w=new Array(l).fill(0);for(let x=0;x<a;++x){const v=s[x*h],C=w[v],k=(v===0?0:f[v-1])+C;w[v]++;for(let I=0;I<h;++I)y[k*h+I]=s[x*h+I];b[k]=n[x],u[x]=k}for(let x=0;x<l;++x)if(w[x]===0){const C=x===0?0:f[x-1];y[C*h+0]=x;for(let k=1;k<h;++k)y[C*h+k]=0;b[C]=o}return[y,[g,h],b,c,u]}}function AN(s,t,e,n,r){const i=K(n),o=t[0],a=r.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=r[g];if(y===-1){if(u!==-1)throw new Error(sk(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(rk(g,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(ik());const g=Math.trunc(i/c);if(c*g!==i)throw new Error(ok(n,l));l[u]=g}if(K(l)!==i)throw new Error(ak(n,l));const d=n.length,p=[];if(d>0){p[d-1]=1;for(let g=d-2;g>=0;--g)p[g]=p[g+1]*n[g+1]}const f=[];if(a>0){f[a-1]=1;for(let g=a-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=de(e,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<d;++b)y+=s[g*d+b]*p[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[o,a],l]}function $x(s,t,e,n,r,i=!1,o=0){const a=n.length,l=[t[0],s.length/t[0]],c=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(ry());const d=t.slice();d[0]=h;const p=d.reduce((w,x)=>w*x,1),f=de(e,p);if(a===0)return h>0&&f.fill(o),[f,d];if(h<=0)throw new Error(ry());let m=0,g=1,y=0,b=r[m];for(;;){let w=0;if(g<a){if(w=r[g],b===w){++g;continue}if(b>=w)throw new Error(lk())}if(b<0||b>=h)throw new Error(ck(b,h));b>y&&f.fill(o,y*c,b*c);for(let x=m;x<g;++x){const v=n[x];if(v<0||v>=l[0])throw new Error(uk(x,n[x],l[0]));for(let C=0;C<c;C++)f[b*c+C]+=s[v*c+C]}if(i)for(let x=0;x<c;x++)f[b*c+x]/=g-m;if(m=g,++g,y=b+1,b=w,g>a)break}return y<h&&f.fill(o,y*c,h*c),[f,d]}const Oj=lr(s=>Math.sqrt(s)),Rj=Wt(al,s=>Math.sqrt(s)),Fj={kernelName:al,backendName:"cpu",kernelFunc:Rj};const ON=ye(((s,t)=>{const e=s-t;return e*e})),Pj=De(ll,ON),Lj={kernelName:ll,backendName:"cpu",kernelFunc:Pj};const RN=lr((s,t)=>{const{pattern:e,replaceGlobal:n,rewrite:r}=t;return s.replace(new RegExp(e,n?"g":""),r)}),Mj=$i(ku,RN),Bj={kernelName:ku,backendName:"cpu",kernelFunc:Mj};function FN(s,t,e,n){const r=Tt(s,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+n[l];r.set(t.get(...a),...o)}return r}class zj{constructor(t,e,n,r,i,o){this.separator=qs(t),this.nGramWidths=e,this.leftPad=qs(n),this.rightPad=qs(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),h=o-(c+u),d=e+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let b=0;b<h;++b)p+=t[d+b].length;p+=u*this.rightPad.length;const f=c+u+h-1;p+=f*this.separator.length,n[r+a]=new Uint8Array(p);const m=n[r+a];let g=0;const y=b=>b.forEach(w=>m[g++]=w);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(t[d+b]),y(this.separator);if(h>0){y(t[d+h-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let u=e[c]>=l;if(u=u&&e[c]<=n,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${n}]`);l=e[c]}if(l!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${l}`)}const i=r-1,o=de("int32",r);if(n===0||r===0){const l=new Array(n);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const d=e[l+1]-e[l],p=this.getNumNGrams(d,h);this.createNGrams(t,c,a,u,p,h),u+=p}),this.preserveShort&&u===o[l]){const h=e[l+1]-e[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(t,c,a,u,1,d)}}return[a,o]}}function PN(s,t,e,n,r,i,o,a){return new zj(e,n,r,i,o,a).compute(s,t)}function Vj(s,t,e,n){if(!s.length)return;if(t.length===0){for(let i=0;i<s.length;++i)n.push(s.subarray(i,i+1));return}if(t.length===1){const i=t[0];let o=s.indexOf(i);for(;o!==-1;){const a=s.subarray(0,o);(!e||a.length!==0)&&n.push(a),s=s.subarray(o+1),o=s.indexOf(i)}(!e||s.length!==0)&&n.push(s);return}let r=0;for(let i=0;i<s.length+1;i++)if(i===s.length||t.indexOf(s[i])!==-1){const o=s.subarray(r,i);(!e||o.length!==0)&&n.push(o),r=i+1}}function LN(s,t,e){const n=s.length,r=[];let i=0,o=0;const a=new Array(n);for(let d=0;d<n;++d){const p=r.length;Vj(s[d],t,e,r);const f=r.length-p;a[d]=f,i+=f,o=Math.max(o,f)}const l=de("int32",i*2),c=new Array(i),u=[n,o];let h=0;for(let d=0;d<n;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=r[h],++h;return[l,c,u]}function MN(s,t){const e=de("int32",s.length);for(let n=0;n<s.length;++n)e[n]=QS(s[n]).modulo(t).getLowBitsUnsigned();return e}const BN=ye(((s,t)=>s-t)),Wj=Tx(((s,t,e,n)=>({real:s-e,imag:t-n}))),_x=De(cl,BN,Wj),Uj={kernelName:cl,backendName:"cpu",kernelFunc:_x};function zN(s,t){const e=new Array(s.rank);for(let r=0;r<e.length;r++)e[r]=s.shape[r]*t[r];const n=Tt(e,s.dtype);for(let r=0;r<n.values.length;++r){const i=n.indexToLoc(r),o=new Array(s.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%s.shape[l];const a=s.locToIndex(o);n.values[r]=s.values[a]}return n}const Ul=(s,t)=>{const e=t.value-s.value;return e===0?s.index-t.index:e};function VN(s,t,e=0,n=s.length-1){for(;n>e;){if(n-e>600){const a=n-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),d=Math.max(e,Math.floor(t-l*u/a+h)),p=Math.min(n,Math.floor(t+(a-l)*u/a+h));VN(s,t,d,p)}const r=s[t];let i=e,o=n;for(yr(s,e,t),Ul(s[n],r)>0&&yr(s,e,n);i<o;){for(yr(s,i,o),i++,o--;Ul(s[i],r)<0;)i=i+1;for(;Ul(s[o],r)>0;)o=o-1}Ul(s[e],r)===0?yr(s,e,o):(o=o+1,yr(s,o,n)),o<=t&&(e=o+1),t<=o&&(n=o-1)}}function WN(s,t,e,n,r){const i=t[t.length-1],[o,a]=[s.length/i,i],l=Le(e,o*n),c=Le("int32",o*n);for(let h=0;h<o;h++){const d=h*a,p=s.subarray(d,d+a);let f=new Array(p.length);p.forEach((b,w)=>f[w]={value:b,index:w}),n<f.length&&(VN(f,n),f=f.slice(0,n)),r&&f.sort(Ul);const m=h*n,g=l.subarray(m,m+n),y=c.subarray(m,m+n);for(let b=0;b<n;b++)g[b]=f[b].value,y[b]=f[b].index}const u=t.slice();return u[u.length-1]=n,[Tt(u,e,l),Tt(u,"int32",c)]}function UN(s,t,e,n){const r=$t(t,e)[0],i=[1,e[0],1];for(let f=0;f<r;f++)i[0]*=e[f];i[1]=e[r];for(let f=r+1;f<e.length;f++)i[2]*=e[f];const o=new Map,a=new Int32Array(e[r]),l=new Ce(i,n,s),c=[],u=i[0]===1&&i[2]===1;for(let f=0;f<e[r];f++){let m;if(u)m=s[f].toString();else{const y=[];for(let b=0;b<i[0];b++)for(let w=0;w<i[2];w++)y.push(l.get(b,f,w));m=y.join(",")}const g=o.get(m);if(g!=null)a[f]=g;else{const y=o.size;o.set(m,y),a[f]=y,c.push(f)}}const h=i.slice();h[1]=o.size;const d=new Ce(h,n);c.forEach((f,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)d.set(l.get(g,f,y),g,m,y)});const p=e.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}const Gj=Object.freeze(Object.defineProperty({__proto__:null,addImpl:J2,bincountImpl:kx,bincountReduceImpl:Q2,bitwiseAndImpl:tN,castImpl:Z2,ceilImpl:eN,concatImpl:nN,equalImpl:sN,expImpl:iN,expm1Impl:aN,floorDivImpl:cN,floorImpl:lN,gatherNdImpl:uN,gatherV2Impl:hN,greaterEqualImpl:pN,greaterImpl:dN,lessEqualImpl:mN,lessImpl:fN,linSpaceImpl:gN,logImpl:yN,maxImpl:bN,maximumImpl:xN,minimumImpl:wN,multiplyImpl:Ix,negImpl:vN,notEqualImpl:SN,prodImpl:CN,raggedGatherImpl:TN,raggedRangeImpl:kN,raggedTensorToTensorImpl:IN,rangeImpl:NN,rsqrtImpl:$N,scatterImpl:qi,sigmoidImpl:Ej,simpleAbsImpl:Y2,sliceImpl:EN,sparseFillEmptyRowsImpl:DN,sparseReshapeImpl:AN,sparseSegmentReductionImpl:$x,sqrtImpl:Oj,squaredDifferenceImpl:ON,staticRegexReplaceImpl:RN,stridedSliceImpl:FN,stringNGramsImpl:PN,stringSplitImpl:LN,stringToHashBucketFastImpl:MN,subImpl:BN,tileImpl:zN,topKImpl:WN,transposeImpl:Nx,uniqueImpl:UN},Symbol.toStringTag,{value:"Module"}));h0("cpu",()=>new Am,1);const GN=Wt(Aa,s=>s>=0?s:Math.exp(s)-1),jj={kernelName:Aa,backendName:"cpu",kernelFunc:GN};function jN(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{alpha:i}=n;dt([r],"leakyRelu");const o=K(r.shape),a=e.data.get(r.dataId).values,l=Le("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(r.shape,"float32",l)}const Hj={kernelName:qc,backendName:"cpu",kernelFunc:jN};const Xj=ye((s,t)=>s<0?t*s:s);function HN(s){const{inputs:t,backend:e}=s,{x:n,alpha:r}=t;dt([n,r],"prelu");const i=e.data.get(n.dataId).values,o=e.data.get(r.dataId).values,[a,l]=Xj(n.shape,r.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const qj={kernelName:pu,backendName:"cpu",kernelFunc:HN};const XN=Wt(Za,s=>Math.max(0,s)),Kj={kernelName:Za,backendName:"cpu",kernelFunc:XN};const qN=Wt(Ja,s=>Math.min(Math.max(0,s),6)),Yj={kernelName:Ja,backendName:"cpu",kernelFunc:qN};function sp(s,t,e,n,r){if(e==="linear")return ir({inputs:{x:t},backend:s});if(e==="relu")return XN({inputs:{x:t},backend:s});if(e==="elu")return GN({inputs:{x:t},backend:s});if(e==="relu6")return qN({inputs:{x:t},backend:s});if(e==="prelu")return HN({inputs:{x:t,alpha:n},backend:s});if(e==="leakyrelu")return jN({inputs:{x:t},backend:s,attrs:{alpha:r}});if(e==="sigmoid")return _N({inputs:{x:t},backend:s});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Jt(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{shape:i}=n,o=K(r.shape),a=t0(i,o),l=K(a);$(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const c=e.data.get(r.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const Zj={kernelName:mu,backendName:"cpu",kernelFunc:Jt};function KN(s){const{inputs:t,backend:e,attrs:n}=s,{a:r,b:i}=t,{transposeA:o,transposeB:a}=n;dt([r,i],"matMul");const l=r.shape.length,c=i.shape.length,u=o?r.shape[l-2]:r.shape[l-1],h=a?i.shape[c-1]:i.shape[c-2],d=o?r.shape[l-1]:r.shape[l-2],p=a?i.shape[c-2]:i.shape[c-1],f=r.shape.slice(0,-2),m=i.shape.slice(0,-2),g=K(f),y=K(m),w=St(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);$(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const x=o?[g,u,d]:[g,d,u],v=a?[y,p,h]:[y,h,p],C=Jt({inputs:{x:r},backend:e,attrs:{shape:x}}),k=Jt({inputs:{x:i},backend:e,attrs:{shape:v}}),I=o?C.shape[1]:C.shape[2],N=o?C.shape[2]:C.shape[1],_=a?k.shape[1]:k.shape[2],T=Math.max(g,y),D=e.data.get(C.dataId).values,R=e.data.get(k.dataId).values,P=yt(C.shape),B=yt(k.shape),[U,H,G]=o?[P[0],1,P[1]]:[P[0],P[1],1],[X,Z,J]=a?[1,B[1],B[0]]:[B[1],1,B[0]],et=N*_,Q=Tt([T,N,_],C.dtype),st=Q.values,it=e.blockSize;for(let at=0;at<T;at++){const pt=at%g,xt=at%y;for(let bt=0;bt<N;bt+=it){const wt=Math.min(bt+it,N);for(let It=0;It<_;It+=it){const Bt=Math.min(It+it,_);for(let qt=0;qt<I;qt+=it){const ue=Math.min(qt+it,I);for(let Kt=bt;Kt<wt;Kt++)for(let Ut=It;Ut<Bt;Ut++){let re=0;for(let te=qt;te<ue;te++){const cr=D[pt*U+Kt*H+te*G],Ve=R[te*X+Ut*Z+xt*J];re+=cr*Ve}st[at*et+(Kt*_+Ut)]+=re}}}}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(k),e.makeTensorInfo(w,Q.dtype,Q.values)}const Jj={kernelName:Ac,backendName:"cpu",kernelFunc:KN};function Qj(s){const{inputs:t,backend:e,attrs:n}=s,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=n;let d,p,f;const m=[];d=KN({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(p=aa({inputs:{a:d,b:o},backend:e}),m.push(d),d=p),u&&(f=sp(e,d,u,a,h),m.push(d),d=f);for(const y of m)e.disposeIntermediateTensorInfo(y);return d}const tH={kernelName:rc,backendName:"cpu",kernelFunc:Qj};const eH=Wt(xa,s=>Math.acos(s)),nH={kernelName:xa,backendName:"cpu",kernelFunc:eH};const sH=Wt(wa,s=>Math.acosh(s)),rH={kernelName:wa,backendName:"cpu",kernelFunc:sH};function iH(s){const{inputs:t,backend:e}=s,n=t;dt(t,"addN");const r=n.map(a=>e.data.get(a.dataId).values),i=Tt(n[0].shape,n[0].dtype),o=i.values;for(let a=0;a<n.length;a++){const l=r[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const oH={kernelName:Nc,backendName:"cpu",kernelFunc:iH};function aH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;dt(r,"all");const a=$t(i,r.shape);let l=a;const c=ce(l,r.shape.length);let u=r;c!=null&&(u=Cn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=me(l.length,r.shape.length)),qe("all",l,u.shape.length);const[h,d]=ze(u.shape,l),p=K(d),f=je(K(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let w=m[b];for(let x=0;x<p;++x){const v=m[b+x];w=w&&v}f[y]=w}c!=null&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(h,u.dtype,f);if(o){const y=fe(h,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}const lH={kernelName:Tp,backendName:"cpu",kernelFunc:aH};function cH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;dt(r,"any");const a=$t(i,r.shape);let l=a;const c=ce(l,r.shape.length);let u=r;c!=null&&(u=Cn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=me(l.length,r.shape.length)),qe("any",l,u.shape.length);const[h,d]=ze(u.shape,l),p=K(d),f=je(K(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let w=m[b];for(let x=0;x<p;++x){const v=m[b+x];w=w||v}f[y]=w}c!=null&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(h,u.dtype,f);if(o){const y=fe(h,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}const uH={kernelName:kp,backendName:"cpu",kernelFunc:cH};function hH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i}=n;dt(r,"argMax");let o=$t(i,r.shape);const a=ce(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Cn({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=me(o.length,l.shape.length)),o=[o[0]],qe("argMax",o,l.shape.length);const[u,h]=ze(l.shape,o),d=K(u),p=je(d,"int32"),f=K(h),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],w=0;for(let x=0;x<f;++x){const v=m[y+x];v>b&&(b=v,w=x)}p[g]=w}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",p)}const dH={kernelName:$c,backendName:"cpu",kernelFunc:hH};function pH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i}=n;dt(r,"argMin");let o=$t(i,r.shape);const a=ce(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Cn({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=me(o.length,l.shape.length)),o=[o[0]],qe("argMin",o,l.shape.length);const[u,h]=ze(l.shape,o),d=K(u),p=je(d,"int32"),f=K(h),m=e.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],w=0;for(let x=0;x<f;++x){const v=m[y+x];v<b&&(b=v,w=x)}p[g]=w}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",p)}const fH={kernelName:_c,backendName:"cpu",kernelFunc:pH};const mH=Wt(va,s=>Math.asin(s)),gH={kernelName:va,backendName:"cpu",kernelFunc:mH};const yH=Wt(Sa,s=>Math.asinh(s)),bH={kernelName:Sa,backendName:"cpu",kernelFunc:yH};const xH=Wt(Ca,s=>Math.atan(s)),wH={kernelName:Ca,backendName:"cpu",kernelFunc:xH};const vH=ye((s,t)=>Math.atan2(s,t)),SH=De(ka,vH),CH={kernelName:ka,backendName:"cpu",kernelFunc:SH};const TH=Wt(Ta,s=>Math.atanh(s)),kH={kernelName:Ta,backendName:"cpu",kernelFunc:TH};function Ex(s,t,e,n,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Tt(r.outShape,e),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],w=r.outShape[3];for(let x=0;x<r.batchSize;++x){const v=x*y,C=x*n[0];for(let k=0;k<r.inChannels;++k)for(let I=0;I<r.outHeight;++I){const N=I*o-d,_=Math.max(0,N),T=Math.min(r.inHeight,u+N),D=v+I*b;for(let R=0;R<r.outWidth;++R){const P=R*a-p,B=Math.max(0,P),U=Math.min(r.inWidth,h+P);let H=f,G=0,X=0;for(let J=_;J<T;J+=l){const et=C+J*n[1];for(let Q=B;Q<U;Q+=c){const st=et+Q*n[2],it=s[st+k];i==="max"&&it>H?H=it:i==="avg"&&(G+=it,X++)}if(isNaN(H))break}const Z=D+R*w+k;g[Z]=i==="avg"?G/X:H}}}return m}function YN(s,t,e,n,r=!1,i=!1){const o=Tt(n.outShape,"int32"),a=n.strideHeight,l=n.strideWidth,c=n.dilationHeight,u=n.dilationWidth,h=n.effectiveFilterHeight,d=n.effectiveFilterWidth,p=n.padInfo.top,f=n.padInfo.left,m=Tt(t,e,s);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let b=0;b<n.outHeight;++b){const w=b*a-p;let x=w;for(;x<0;)x+=c;const v=Math.min(n.inHeight,h+w);for(let C=0;C<n.outWidth;++C){const k=C*l-f;let I=k;for(;I<0;)I+=u;const N=Math.min(n.inWidth,d+k);let _=Number.NEGATIVE_INFINITY,T=-1;for(let D=x;D<v;D+=c){const R=D-w;for(let P=I;P<N;P+=u){const B=P-k,U=m.get(g,D,P,y);U>_&&(_=U,r?T=i?((g*n.inHeight+D)*n.inWidth+P)*n.inChannels+y:(D*n.inWidth+P)*n.inChannels+y:T=R*d+B)}}o.set(T,g,b,C,y)}}return o}function ZN(s,t,e,n,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Tt(r.outShape,e),x=w.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let N=0;N<r.batchSize;++N){const _=N*v,T=N*n[0];for(let D=0;D<r.inChannels;++D)for(let R=0;R<r.outDepth;++R){const P=R*o-m;let B=P;for(;B<0;)B+=c;const U=Math.min(r.inDepth,d+P),H=_+R*C;for(let G=0;G<r.outHeight;++G){const X=G*a-g;let Z=X;for(;Z<0;)Z+=u;const J=Math.min(r.inHeight,p+X),et=H+G*k;for(let Q=0;Q<r.outWidth;++Q){const st=Q*l-y;let it=st;for(;it<0;)it+=h;const at=Math.min(r.inWidth,f+st),pt=et+Q*I;let xt=b,bt=0,wt=0;for(let Bt=B;Bt<U;Bt+=c){const qt=T+Bt*n[1];for(let ue=Z;ue<J;ue+=u){const Kt=qt+ue*n[2];for(let Ut=it;Ut<at;Ut+=h){const re=Kt+Ut*n[3],te=s[re+D];if(i==="max"&&te>xt?xt=te:i==="avg"&&(bt+=te,wt++),isNaN(xt))break}if(isNaN(xt))break}if(isNaN(xt))break}const It=pt+D;x[It]=i==="avg"?bt/Math.max(wt,1):xt}}}}return w}function IH(s,t){const e=Tt(t.outShape,"int32"),n=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*n-d;let w=b;for(;w<0;)w+=o;const x=Math.min(t.inDepth,c+b);for(let v=0;v<t.outHeight;++v){const C=v*r-p;let k=C;for(;k<0;)k+=a;const I=Math.min(t.inHeight,u+C);for(let N=0;N<t.outWidth;++N){const _=N*i-f;let T=_;for(;T<0;)T+=l;const D=Math.min(t.inWidth,h+_);let R=Number.NEGATIVE_INFINITY,P=-1;for(let B=w;B<x;B+=o){const U=B-b;for(let H=k;H<I;H+=a){const G=H-C;for(let X=T;X<D;X+=l){const Z=X-_,J=s.get(m,B,H,X,g);J>=R&&(R=J,P=U*u*h+G*u+Z)}}}e.set(P,m,y,v,N,g)}}}return e}function NH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t;dt(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n,c=1;$(Xe(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ds(r.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Dt(u.inShape,u.outShape))h=ir({inputs:{x:r},backend:e});else{const d=e.data.get(r.dataId).values,p=yt(r.shape),f=Ex(d,r.shape,r.dtype,p,u,"avg");h=e.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}const $H={kernelName:Ec,backendName:"cpu",kernelFunc:NH};function _H(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=n;dt(r,"avgPool3d");const u=Mr(r.shape,i,o,1,a,l,c),h=e.data.get(r.dataId).values,d=ZN(h,r.shape,r.dtype,yt(r.shape),u,"avg");return e.makeTensorInfo(d.shape,"float32",d.values)}const EH={kernelName:Dc,backendName:"cpu",kernelFunc:_H};function DH(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=n;dt([r,i],"avgPool3DGrad");const u=Mr(i.shape,o,a,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,w=u.dilationWidth,x=u.effectiveFilterDepth,v=u.effectiveFilterHeight,C=u.effectiveFilterWidth,k=x-1-u.padInfo.front,I=C-1-u.padInfo.left,N=v-1-u.padInfo.top,_=Tt(i.shape,"float32"),T=1/(f*m*g),D=e.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let P=0;P<u.inChannels;++P)for(let B=0;B<u.inDepth;++B)for(let U=0;U<u.inHeight;++U)for(let H=0;H<u.inWidth;++H){const G=B-k,X=U-N,Z=H-I;let J=0;for(let et=0;et<x;et+=y){const Q=(G+et)/h;if(!(Q<0||Q>=u.outDepth||Math.floor(Q)!==Q))for(let st=0;st<v;st+=b){const it=(X+st)/d;if(!(it<0||it>=u.outHeight||Math.floor(it)!==it))for(let at=0;at<C;at+=w){const pt=(Z+at)/p;if(pt<0||pt>=u.outWidth||Math.floor(pt)!==pt)continue;const xt=D.get(R,Q,it,pt,P);J+=xt}}}_.set(J*T,R,B,U,H,P)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const AH={kernelName:Np,backendName:"cpu",kernelFunc:DH};function OH(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,o=i;dt([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=n,u=ds(o.shape,a,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,w=b-1-u.padInfo.left,x=y-1-u.padInfo.top,v=Tt(o.shape,"float32"),C=1/(p*f),k=e.data.get(r.dataId).values,I=Tt(r.shape,"float32",k);for(let N=0;N<u.batchSize;++N)for(let _=0;_<u.inChannels;++_)for(let T=0;T<u.inHeight;++T)for(let D=0;D<u.inWidth;++D){const R=T-x,P=D-w;let B=0;for(let U=0;U<y;U+=m){const H=(R+U)/h;if(!(H<0||H>=u.outHeight||Math.floor(H)!==H))for(let G=0;G<b;G+=g){const X=(P+G)/d;if(X<0||X>=u.outWidth||Math.floor(X)!==X)continue;const Z=I.get(N,H,X,_);B+=Z}}v.set(B*C,N,T,D,_)}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const RH={kernelName:Ip,backendName:"cpu",kernelFunc:OH};function FH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,scale:i,offset:o,mean:a,variance:l}=t;$(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),dt([r,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=n;c==null&&(c=.001);const u=e.data.get(r.dataId).values,h=e.data.get(a.dataId).values,d=e.data.get(l.dataId).values,p=i?e.data.get(i.dataId).values:new Float32Array([1]),f=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,w=h.length;let x=0,v=0,C=0,k=0;for(let I=0;I<u.length;++I)m[I]=f[x++]+(u[I]-h[v++])*p[C++]/Math.sqrt(d[k++]+c),x>=g&&(x=0),v>=w&&(v=0),C>=y&&(C=0),k>=b&&(k=0);return e.makeTensorInfo(r.shape,r.dtype,m)}const PH={kernelName:jc,backendName:"cpu",kernelFunc:FH};function LH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockShape:i,crops:o}=n;dt([r],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Ku(r.shape,i,a),c=Yu(l.length,i.length),u=Zu(r.shape,i,a),h=Mb(o,i.length),d=Bb(u,o,i.length),p=Jt({inputs:{x:r},backend:e,attrs:{shape:l}}),f=Cn({inputs:{x:p},backend:e,attrs:{perm:c}}),m=Jt({inputs:{x:f},backend:e,attrs:{shape:u}}),g=mo({inputs:{x:m},backend:e,attrs:{begin:h,size:d}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}const MH={kernelName:Oc,backendName:"cpu",kernelFunc:LH};function BH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,weights:i}=t,{size:o}=n,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,c=kx(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}const zH={kernelName:$p,backendName:"cpu",kernelFunc:BH};function VH(s){const{inputs:t,backend:e}=s,{s0:n,s1:r}=t,i=e.data.get(n.dataId).values,o=e.data.get(r.dataId).values,a=St(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const WH={kernelName:_p,backendName:"cpu",kernelFunc:VH};const UH=Wt($a,(s,t)=>{const e=t;return s>e.clipValueMax?e.clipValueMax:s<e.clipValueMin?e.clipValueMin:s}),GH={kernelName:$a,backendName:"cpu",kernelFunc:UH};const jH=s=>{const{x:t}=s.inputs,e=s.backend,n=new Float32Array(K(t.shape)),r=e.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];n[c]=Math.hypot(u,h)}return e.makeOutput(n,t.shape,"float32")},HH={kernelName:Fc,backendName:"cpu",kernelFunc:jH};function la(s){const{inputs:t,backend:e}=s,{input:n}=t,r=e.data.get(n.dataId).complexTensorInfos.imag,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const XH={kernelName:Kp,backendName:"cpu",kernelFunc:la};function ca(s){const{inputs:t,backend:e,attrs:n}=s,{axis:r}=n,i=$t(r,t[0].shape)[0],o=t.map(m=>m.shape);Fb(o,i);let a=Ys(t.map(m=>m.shape),i);if(K(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>K(m.shape)>0);if(l.length===1)return ir({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){const m=l.map(x=>fo({inputs:{input:x},backend:e})),g=l.map(x=>la({inputs:{input:x},backend:e})),y=ca({inputs:m,backend:e,attrs:{axis:i}}),b=ca({inputs:g,backend:e,attrs:{axis:i}}),w=_n({inputs:{real:y,imag:b},backend:e});return m.forEach(x=>e.disposeIntermediateTensorInfo(x)),g.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}const c=l.map(m=>{const y=[-1,K(m.shape.slice(i))];return Jt({inputs:{x:m},backend:e,attrs:{shape:y}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=Ys(c.map(m=>m.shape),1);const h=c[0].shape[0]===1,d=nN(u,a,t[0].dtype,h),p=Ys(l.map(m=>m.shape),i),f=e.makeTensorInfo(p,t[0].dtype,d);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const qH={kernelName:Pc,backendName:"cpu",kernelFunc:ca};function JN(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=n;dt([r,i],"conv2d");const h=Br(l),d=Be(r.shape,i.shape,o,c,a,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,w=d.dataFormat==="channelsLast",x=new Ce(d.outShape,r.dtype),v=yt(r.shape),C=yt(i.shape),k=v[0],I=w?v[1]:v[2],N=w?v[2]:1,_=w?1:v[1],T=x.strides[0],D=w?x.strides[1]:x.strides[2],R=w?x.strides[2]:1,P=w?1:x.strides[1],B=e.data.get(r.dataId).values,U=e.data.get(i.dataId).values,H=x.values;for(let G=0;G<d.batchSize;++G){const X=G*k,Z=G*T;for(let J=0;J<d.outHeight;++J){const et=Z+J*D,Q=J*d.strideHeight-b;for(let st=0;st<p;++st){const it=Q+st*m;if(it<0||it>=d.inHeight)continue;const at=st*C[0],pt=X+it*I;for(let xt=0;xt<d.outWidth;++xt){const bt=et+xt*R,wt=xt*d.strideWidth-y;for(let It=0;It<f;++It){const Bt=wt+It*g;if(Bt<0||Bt>=d.inWidth)continue;const qt=at+It*C[1],ue=pt+Bt*N;let Kt=qt;for(let Ut=0;Ut<d.inChannels;++Ut){const re=B[ue+Ut*_];for(let te=0;te<d.outChannels;++te)H[bt+te*P]+=re*U[Kt+te];Kt+=d.outChannels}}}}}}return e.makeTensorInfo(x.shape,x.dtype,H)}const KH={kernelName:Lc,backendName:"cpu",kernelFunc:JN};function YH(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=n;dt([r,i],"conv2dBackpropFilter");const h=Br(l),d=Be(r.shape,u,o,1,a,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",b=new Ce(d.filterShape,"float32"),w=d.padInfo.left,x=d.padInfo.top,v=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,k=new Ce(r.shape,r.dtype,v),I=new Ce(i.shape,i.dtype,C);for(let N=0;N<m;++N){const _=Math.max(0,Math.ceil((x-N)/p)),T=Math.min(d.outHeight,(d.inHeight+x-N)/p);for(let D=0;D<g;++D){const R=Math.max(0,Math.ceil((w-D)/f)),P=Math.min(d.outWidth,(d.inWidth+w-D)/f);for(let B=0;B<d.inChannels;++B)for(let U=0;U<d.outChannels;++U){let H=0;for(let G=0;G<d.batchSize;++G)for(let X=_;X<T;++X){const Z=N+X*p-x;for(let J=R;J<P;++J){const et=D+J*f-w;y?H+=k.get(G,Z,et,B)*I.get(G,X,J,U):H+=k.get(G,B,Z,et)*I.get(G,U,X,J)}}b.set(H,N,D,B,U)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const ZH={kernelName:Dp,backendName:"cpu",kernelFunc:YH};function JH(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=n;dt([r,i],"conv2dBackpropInput");const h=yt(i.shape),d=yt(r.shape);let p=Br(c);const f=Be(o,i.shape,a,1,l,u,!1,p),m=new Ce(f.inShape,"float32"),g=m.values,y=e.data.get(r.dataId).values,b=e.data.get(i.dataId).values,[w,x,v]=h,{batchSize:C,filterHeight:k,filterWidth:I,inChannels:N,inHeight:_,inWidth:T,outChannels:D,outHeight:R,outWidth:P,strideHeight:B,strideWidth:U}=f;p=f.dataFormat;const H=k-1-f.padInfo.top,G=I-1-f.padInfo.left,X=p==="channelsLast",Z=m.strides[0],J=X?m.strides[1]:m.strides[2],et=X?m.strides[2]:1,Q=X?1:m.strides[1],st=d[0],it=X?d[1]:d[2],at=X?d[2]:1,pt=X?1:d[1];for(let xt=0;xt<C;++xt)for(let bt=0;bt<N;++bt)for(let wt=0;wt<_;++wt){const It=wt-H,Bt=Math.max(0,Math.ceil(It/B)),qt=Math.min(R,(k+It)/B);for(let ue=0;ue<T;++ue){const Kt=ue-G,Ut=Math.max(0,Math.ceil(Kt/U)),re=Math.min(P,(I+Kt)/U);let te=0;for(let Ve=Bt;Ve<qt;++Ve){const jr=Ve*B-It;for(let Wn=Ut;Wn<re;++Wn){const Ei=Wn*U-Kt,ms=st*xt+it*Ve+at*Wn,ur=w*(k-1-jr)+x*(I-1-Ei)+v*bt;for(let Hr=0;Hr<D;++Hr){const Xr=y[ms+pt*Hr],qr=b[ur+Hr];te+=Xr*qr}}}const cr=Z*xt+J*wt+et*ue+Q*bt;g[cr]=te}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const QH={kernelName:Mc,backendName:"cpu",kernelFunc:JH};function t5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=n;dt([r,i],"conv3d");const c=Si(r.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,w=g.top,x=new Ce(c.outShape,r.dtype),v=e.data.get(r.dataId).values,C=e.data.get(i.dataId).values,k=x.values,I=yt(r.shape),N=yt(i.shape);for(let _=0;_<c.batchSize;++_){const T=_*I[0],D=_*x.strides[0];for(let R=0;R<c.outDepth;++R){const P=D+R*x.strides[1],B=R*c.strideDepth-y;for(let U=0;U<u;++U){const H=B+U*p;if(H<0||H>=c.inDepth)continue;const G=U*N[0],X=T+H*I[1];for(let Z=0;Z<c.outHeight;++Z){const J=P+Z*x.strides[2],et=Z*c.strideHeight-w;for(let Q=0;Q<h;++Q){const st=et+Q*f;if(st<0||st>=c.inHeight)continue;const it=G+Q*N[1],at=X+st*I[2];for(let pt=0;pt<c.outWidth;++pt){const xt=J+pt*c.outChannels,bt=pt*c.strideWidth-b;for(let wt=0;wt<d;++wt){const It=bt+wt*m;if(It<0||It>=c.inWidth)continue;const Bt=it+wt*N[2],qt=at+It*c.inChannels;let ue=Bt;for(let Kt=0;Kt<c.inChannels;++Kt){const Ut=v[qt+Kt];for(let re=0;re<c.outChannels;++re)k[xt+re]+=Ut*C[ue+re];ue+=c.outChannels}}}}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const e5={kernelName:Bc,backendName:"cpu",kernelFunc:t5};function n5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=n;dt([r,i],"conv3dBackpropFilterV2");const c=yt(r.shape),u=yt(i.shape),h=Si(r.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Ce(h.filterShape,"float32"),w=b.values,[x,v,C,k]=b.strides,I=e.data.get(i.dataId).values,[N,_,T,D]=u,R=e.data.get(r.dataId).values,[P,B,U,H]=c,G=h.padInfo.front,X=h.padInfo.left,Z=h.padInfo.top;for(let J=0;J<m;++J){const et=Math.max(0,Math.ceil((G-J)/d)),Q=Math.min(h.outDepth,(h.inDepth+G-J)/d),st=J*x;for(let it=0;it<g;++it){const at=Math.max(0,Math.ceil((Z-it)/p)),pt=Math.min(h.outHeight,(h.inHeight+Z-it)/p),xt=it*v+st;for(let bt=0;bt<y;++bt){const wt=Math.max(0,Math.ceil((X-bt)/f)),It=Math.min(h.outWidth,(h.inWidth+X-bt)/f),Bt=bt*C+xt;for(let qt=0;qt<h.inChannels;++qt){const ue=qt*k+Bt;for(let Kt=0;Kt<h.outChannels;++Kt){let Ut=0;for(let re=0;re<h.batchSize;++re){const te=re*P,cr=re*N;for(let Ve=et;Ve<Q;++Ve){const Wn=(J+Ve*d-G)*B+te,Ei=Ve*_+cr;for(let ms=at;ms<pt;++ms){const Hr=(it+ms*p-Z)*U+Wn,Xr=ms*T+Ei;for(let qr=wt;qr<It;++qr){const Bm=(bt+qr*f-X)*H+Hr,zm=qr*D+Xr;Ut+=R[Bm+qt]*I[zm+Kt]}}}}w[ue+Kt]=Ut}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const s5={kernelName:Ap,backendName:"cpu",kernelFunc:n5};function r5(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=n;dt([r],"conv3dBackpropInputV2");const c=yt(r.shape),u=yt(i.shape),h=Si(l,i.shape,a,1,o),d=new Ce(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=e.data.get(r.dataId).values,[w,x,v,C]=c,k=e.data.get(i.dataId).values,[I,N,_,T]=u,{batchSize:D,filterDepth:R,filterHeight:P,filterWidth:B,inChannels:U,inDepth:H,inHeight:G,inWidth:X,outChannels:Z,outDepth:J,outHeight:et,outWidth:Q,strideDepth:st,strideHeight:it,strideWidth:at}=h,pt=R-1-h.padInfo.front,xt=P-1-h.padInfo.top,bt=B-1-h.padInfo.left;for(let wt=0;wt<D;++wt)for(let It=0;It<U;++It)for(let Bt=0;Bt<H;++Bt){const qt=Bt-pt,ue=Math.max(0,Math.ceil(qt/st)),Kt=Math.min(J,(R+qt)/st);for(let Ut=0;Ut<G;++Ut){const re=Ut-xt,te=Math.max(0,Math.ceil(re/it)),cr=Math.min(et,(P+re)/it);for(let Ve=0;Ve<X;++Ve){const jr=Ve-bt,Wn=Math.max(0,Math.ceil(jr/at)),Ei=Math.min(Q,(B+jr)/at);let ms=0;for(let ur=ue;ur<Kt;++ur){const Hr=ur*st-qt;for(let Xr=te;Xr<cr;++Xr){const qr=Xr*it-re;for(let El=Wn;El<Ei;++El){const Bm=El*at-jr,zm=w*wt+x*ur+v*Xr+C*El,Z$=I*(R-1-Hr)+N*(P-1-qr)+_*(B-1-Bm)+T*It;for(let dh=0;dh<Z;++dh){const J$=b[zm+dh],Q$=k[Z$+dh];ms+=J$*Q$}}}}p[f*wt+m*Bt+g*Ut+y*Ve+It]=ms}}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}const i5={kernelName:Op,backendName:"cpu",kernelFunc:r5};const o5=Wt(_a,s=>Math.cos(s)),a5={kernelName:_a,backendName:"cpu",kernelFunc:o5};const l5=Wt(Ea,s=>Math.cosh(s)),c5={kernelName:Ea,backendName:"cpu",kernelFunc:l5};function u5(s){const{inputs:t,backend:e,attrs:n}=s,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=n,[u,h,d,p]=r.shape,f=i.shape[0],[m,g]=a,y=Tt([f,m,g,p],"float32"),b=e.data.get(i.dataId).values,w=e.data.get(o.dataId).values,x=e.data.get(r.dataId).values,v=yt(r.shape),C=yt(y.shape);for(let k=0;k<f;k++){const I=k*4,N=b[I],_=b[I+1],T=b[I+2],D=b[I+3],R=w[k];if(R>=u)continue;const P=m>1?(T-N)*(h-1)/(m-1):0,B=g>1?(D-_)*(d-1)/(g-1):0;for(let U=0;U<m;U++){const H=m>1?N*(h-1)+U*P:.5*(N+T)*(h-1);if(H<0||H>h-1){for(let G=0;G<g;G++)for(let X=0;X<p;X++){const Z=X+G*C[2]+U*C[1]+k*C[0];y.values[Z]=c}continue}if(l==="bilinear"){const G=Math.floor(H),X=Math.ceil(H),Z=H-G;for(let J=0;J<g;J++){const et=g>1?_*(d-1)+J*B:.5*(_+D)*(d-1);if(et<0||et>d-1){for(let at=0;at<p;at++){const pt=at+J*C[2]+U*C[1]+k*C[0];y.values[pt]=c}continue}const Q=Math.floor(et),st=Math.ceil(et),it=et-Q;for(let at=0;at<p;at++){let pt=at+Q*v[2]+G*v[1]+R*v[0];const xt=x[pt];pt=at+st*v[2]+G*v[1]+R*v[0];const bt=x[pt];pt=at+Q*v[2]+X*v[1]+R*v[0];const wt=x[pt];pt=at+st*v[2]+X*v[1]+R*v[0];const It=x[pt],Bt=xt+(bt-xt)*it,qt=wt+(It-wt)*it;pt=at+J*C[2]+U*C[1]+k*C[0],y.values[pt]=Bt+(qt-Bt)*Z}}}else for(let G=0;G<g;++G){const X=g>1?_*(d-1)+G*B:.5*(_+D)*(d-1);if(X<0||X>d-1){for(let et=0;et<p;et++){const Q=et+G*C[2]+U*C[1]+k*C[0];y.values[Q]=c}continue}const Z=Math.round(X),J=Math.round(H);for(let et=0;et<p;et++){const Q=et+Z*v[2]+J*v[1]+R*v[0],st=et+G*C[2]+U*C[1]+k*C[0];y.values[st]=x[Q]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}const h5={kernelName:Fp,backendName:"cpu",kernelFunc:u5};function d5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,exclusive:o,reverse:a}=n;dt(r,"cumprod");const l=ce([i],r.shape.length);let c=r;l!=null&&(c=Cn({inputs:{x:r},backend:e,attrs:{perm:l}}));const u=me(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=bn(c.dtype,"int32"),d=Cp(K(c.shape),h),p=e.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const w=m(y,b);if(b===0)d[w]=o?1:p[w];else{const x=m(y,b-1);d[w]=o?p[x]*d[x]:p[w]*d[x]}}const g=e.makeTensorInfo(c.shape,h,d);if(l!=null){const y=Ci(l),b=Cn({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}const p5={kernelName:Rp,backendName:"cpu",kernelFunc:d5};function f5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,exclusive:o,reverse:a}=n;dt(r,"cumsum");const l=ce([i],r.shape.length);let c=r;l!=null&&(c=Cn({inputs:{x:r},backend:e,attrs:{perm:l}}));const u=me(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=bn(c.dtype,"int32"),d=je(K(c.shape),h),p=e.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=a?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const w=m(y,b);if(b===0)d[w]=o?0:p[w];else{const x=m(y,b-1);d[w]=o?p[x]+d[x]:p[w]+d[x]}}const g=e.makeTensorInfo(c.shape,h,d);if(l!=null){const y=Ci(l),b=Cn({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}const m5={kernelName:zc,backendName:"cpu",kernelFunc:f5};function g5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,weights:i}=t,{size:o,binaryOutput:a}=n;if(r.shape.length===1){const l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,u=kx(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}else if(r.shape.length===2){const l=e.bufferSync(r),c=e.bufferSync(i),u=Q2(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const y5={kernelName:Pp,backendName:"cpu",kernelFunc:g5};function b5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockSize:i,dataFormat:o}=n;$(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],c=r.shape[2],u=r.shape[3],h=l*i,d=c*i,p=u/(i*i),f=e.data.get(r.dataId).values,m=new Float32Array(a*h*d*p);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const w=Math.floor(b/i),x=b%i;for(let v=0;v<d;++v){const C=Math.floor(v/i),k=v%i,I=(x*i+k)*p;for(let N=0;N<p;++N){const T=N+I+u*(C+c*(w+l*y));m[g++]=f[T]}}}return e.makeTensorInfo([a,h,d,p],r.dtype,m)}const x5={kernelName:Lp,backendName:"cpu",kernelFunc:b5};function QN(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=n;dt([r,i],"depthwiseConv2DNative");const u=yt(r.shape),h=yt(i.shape);let d=l;d==null&&(d=[1,1]),$(Xe(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Be(r.shape,i.shape,o,d,a,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,w=b.left,x=b.top,v=p.outChannels/p.inChannels,C=new Ce(p.outShape,r.dtype),k=e.data.get(r.dataId).values,I=e.data.get(i.dataId).values,N=C.values;for(let _=0;_<p.batchSize;++_){const T=_*u[0],D=_*C.strides[0];for(let R=0;R<p.outHeight;++R){const P=D+R*C.strides[1],B=R*p.strideHeight-x;for(let U=0;U<f;++U){const H=B+U*g;if(H<0||H>=p.inHeight)continue;const G=U*h[0],X=T+H*u[1];for(let Z=0;Z<p.outWidth;++Z){const J=P+Z*C.strides[2],et=Z*p.strideWidth-w;for(let Q=0;Q<m;++Q){const st=et+Q*y;if(st<0||st>=p.inWidth)continue;const it=G+Q*h[1],at=X+st*p.inChannels;let pt=J,xt=it;for(let bt=0;bt<p.inChannels;++bt){const wt=k[at+bt];for(let It=0;It<v;++It)N[pt+It]+=wt*I[xt+It];pt+=v,xt+=v}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const w5={kernelName:Vc,backendName:"cpu",kernelFunc:QN};function v5(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=n;dt([r,i],"depthwiseConv2dNativeBackpropFilter");const h=Be(r.shape,u,o,a,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Ce(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,w=h.outChannels/h.inChannels,x=e.data.get(r.dataId).values,v=new Ce(r.shape,r.dtype,x),C=e.data.get(i.dataId).values,k=new Ce(i.shape,i.dtype,C);for(let I=0;I<f;++I){const N=Math.max(0,Math.ceil((b-I)/d)),_=Math.min(h.outHeight,(h.inHeight+b-I)/d);for(let T=0;T<m;++T){const D=Math.max(0,Math.ceil((y-T)/p)),R=Math.min(h.outWidth,(h.inWidth+y-T)/p);for(let P=0;P<h.outChannels;++P){const B=Math.trunc(P/w),U=P%w;let H=0;for(let G=0;G<h.batchSize;++G)for(let X=N;X<_;++X){const Z=I+X*d-b;for(let J=D;J<R;++J){const et=T+J*p-y;H+=v.get(G,Z,et,B)*k.get(G,X,J,P)}}g.set(H,I,T,B,U)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const S5={kernelName:Mp,backendName:"cpu",kernelFunc:v5};function C5(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=n;dt([r,i],"depthwiseConv2DNativeBackpropInput");const h=yt(r.shape),d=yt(i.shape),p=Be(u,i.shape,o,a,l,c,!0),f=new Ce(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,w=e.data.get(r.dataId).values,[x,v,C]=h,k=e.data.get(i.dataId).values,[I,N,_]=d,{batchSize:T,filterHeight:D,filterWidth:R,inChannels:P,inHeight:B,inWidth:U,outChannels:H,outHeight:G,outWidth:X,strideHeight:Z,strideWidth:J}=p,et=D-1-p.padInfo.top,Q=R-1-p.padInfo.left,st=H/P;for(let it=0;it<T;++it)for(let at=0;at<P;++at)for(let pt=0;pt<B;++pt){const xt=pt-et,bt=Math.max(0,Math.ceil(xt/Z)),wt=Math.min(G,(D+xt)/Z);for(let It=0;It<U;++It){const Bt=It-Q,qt=Math.max(0,Math.ceil(Bt/J)),ue=Math.min(X,(R+Bt)/J);let Kt=0;for(let Ut=bt;Ut<wt;++Ut){const re=Ut*Z-xt;for(let te=qt;te<ue;++te){const cr=te*J-Bt,Ve=x*it+v*Ut+C*te,jr=I*(D-1-re)+N*(R-1-cr)+_*at;for(let Wn=0;Wn<st;++Wn){const Ei=at*st+Wn,ms=w[Ve+Ei],ur=k[jr+Wn];Kt+=ms*ur}}}m[g*it+y*pt+b*It+at]=Kt}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}const T5={kernelName:Bp,backendName:"cpu",kernelFunc:C5};function k5(s){const{inputs:t,backend:e}=s,{x:n}=t,r=K(n.shape),i=e.data.get(n.dataId).values,o=Tt([r,r],n.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*r+c]=i[c];const l=[...n.shape,...n.shape];return e.makeTensorInfo(l,o.dtype,o.values)}const I5={kernelName:zp,backendName:"cpu",kernelFunc:k5};const N5={kernelName:Wc,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:n,filter:r}=s,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(n.dataId).values,u=n.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:x,strideWidth:v,filterHeight:C,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:_}=Du(n.shape,r.shape,i,o,"NHWC",a),T=K(_),D=_.length,R=de(n.dtype,T);for(let B=0;B<p;++B)for(let U=0;U<y;++U){const H=U*x-w.top;for(let G=0;G<b;++G){const X=G*v-w.left;for(let Z=0;Z<g;++Z){let J=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<C;++Q){const st=H+Q*I;if(st>=0&&st<f)for(let it=0;it<k;++it){const at=X+it*N;if(at>=0&&at<m){const pt=$s([B,st,at,Z],u,yt(n.shape)),xt=$s([Q,it,Z],d,yt(r.shape)),bt=c[pt]+h[xt];bt>J&&(J=bt)}}}const et=$s([B,U,G,Z],D,yt(_));R[et]=J}}}return{dataId:l.write(wi(R,n.dtype),_,n.dtype),shape:_,dtype:n.dtype}}};const $5={kernelName:Bd,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:n,filter:r,dy:i}=s,{strides:o,pad:a,dilations:l}=e,c=t,u=Kn(n.shape,c.data.get(n.dataId).values),h=Kn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:C,dilationHeight:k,dilationWidth:I,outShape:N}=Du(n.shape,r.shape,o,a,"NHWC",l);$(i.rank===N.length,()=>`Error in ${Bd}, dy must have the same rank as output ${N.length}, but got ${i.rank}`);const _=Kn(N,c.data.get(i.dataId).values),T=n0(r.shape,r.dtype);for(let R=0;R<d;++R)for(let P=0;P<g;++P){const B=P*w-b.top;for(let U=0;U<y;++U){const H=U*x-b.left;for(let G=0;G<m;++G){let X=Number.MIN_SAFE_INTEGER,Z=0,J=0;for(let et=0;et<v;++et){const Q=B+et*k;if(Q>=0&&Q<p)for(let st=0;st<C;++st){const it=H+st*I;if(it>=0&&it<f){const at=u[R][Q][it][G]+h[et][st][G];at>X&&(X=at,Z=et,J=st)}}}T[Z][J][G]+=_[R][P][U][G]}}}return{dataId:c.write(wi(T,n.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const _5={kernelName:Md,backendName:"cpu",kernelFunc:({inputs:s,backend:t,attrs:e})=>{const{x:n,filter:r,dy:i}=s,{strides:o,pad:a,dilations:l}=e,c=t,u=Kn(n.shape,c.data.get(n.dataId).values),h=Kn(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:C,dilationHeight:k,dilationWidth:I,outShape:N}=Du(n.shape,r.shape,o,a,"NHWC",l);$(i.rank===N.length,()=>`Error in ${Md}, dy must have the same rank as output ${N.length}, but got ${i.rank}`);const _=Kn(N,c.data.get(i.dataId).values),T=n0(n.shape,n.dtype);for(let R=0;R<d;++R)for(let P=0;P<g;++P){const B=P*w-b.top;for(let U=0;U<y;++U){const H=U*x-b.left;for(let G=0;G<m;++G){let X=Number.MIN_SAFE_INTEGER,Z=B<0?0:B,J=H<0?0:H;for(let et=0;et<v;++et){const Q=B+et*k;if(Q>=0&&Q<p)for(let st=0;st<C;++st){const it=H+st*I;if(it>=0&&it<f){const at=u[R][Q][it][G]+h[et][st][G];at>X&&(X=at,Z=Q,J=it)}}}T[R][Z][J][G]+=_[R][P][U][G]}}}return{dataId:c.write(wi(T,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function E5(s){const{inputs:t,backend:e,attrs:n}=s,{image:r}=t,{canvas:i,options:o}=n,{contextOptions:a,imageOptions:l}=o||{},c=l?.alpha||1,u=a?.contextType||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(u,a?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],m=e.data.get(r.dataId).values,g=r.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*d*4);for(let w=0;w<d*p;++w){const x=[0,0,0,255*c];for(let C=0;C<f;C++){const k=m[w*f+C];if(r.dtype==="float32"){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if(r.dtype==="int32"&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);f===1?(x[0]=k*g,x[1]=k*g,x[2]=k*g):x[C]=k*g}const v=w*4;y[v+0]=Math.round(x[0]),y[v+1]=Math.round(x[1]),y[v+2]=Math.round(x[2]),y[v+3]=Math.round(x[3])}i.width=p,i.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),r}const D5={kernelName:Vp,backendName:"cpu",kernelFunc:E5};function oh(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;dt(r,"sum");let a;r.dtype==="bool"?a=bi({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):a=ir({inputs:{x:r},backend:e});const l=a.shape.length,c=$t(i,a.shape),u=ce(c,l);let h=c,d=a;u!=null&&(d=Cn({inputs:{x:a},backend:e,attrs:{perm:u}}),h=me(h.length,l)),qe("sum",h,d.shape.length);const[p,f]=ze(d.shape,h),m=bn(d.dtype,"int32");let g=ep(e,p,m);const y=K(f),b=e.data.get(g.dataId).values,w=e.data.get(d.dataId).values;for(let x=0;x<b.length;++x){const v=x*y;let C=0;for(let k=0;k<y;++k)C+=w[v+k];b[x]=C}if(o){const x=fe(g.shape,c),v=g;g=Jt({inputs:{x:g},backend:e,attrs:{shape:x}}),e.disposeIntermediateTensorInfo(v)}return e.disposeIntermediateTensorInfo(a),u!=null&&e.disposeIntermediateTensorInfo(d),g}const A5={kernelName:vu,backendName:"cpu",kernelFunc:oh};function O5(s){const{inputs:t,backend:e,attrs:n}=s,{equation:r}=n,i=t,{allDims:o,summedDims:a,idDims:l}=Xb(r,i.length);Kb(o.length,l,i);const{path:c,steps:u}=Yb(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=qb(p,l[g]);let w;Zb(y)?w=i[g]:(w=Cn({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),f.push(w));const x=w.shape.slice();for(let v=0;v<b.length;++v)x.splice(b[v],0,1);Dt(w.shape,x)||(w=Jt({inputs:{x:w},backend:e,attrs:{shape:x}}),f.push(w)),d===null?d=w:(d=Om({inputs:{a:w,b:d},backend:e}),f.push(d))}m<h-1&&(c[m]>=0&&(d=oh({inputs:{x:d},backend:e,attrs:{axis:c[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&e.disposeIntermediateTensorInfo(m);return d}const R5={kernelName:Wp,backendName:"cpu",kernelFunc:O5};function F5(s){const{inputs:t,backend:e}=s,{dy:n,y:r}=t;dt([n,r],"eluGrad");const i=new Float32Array(K(r.shape)),o=e.data.get(r.dataId).values,a=e.data.get(n.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return e.makeTensorInfo(r.shape,"float32",i)}const P5={kernelName:Up,backendName:"cpu",kernelFunc:F5};const L5=zb,M5=Vb,B5=Wb,z5=Ub,V5=Gb,W5=jb,U5=Wt(Oa,s=>{const t=Math.sign(s),e=Math.abs(s),n=1/(1+L5*e);return t*(1-((((W5*n+V5)*n+z5)*n+B5)*n+M5)*n*Math.exp(-e*e))}),G5={kernelName:Oa,backendName:"cpu",kernelFunc:U5};function rp(s){const{inputs:t,backend:e,attrs:n}=s,{input:r}=t,{dim:i}=n,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&($(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Jt({inputs:{x:r},backend:e,attrs:{shape:a}})}const j5={kernelName:Gc,backendName:"cpu",kernelFunc:rp};const H5=ye((s,t)=>s/t),Dx=De(Da,H5),Ny={kernelName:Da,backendName:"cpu",kernelFunc:Dx};function t$(s,t,e){const n=s.shape,r=n[0],i=n[1],o=e.data.get(s.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,i],u=K(c),h=Le("float32",u),d=Le("float32",u);for(let g=0;g<r;g++){const y=mo({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,i]}}),b=mo({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,i]}}),w=_n({inputs:{real:y,imag:b},backend:e}),{real:x,imag:v}=X5(w,t,e),C=Ar(x,v);for(let k=0;k<i;k++){const I=Hb(C,k);h[g*i+k]=I.real,d[g*i+k]=I.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w)}const p=e.makeTensorInfo(c,"float32",h),f=e.makeTensorInfo(c,"float32",d),m=_n({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),m}function X5(s,t,e){const n=K(s.shape),r=e.data.get(s.dataId),i=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(q5(n)){const a=$y(i,o,n,t,e),l=[s.shape[0],s.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),h=e.makeTensorInfo([],"float32",Lr(n,"float32")),d=ir({inputs:{x:h},backend:e}),p=Ny.kernelFunc({inputs:{a:c,b:h},backend:e}),f=Ny.kernelFunc({inputs:{a:u,b:d},backend:e}),m=e.data.get(p.dataId).values,g=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return a}else{const a=Ar(i,o),l=K5(a,n,t);return qT(l)}}function q5(s){return(s&s-1)===0}function $y(s,t,e,n,r){if(e===1)return{real:s,imag:t};const i=Ar(s,t),o=e/2,a=KT(i),l=a.real,c=a.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),d=r.makeTensorInfo(u,"float32",c),p=_n({inputs:{real:h,imag:d},backend:r}),f=YT(i),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),w=r.makeTensorInfo(y,"float32",g),x=_n({inputs:{real:b,imag:w},backend:r}),v=$y(l,c,o,n,r),C=v.real,k=v.imag,I=[C.length],N=r.makeTensorInfo(I,"float32",C),_=r.makeTensorInfo(I,"float32",k),T=_n({inputs:{real:N,imag:_},backend:r}),D=$y(m,g,o,n,r),R=D.real,P=D.imag,B=[R.length],U=r.makeTensorInfo(B,"float32",R),H=r.makeTensorInfo(B,"float32",P),G=_n({inputs:{real:U,imag:H},backend:r}),X=JT(e,n),Z=[X.real.length],J=r.makeTensorInfo(Z,"float32",X.real),et=r.makeTensorInfo(Z,"float32",X.imag),Q=_n({inputs:{real:J,imag:et},backend:r}),st=Om({inputs:{a:Q,b:G},backend:r}),it=aa({inputs:{a:T,b:st},backend:r}),at=_x({inputs:{a:T,b:st},backend:r}),pt=fo({inputs:{input:it},backend:r}),xt=fo({inputs:{input:at},backend:r}),bt=la({inputs:{input:it},backend:r}),wt=la({inputs:{input:at},backend:r}),It=ca({inputs:[pt,xt],backend:r,attrs:{axis:0}}),Bt=ca({inputs:[bt,wt],backend:r,attrs:{axis:0}}),qt=r.data.get(It.dataId).values,ue=r.data.get(Bt.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(et),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(st),r.disposeIntermediateTensorInfo(it),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(pt),r.disposeIntermediateTensorInfo(bt),r.disposeIntermediateTensorInfo(xt),r.disposeIntermediateTensorInfo(wt),r.disposeIntermediateTensorInfo(It),r.disposeIntermediateTensorInfo(Bt),{real:qt,imag:ue}}function K5(s,t,e){const n=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,o=0;for(let a=0;a<t;a++){const l=QT(r*a,t,e),c=Hb(s,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),ZT(n,i,o,r)}return n}function Y5(s){const{inputs:t,backend:e}=s,{input:n}=t,r=K(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Jt({inputs:{x:n},backend:e,attrs:{shape:[o,i]}}),l=t$(a,!1,e),c=Jt({inputs:{x:l},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}const Z5={kernelName:Gp,backendName:"cpu",kernelFunc:Y5};function Ax(s){const{backend:t,attrs:e}=s,{shape:n,value:r,dtype:i}=e,o=i||xo(r),a=de(o,K(n));return Q5(a,r,o),t.makeTensorInfo(n,o,a)}const J5={kernelName:jp,backendName:"cpu",kernelFunc:Ax};function Q5(s,t,e){s.fill(t)}const tX={kernelName:Hp,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:n}=s,r=e,i=Le(n.dtype,K(n.shape)),[o,a,l,c]=n.shape,u=r.data.get(n.dataId).values;for(let d=0;d<o;d++){const p=d*l*a*c;for(let f=0;f<a;f++){const m=f*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const w=Math.round(l-g-1),x=p+m+y+b;let v=u[x];if(w>=0&&w<l){const C=w*c,k=p+m+C+b;v=u[k]}i[x]=v}}}}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function eX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n;let m=JN({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const g=m;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=Jt({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});m=aa({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=aa({inputs:{a:m,b:o},backend:e});e.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(u==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=Jt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=sp(e,m,p,y,f),e.disposeIntermediateTensorInfo(y)}else m=sp(e,m,p,a,f);e.disposeIntermediateTensorInfo(g)}return m}const nX={kernelName:ic,backendName:"cpu",kernelFunc:eX};function sX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n;let m=QN({inputs:{x:r,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const g=m;m=aa({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=sp(e,m,p,a,f),e.disposeIntermediateTensorInfo(g)}return m}const rX={kernelName:oc,backendName:"cpu",kernelFunc:sX};function iX(s){const{inputs:t,backend:e}=s,{params:n,indices:r}=t,i=K(n.shape),o=r.shape,a=o[o.length-1],[l,c,u,h]=gm(n,r);if(c===0)return e.makeTensorInfo(l,n.dtype,[]);const d=e.data.get(r.dataId).values,p=e.bufferSync(n),f=uN(d,p,n.dtype,c,a,u,h,n.shape,i);return e.makeTensorInfo(l,n.dtype,f.values)}const oX={kernelName:Xp,backendName:"cpu",kernelFunc:iX};function aX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,indices:i}=t,{axis:o,batchDims:a}=n;dt([r,i],"gatherV2");const l=$t(o,r.shape)[0],c=e.data.get(i.dataId).values,u=r.shape[l];for(let x=0;x<c.length;++x){const v=c[x];$(v<=u-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const d=K(i.shape),p=Qb(r,i,l,h),f=Jt({inputs:{x:r},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Jt({inputs:{x:i},backend:e,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=e.bufferSync(m),b=e.bufferSync(f),w=hN(b,y,g);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(p.outputShape,w.dtype,w.values)}const lX={kernelName:Hc,backendName:"cpu",kernelFunc:aX};function cX(s){const{inputs:t,backend:e}=s,{input:n}=t,r=K(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Jt({inputs:{x:n},backend:e,attrs:{shape:[o,i]}}),l=t$(a,!0,e),c=Jt({inputs:{x:l},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}const uX={kernelName:qp,backendName:"cpu",kernelFunc:cX};const hX=Wt(za,s=>Number.isFinite(s)?1:0,"bool"),dX={kernelName:za,backendName:"cpu",kernelFunc:hX};const pX=Wt(Va,s=>Math.abs(s)===1/0?1:0,"bool"),fX={kernelName:Va,backendName:"cpu",kernelFunc:pX};const mX=Wt(Wa,s=>Number.isNaN(s)?1:0,"bool"),gX={kernelName:Wa,backendName:"cpu",kernelFunc:mX};function yX(s){const{backend:t,attrs:e}=s,{start:n,stop:r,num:i}=e,o=gN(n,r,i);return t.makeTensorInfo([o.length],"float32",o)}const bX={kernelName:Yp,backendName:"cpu",kernelFunc:yX};const xX=Wt(Ga,s=>Math.log1p(s)),wX={kernelName:Ga,backendName:"cpu",kernelFunc:xX};const vX=ye((s,t)=>s&&t),SX=De(Zc,vX,null,"bool"),CX={kernelName:Zc,backendName:"cpu",kernelFunc:SX};const TX=Wt(Jc,s=>s?0:1,"bool"),kX={kernelName:Jc,backendName:"cpu",kernelFunc:TX};const IX=ye((s,t)=>s||t),NX=De(Qc,IX,null,"bool"),$X={kernelName:Qc,backendName:"cpu",kernelFunc:NX};function _X(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=n;dt(r,"LRN");const c=r.shape[3],u=c-1,h=e.data.get(r.dataId).values,d=K(r.shape),p=new Float32Array(d);function f(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let w=0;for(;y<=b;y++){const x=h[y];w+=x*x}return w}for(let m=0;m<d;m++){const g=f(m),y=h[m]*Math.pow(o+a*g,-l);p[m]=y}return e.makeTensorInfo(r.shape,r.dtype,p)}const EX={kernelName:tu,backendName:"cpu",kernelFunc:_X};function DX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=n;dt(o,"LRNGrad");const h=K(o.shape),d=o.shape[3],p=e.data.get(o.dataId).values,f=e.data.get(r.dataId).values,m=e.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const w=b%d,x=b-w+Math.max(0,w-a),v=b-w+Math.min(d,w+a+1);let C=0;for(let k=x;k<v;k++)C+=Math.pow(f[k],2);C=c*C+l;for(let k=x;k<v;k++){let I=-2*c*u*f[k]*m[b]/C;b===k&&(I+=Math.pow(C,-u)),I*=p[b],g[k]+=I}}return e.makeTensorInfo(o.shape,r.dtype,g)}const AX={kernelName:Zp,backendName:"cpu",kernelFunc:DX};function e$(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{reductionIndices:i,keepDims:o}=n,a=e;let l=r.shape;const c=l.length,u=$t(i,l);let h=u;const d=ce(h,c);let p=a.data.get(r.dataId).values;if(d!=null){const x=new Array(c);for(let v=0;v<x.length;v++)x[v]=l[d[v]];p=Nx(p,l,r.dtype,d,x),h=me(h.length,c),l=x}dt(r,"max"),qe("max",h,c);const[f,m]=ze(l,h),g=K(m),y=bN(p,g,f,r.dtype),b=a.write(y,f,r.dtype);let w=f;return o&&(w=fe(f,u)),{dataId:b,shape:w,dtype:r.dtype}}const OX={kernelName:eu,backendName:"cpu",kernelFunc:e$};function RX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t;dt(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n,c=1;$(Xe(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ds(r.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Dt(u.inShape,u.outShape))h=ir({inputs:{x:r},backend:e});else{const d=e.data.get(r.dataId).values,p=yt(r.shape),f=Ex(d,r.shape,r.dtype,p,u,"max");h=e.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}const FX={kernelName:nu,backendName:"cpu",kernelFunc:RX};function PX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=n;dt(r,"maxPool3d");const u=Mr(r.shape,i,o,1,a,l,c),h=e.data.get(r.dataId).values,d=ZN(h,r.shape,r.dtype,yt(r.shape),u,"max");return e.makeTensorInfo(d.shape,"float32",d.values)}const LX={kernelName:su,backendName:"cpu",kernelFunc:PX};function MX(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=n;dt([r,i],"maxPool3DGrad");const u=Mr(i.shape,o,a,1,l,c),h=e.bufferSync(i),d=IH(h,u),p=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,w=u.effectiveFilterDepth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,C=w-1-u.padInfo.front,k=v-1-u.padInfo.left,I=x-1-u.padInfo.top,N=Tt(i.shape,"float32"),_=e.bufferSync(r);for(let T=0;T<u.batchSize;++T)for(let D=0;D<u.inChannels;++D)for(let R=0;R<u.inDepth;++R)for(let P=0;P<u.inHeight;++P)for(let B=0;B<u.inWidth;++B){const U=R-C,H=P-I,G=B-k;let X=0;for(let Z=0;Z<w;Z+=g){const J=(U+Z)/p;if(!(J<0||J>=u.outDepth||Math.floor(J)!==J))for(let et=0;et<x;et+=y){const Q=(H+et)/f;if(!(Q<0||Q>=u.outHeight||Math.floor(Q)!==Q))for(let st=0;st<v;st+=b){const it=(G+st)/m;if(it<0||it>=u.outWidth||Math.floor(it)!==it)continue;const at=w*x*v-1-d.get(T,J,Q,it,D),pt=Z*x*v+et*v+st,xt=at===pt?1:0;if(xt===0)continue;const bt=_.get(T,J,Q,it,D);X+=bt*xt}}}N.set(X,T,R,P,B,D)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const BX={kernelName:Qp,backendName:"cpu",kernelFunc:MX};function zX(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i,output:o}=t,a=i;dt([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=n,d=ds(a.shape,l,c,1,u,h),p=e.data.get(a.dataId).values,f=Tt(d.outShape,a.dtype,YN(p,a.shape,a.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,w=d.effectiveFilterHeight,x=d.effectiveFilterWidth,v=x-1-d.padInfo.left,C=w-1-d.padInfo.top,k=Tt(a.shape,"float32"),I=e.data.get(r.dataId).values,N=Tt(r.shape,"float32",I);for(let _=0;_<d.batchSize;++_)for(let T=0;T<d.inChannels;++T)for(let D=0;D<d.inHeight;++D)for(let R=0;R<d.inWidth;++R){const P=D-C,B=R-v;let U=0;for(let H=0;H<w;H+=y){const G=(P+H)/m;if(!(G<0||G>=d.outHeight||Math.floor(G)!==G))for(let X=0;X<x;X+=b){const Z=(B+X)/g;if(Z<0||Z>=d.outWidth||Math.floor(Z)!==Z)continue;const J=w*x-1-f.get(_,G,Z,T),et=H*x+X,Q=J===et?1:0;if(Q===0)continue;const st=N.get(_,G,Z,T);U+=st*Q}}k.set(U,_,D,R,T)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const VX={kernelName:Jp,backendName:"cpu",kernelFunc:zX};function WX(s,t,e,n,r){const i=yt(t),o=Ex(s,t,e,i,r,"max"),a=YN(s,t,e,r,!0,n);return[o.values,a.values]}const UX={kernelName:tf,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:n}=s,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;dt(n,"MaxPoolWithArgmax");const c=l.data.get(n.dataId).values,u=ds(n.shape,r,i,[1,1],o),[h,d]=WX(c,n.shape,n.dtype,a,u),p=l.write(h,u.outShape,n.dtype),f=l.write(d,u.outShape,n.dtype);return[{dataId:p,shape:u.outShape,dtype:n.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function GX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n,a=$t(i,r.shape),c=ze(r.shape,a)[1],u=K(c),h=[],d=e.makeTensorInfo([],"float32",new Float32Array([u]));h.push(d);const p=bi({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});h.push(p);const f=Dx({inputs:{a:p,b:d},backend:e});h.push(f);const m=oh({inputs:{x:f},backend:e,attrs:{axis:i,keepDims:o}});return h.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}const jX={kernelName:ru,backendName:"cpu",kernelFunc:GX};function HX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;dt(r,"min");const a=$t(i,r.shape);let l=a;const c=ce(l,r.shape.length);let u=r;c!=null&&(u=Cn({inputs:{x:r},backend:e,attrs:{perm:c}}),l=me(l.length,r.shape.length)),qe("min",l,u.shape.length);const[h,d]=ze(u.shape,l),p=K(d),f=je(K(h),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let w=m[b];for(let x=0;x<p;++x){const v=m[b+x];(Number.isNaN(v)||v<w)&&(w=v)}f[y]=w}c!=null&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(h,u.dtype,f);if(o){const y=fe(h,a),b=Jt({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}const XX={kernelName:iu,backendName:"cpu",kernelFunc:HX};function qX(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{paddings:i,mode:o}=n;dt(r,"mirrorPad");const a=i.map((w,x)=>w[0]+r.shape[x]+w[1]),l=i.map(w=>w[0]),c=i.map((w,x)=>w[0]+r.shape[x]),u=o==="reflect"?0:1,h=e.data.get(r.dataId).values,d=r.shape.length,p=yt(r.shape),f=K(a),m=a.length,g=yt(a),y=Le(r.dtype,f);for(let w=0;w<f;w++){let x=wo(w,m,g);for(let C=0;C<m;C++)x[C]<l[C]?x[C]=l[C]*2-x[C]-u:x[C]>=c[C]&&(x[C]=(c[C]-1)*2-x[C]+u);x=x.map((C,k)=>C-l[k]);const v=$s(x,d,p);y[w]=h[v]}return{dataId:e.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const KX={kernelName:ou,backendName:"cpu",kernelFunc:qX};const YX=ye(((s,t)=>{const e=s%t;return s<0&&t<0||s>=0&&t>=0?e:(e+t)%t})),ZX=De(Xa,YX),JX={kernelName:Xa,backendName:"cpu",kernelFunc:ZX};function n$(s){const{inputs:t,backend:e,attrs:n}=s,{logits:r}=t,{dim:i}=n,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=$t([a],r.shape),c=e$({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=fe(c.shape,l),h=Jt({inputs:{x:c},backend:e,attrs:{shape:u}}),d=_x({inputs:{a:r,b:h},backend:e}),p=oN({inputs:{x:d},backend:e}),f=oh({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),m=Jt({inputs:{x:f},backend:e,attrs:{shape:u}}),g=Dx({inputs:{a:p,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}const QX={kernelName:Tu,backendName:"cpu",kernelFunc:n$};function tq(s){const{inputs:t,backend:e,attrs:n}=s,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=n;dt(r,"multinomial");const l=a?r:n$({inputs:{logits:r},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=e.data.get(l.dataId).values,d=[c,i],p=je(K(d),"int32");for(let f=0;f<c;++f){const m=f*u,g=new Float32Array(u-1);g[0]=h[m];for(let w=1;w<g.length;++w)g[w]=g[w-1]+h[m+w];const y=jf.alea(o.toString()),b=f*i;for(let w=0;w<i;++w){const x=y();p[b+w]=g.length;for(let v=0;v<g.length;v++)if(x<g[v]){p[b+w]=v;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(d,"int32",p)}const eq={kernelName:ef,backendName:"cpu",kernelFunc:tq};const nq=dm;function sq(s){const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=n;dt(r,"NonMaxSuppression");const c=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,{selectedIndices:h}=nq(c,u,o,a,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const rq={kernelName:nf,backendName:"cpu",kernelFunc:sq};const iq=pm;function oq(s){const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=n;dt(r,"NonMaxSuppressionPadded");const u=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=iq(u,h,o,a,l,c);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}const aq={kernelName:sf,backendName:"cpu",kernelFunc:oq};const lq=fm;function cq(s){const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=n;dt(r,"NonMaxSuppressionWithScore");const u=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=lq(u,h,d,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const uq={kernelName:rf,backendName:"cpu",kernelFunc:cq};function hq(s){const{inputs:t,backend:e,attrs:n}=s,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=n;dt(r,"oneHot");const c=K(r.shape),u=new Float32Array(c*o);u.fill(l);const h=e.data.get(r.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=a);return e.makeTensorInfo([...r.shape,o],i,u)}const dq={kernelName:uu,backendName:"cpu",kernelFunc:hq};function ip(s){const{inputs:t,backend:e}=s,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){const r=fo({inputs:{input:n},backend:e}),i=ip({inputs:{x:r},backend:e}),o=la({inputs:{input:n},backend:e}),a=ip({inputs:{x:o},backend:e}),l=_n({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return Ax({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}const pq={kernelName:$u,backendName:"cpu",kernelFunc:ip};function s$(s){const{inputs:t,backend:e}=s,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){const r=fo({inputs:{input:n},backend:e}),i=s$({inputs:{x:r},backend:e}),o=la({inputs:{input:n},backend:e}),a=ip({inputs:{x:o},backend:e}),l=_n({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return Ax({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}const fq={kernelName:cu,backendName:"cpu",kernelFunc:s$};function r$(s){const{inputs:t,backend:e,attrs:n}=s,{axis:r}=n;if(t.length===1)return rp({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{He(i,u.shape,"All tensors passed to stack must have matching shapes"),$(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(u=>{const h=rp({inputs:{input:u},backend:e,attrs:{dim:r}});return a.push(h),h}),c=ca({inputs:l,backend:e,attrs:{axis:r}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const mq={kernelName:hu,backendName:"cpu",kernelFunc:r$};function gq(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{paddings:i,constantValue:o}=n;dt(r,"pad");const a=i.map((b,w)=>b[0]+r.shape[w]+b[1]),l=i.map(b=>b[0]),c=e.data.get(r.dataId).values,u=K(r.shape),h=r.shape.length,d=yt(r.shape),p=K(a),f=a.length,m=yt(a),g=Le(r.dtype,p);o!==0&&g.fill(o);for(let b=0;b<u;b++){const x=wo(b,h,d).map((C,k)=>C+l[k]),v=$s(x,f,m);g[v]=c[b]}return{dataId:e.write(g,a,r.dtype),shape:a,dtype:r.dtype}}const i$={kernelName:du,backendName:"cpu",kernelFunc:gq};const yq=ye((s,t)=>Math.pow(s,t)),bq=De(Ka,yq),xq={kernelName:Ka,backendName:"cpu",kernelFunc:bq};function wq(s){const{inputs:t,backend:e,attrs:n}=s,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=n,l=r.map(y=>e.data.get(y.dataId).values),c=r.map(y=>y.shape),u=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,[d,p,f]=TN(l,c,u,i.shape,i.dtype,h,o.shape),m=d.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(f,i.dtype,p);return m.concat([g])}const vq={kernelName:of,backendName:"cpu",kernelFunc:wq};function Sq(s){const{inputs:t,backend:e}=s,{starts:n,limits:r,deltas:i}=t,o=e.data.get(n.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,u]=kN(o,n.shape,n.dtype,a,r.shape,l,i.shape),h=e.makeTensorInfo([c.length],"int32",c),d=e.makeTensorInfo([u.length],n.dtype,u);return[h,d]}const Cq={kernelName:af,backendName:"cpu",kernelFunc:Sq};function Tq(s){const{inputs:t,backend:e,attrs:n}=s,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=n,c=e.data.get(r.dataId).values,u=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,d=a.map(g=>e.data.get(g.dataId).values),p=a.map(g=>g.shape),[f,m]=IN(c,r.shape,u,i.shape,i.dtype,h,o.shape,d,p,l);return e.makeTensorInfo(f,i.dtype,m)}const kq={kernelName:lf,backendName:"cpu",kernelFunc:Tq};function Iq(s){const{backend:t,attrs:e}=s,{start:n,stop:r,dtype:i,step:o}=e,a=NN(n,r,o,i);return t.makeTensorInfo([a.length],i,a)}const Nq={kernelName:cf,backendName:"cpu",kernelFunc:Iq};const $q=Wt(Ya,s=>1/s),_q={kernelName:Ya,backendName:"cpu",kernelFunc:$q};function Eq(s){const{inputs:t,backend:e,attrs:n}=s,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=n;dt(r,"resizeBilinear");const l=yt(r.shape),[c,u]=a,[h,d,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(K([h,c,u,f])),y=[i&&c>1?d-1:d,i&&u>1?p-1:p],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let w=0;const x=y[0]/b[0],v=y[1]/b[1];for(let C=0;C<h;C++)for(let k=0;k<c;k++){let I;o?I=x*(k+.5)-.5:I=x*k;const N=Math.max(0,Math.floor(I)),_=I-N,T=Math.min(d-1,Math.ceil(I)),D=C*l[0]+N*l[1],R=C*l[0]+T*l[1];for(let P=0;P<u;P++){let B;o?B=v*(P+.5)-.5:B=v*P;const U=Math.max(0,Math.floor(B)),H=B-U,G=Math.min(p-1,Math.ceil(B)),X=D+U*l[2],Z=R+U*l[2],J=D+G*l[2],et=R+G*l[2];for(let Q=0;Q<f;Q++){const st=m[X+Q],it=m[Z+Q],at=m[J+Q],pt=m[et+Q],xt=st+(at-st)*H,bt=it+(pt-it)*H,wt=xt+(bt-xt)*_;g[w++]=wt}}}return e.makeTensorInfo([h,c,u,f],"float32",g)}const Dq={kernelName:yu,backendName:"cpu",kernelFunc:Eq};function Aq(s){const{inputs:t,backend:e,attrs:n}=s,{images:r,dy:i}=t,{alignCorners:o}=n;dt([i,r],"resizeBilinearGrad");const a=yt(r.shape),[l,c,u,h]=r.shape,[,d,p]=i.shape,f=new Float32Array(l*c*u*h),m=[o&&d>1?c-1:c,o&&p>1?u-1:u],g=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],w=e.data.get(i.dataId).values;let x=0;for(let v=0;v<l;v++){const C=v*a[0];for(let k=0;k<d;k++){const I=k*y,N=Math.floor(I),_=Math.min(Math.ceil(I),c-1),T=C+N*a[1],D=C+_*a[1],R=I-N,P=1-R;for(let B=0;B<p;B++){const U=B*b,H=Math.floor(U),G=Math.min(Math.ceil(U),u-1),X=U-H,Z=1-X,J=T+H*a[2],et=T+G*a[2],Q=D+H*a[2],st=D+G*a[2],it=P*Z,at=P*X,pt=R*Z,xt=R*X;for(let bt=0;bt<h;bt++){const wt=w[x++];f[J+bt]+=wt*it,f[et+bt]+=wt*at,f[Q+bt]+=wt*pt,f[st+bt]+=wt*xt}}}}return e.makeTensorInfo([l,u,c,h],"float32",f)}const Oq={kernelName:df,backendName:"cpu",kernelFunc:Aq};function Rq(s){const{inputs:t,backend:e,attrs:n}=s,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=n;dt(r,"resizeNearestNeighbor");const l=yt(r.shape),[c,u]=a,[h,d,p,f]=r.shape,m=e.data.get(r.dataId).values,g=new Float32Array(h*c*u*f),y=[i&&c>1?d-1:d,i&&u>1?p-1:p],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],w=y[0]/b[0],x=y[1]/b[1];let v=0;for(let C=0;C<h;C++){const k=C*l[0];for(let I=0;I<c;I++){const N=o?w*(I+.5):w*I;let _=Math.min(d-1,i?Math.round(N):Math.floor(N));o&&(_=Math.max(0,_));const T=k+_*l[1];for(let D=0;D<u;D++){const R=o?x*(D+.5):x*D;let P=Math.min(p-1,i?Math.round(R):Math.floor(R));o&&(P=Math.max(0,P));const B=T+P*l[2];for(let U=0;U<f;U++){const H=m[B+U];g[v++]=H}}}}return e.makeTensorInfo([h,c,u,f],r.dtype,g)}const Fq={kernelName:gu,backendName:"cpu",kernelFunc:Rq};function Pq(s){const{inputs:t,backend:e,attrs:n}=s,{images:r,dy:i}=t,{alignCorners:o}=n;dt([i,r],"resizeNearestNeighborGrad");const a=yt(r.shape),l=yt(i.shape),[c,u,h,d]=r.shape,[,p,f]=i.shape,m=new Float32Array(c*u*h*d),g=e.data.get(i.dataId).values,y=[o&&p>1?u-1:u,o&&f>1?h-1:h],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],w=y[0]/b[0],x=y[1]/b[1],v=1/w,C=1/x,k=Math.ceil(v)*2+2,I=Math.ceil(C)*2+2;for(let N=0;N<c;N++){const _=N*a[0];for(let T=0;T<u;T++){const D=_+T*a[1],R=Math.floor(T*v),P=Math.floor(R-k/2);for(let B=0;B<h;B++){const U=D+B*a[2],H=Math.floor(B*C),G=Math.floor(H-I/2);for(let X=0;X<d;X++){let Z=0;for(let J=0;J<k;J++){const et=J+P;if(et<0||et>=p)continue;const Q=_+et*l[1],st=et*w,it=Math.min(u-1,o?Math.round(st):Math.floor(st));if(T===it)for(let at=0;at<I;at++){const pt=at+G;if(pt<0||pt>=f)continue;const xt=Q+pt*l[2],bt=pt*x,wt=Math.min(h-1,o?Math.round(bt):Math.floor(bt));B===wt&&(Z+=g[xt+X])}}m[U+X]=Z}}}}return e.makeTensorInfo(r.shape,r.dtype,m)}const Lq={kernelName:hf,backendName:"cpu",kernelFunc:Pq};function Mq(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{dims:i}=n;dt(r,"reverse");const o=r.shape.length,a=$t(i,r.shape);if(o===0)return ir({inputs:{x:r},backend:e});const l=new Ce(r.shape,r.dtype),c=e.bufferSync(r);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),d=h.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}const Bq={kernelName:bu,backendName:"cpu",kernelFunc:Mq};const zq={kernelName:_f,backendName:"cpu",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:n}=s,{radians:r,fillValue:i,center:o}=t,a=e,l=Le(n.dtype,K(n.shape)),[c,u,h,d]=n.shape,[p,f]=Lb(o,u,h),m=255,g=Math.sin(r),y=Math.cos(r),b=a.data.get(n.dataId).values;for(let x=0;x<c;x++){const v=x*h*u*d;for(let C=0;C<u;C++){const k=C*(h*d);for(let I=0;I<h;I++){const N=I*d;for(let _=0;_<d;_++){const T=[c,C,I,_],D=T[2],R=T[1];let P=(D-p)*y-(R-f)*g,B=(D-p)*g+(R-f)*y;P=Math.round(P+p),B=Math.round(B+f);let U=i;if(typeof i!="number"&&(_===3?U=m:U=i[_]),P>=0&&P<h&&B>=0&&B<u){const G=B*(h*d),X=P*d,Z=v+G+X+_;U=b[Z]}const H=v+k+N+_;l[H]=U}}}}return{dataId:a.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};const Vq=Wt(Qa,s=>{const t=Math.floor(s);return s-t<.5?Math.floor(s):s-t>.5?Math.ceil(s):t%2===0?t:t+1}),Wq={kernelName:Qa,backendName:"cpu",kernelFunc:Vq};function Uq(s){const{inputs:t,backend:e,attrs:n}=s,{indices:r,updates:i}=t,{shape:o}=n,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Ii(i,r,o),d=!0,p=e.bufferSync(r),f=e.bufferSync(i),m=qi(p,f,o,h,c,l,a,u,0,d);return e.makeTensorInfo(o,m.dtype,m.values)}const Gq={kernelName:pf,backendName:"cpu",kernelFunc:Uq};function jq(s,t){let e=0,n=s.length,r=0;for(;e<n;)r=Math.floor((e+n)/2),s[r]<t?e=r+1:n=r;return n}function Hq(s,t){let e=0,n=s.length,r=0;for(;e<n;)r=Math.floor((e+n)/2),s[r]<=t?e=r+1:n=r;return n}function Xq(s,t,e,n,r,i){const o=de("int32",e*r);for(let a=0;a<e;++a){const l=s.slice(a*n,(a+1)*n),c=a*r;for(let u=0;u<r;++u)o[c+u]=i==="left"?jq(l,t[u+c]):Hq(l,t[u+c])}return o}function qq(s){const{inputs:t,backend:e,attrs:n}=s,{sortedSequence:r,values:i}=t,{side:o}=n,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,c=Xq(a,l,r.shape[0],r.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}const Kq={kernelName:mf,backendName:"cpu",kernelFunc:qq};function Yq(s){const{inputs:t,backend:e}=s,{condition:n,t:r,e:i}=t;dt([n,r,i],"select");const o=n.shape.length,a=e.data.get(n.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,u=bn(r.dtype,i.dtype),h=je(K(r.shape),u);let d=0;const p=o===0||o>1||r.shape.length===1?1:K(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let m=0;m<p;m++)a[f]===1?h[d++]=l[f]:h[d++]=c[f];return e.makeTensorInfo(r.shape,u,h)}const Zq={kernelName:xu,backendName:"cpu",kernelFunc:Yq};const Jq=xm,Qq=wm,tK=Wt(el,s=>s>=0?Qq*s:Jq*(Math.exp(s)-1)),eK={kernelName:el,backendName:"cpu",kernelFunc:tK};const nK=Wt(rl,s=>s<0?-1:s>0?1:0),sK={kernelName:rl,backendName:"cpu",kernelFunc:nK};const rK=Wt(nl,s=>Math.sin(s)),iK={kernelName:nl,backendName:"cpu",kernelFunc:rK};const oK=Wt(sl,s=>Math.sinh(s)),aK={kernelName:sl,backendName:"cpu",kernelFunc:oK};const lK=11920928955078125e-23,s1=Math.log(lK)+2,cK=Wt(ol,s=>{const t=s>-s1,e=s<s1,n=Math.exp(s);let r;return e?r=n:t?r=s:r=Math.log(1+n),r}),uK={kernelName:ol,backendName:"cpu",kernelFunc:cK};function hK(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockShape:i,paddings:o}=n;dt([r],"spaceToBatchND");const a=K(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<r.shape.length;++C)l.push([0,0]);const c=i$.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),u=Ku(c.shape,i,a,!1),h=Yu(u.length,i.length,!1),d=Zu(c.shape,i,a,!1),m=Jt({inputs:{x:c},backend:e,attrs:{shape:u}}),b=Cn({inputs:{x:m},backend:e,attrs:{perm:h}}),v=Jt({inputs:{x:b},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),v}const dK={kernelName:Su,backendName:"cpu",kernelFunc:hK};function pK(s){const{inputs:t,backend:e}=s,{indices:n,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=e.data.get(n.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[h,d,p,f,m]=DN(a,n.shape,n.dtype,l,r.dtype,c,u);return[e.makeTensorInfo(d,n.dtype,h),e.makeTensorInfo([d[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}const fK={kernelName:gf,backendName:"cpu",kernelFunc:pK};function mK(s){const{inputs:t,backend:e}=s,{inputIndices:n,inputShape:r,newShape:i}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(r.dataId).values),a=e.data.get(n.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,u,h]=AN(a,n.shape,n.dtype,o,l);return[e.makeTensorInfo(u,n.dtype,c),e.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const gK={kernelName:yf,backendName:"cpu",kernelFunc:mK};function yK(s){const{inputs:t,backend:e}=s,{data:n,indices:r,segmentIds:i}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(n.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,u]=$x(o,n.shape,n.dtype,a,l,!0);return e.makeTensorInfo(u,n.dtype,c)}const bK={kernelName:bf,backendName:"cpu",kernelFunc:yK};function xK(s){const{inputs:t,backend:e}=s,{data:n,indices:r,segmentIds:i}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(n.dataId).values,a=e.data.get(r.dataId).values,l=e.data.get(i.dataId).values,[c,u]=$x(o,n.shape,n.dtype,a,l);return e.makeTensorInfo(u,n.dtype,c)}const wK={kernelName:xf,backendName:"cpu",kernelFunc:xK};function vK(s){const{inputs:t,backend:e,attrs:n}=s,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=n,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=Ii(i,r,a),p=!1,f=e.bufferSync(r);let m;switch(i.dtype){case"bool":{const g=e.bufferSync(i),y=!!e.data.get(o.dataId).values[0];m=qi(f,g,a,d,u,c,l,h,y,p);break}case"float32":{const g=e.bufferSync(i),y=e.data.get(o.dataId).values[0];m=qi(f,g,a,d,u,c,l,h,y,p);break}case"int32":{const g=e.bufferSync(i),y=e.data.get(o.dataId).values[0];m=qi(f,g,a,d,u,c,l,h,y,p);break}case"string":{const g=e.bufferSync(i),y=$r(e.data.get(o.dataId).values[0]);m=qi(f,g,a,d,u,c,l,h,y,p);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}const SK={kernelName:wf,backendName:"cpu",kernelFunc:vK};function CK(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{numOrSizeSplits:i,axis:o}=n,a=$t(o,r.shape)[0],l=Jb(r,i,a),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map(h=>{const d=[...u];d[a]=h;const p=mo({inputs:{x:r},backend:e,attrs:{begin:c,size:d}});return c[a]+=h,p})}const TK={kernelName:Cu,backendName:"cpu",kernelFunc:CK};const kK={kernelName:vf,backendName:"cpu",kernelFunc:({inputs:s,backend:t})=>{const{x:e}=s,n=t;dt(e,"square");const r=n.data.get(e.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:n.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const IK=Wt(pl,(s,t)=>{const e=t;return isNaN(s)?NaN:s>0?1:e.alpha}),NK={kernelName:pl,backendName:"cpu",kernelFunc:IK};function $K(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=n;dt(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:x}=Ob(r.shape,i,o,a,l,c,u,h,d);let v;if(m)v=Jt({inputs:{x:r},backend:e,attrs:{shape:f}});else if(g||y){$(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const C=Eb(b,w,x),k=mo({inputs:{x:r},backend:e,attrs:{begin:b,size:C}});v=Jt({inputs:{x:k},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(k)}else{const C=e.bufferSync(r),k=FN(p,C,x,b);v=e.makeTensorInfo(f,k.dtype,k.values)}return v}const _K={kernelName:Sf,backendName:"cpu",kernelFunc:$K};function EK(s){const{inputs:t,backend:e,attrs:n}=s,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=n,{data:u,dataSplits:h}=t,d=e.data.get(u.dataId).values,p=e.data.get(h.dataId).values,[f,m]=PN(d,p,r,i,o,a,l,c);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(h.shape,"int32",m)]}const DK={kernelName:Cf,backendName:"cpu",kernelFunc:EK};function AK(s){const{inputs:t,backend:e,attrs:n}=s,{skipEmpty:r}=n,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,u,h]=LN(a,l,r),d=u.length;return[e.makeTensorInfo([d,2],"int32",c),e.makeTensorInfo([d],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(h))]}const OK={kernelName:Tf,backendName:"cpu",kernelFunc:AK};function RK(s){const{inputs:t,backend:e,attrs:n}=s,{numBuckets:r}=n,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(i.dataId).values,a=MN(o,r);return e.makeTensorInfo(i.shape,"int32",a)}const FK={kernelName:kf,backendName:"cpu",kernelFunc:RK};const PK=Wt(ul,s=>Math.tan(s)),LK={kernelName:ul,backendName:"cpu",kernelFunc:PK};const MK=Wt(hl,s=>Math.tanh(s)),BK={kernelName:hl,backendName:"cpu",kernelFunc:MK};function zK(s){const{inputs:t,backend:e}=s,{tensor:n,indices:r,updates:i}=t,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=Ii(i,r,n.shape),h=!1,d=e.bufferSync(r),p=e.bufferSync(i),f=e.bufferSync(n),m=qi(d,p,n.shape,u,l,a,o,c,f,h);return e.makeTensorInfo(n.shape,m.dtype,m.values)}const VK={kernelName:ff,backendName:"cpu",kernelFunc:zK};function WK(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{reps:i}=n;dt(r,"tile");const o=zN(e.bufferSync(r),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const UK={kernelName:dl,backendName:"cpu",kernelFunc:WK};function GK(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{k:i,sorted:o}=n;dt(r,"topk");const a=e.data.get(r.dataId).values,[l,c]=WN(a,r.shape,r.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}const jK={kernelName:If,backendName:"cpu",kernelFunc:GK};function HK(s){const{inputs:t,attrs:e,backend:n}=s,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[u,h,d,p]=r.shape,[f,m]=c??[h,d],g=[u,f,m,p],y=yt(r.shape),b=y[0],w=y[1],x=y[2],v=yt(g),C=v[0],k=v[1],I=v[2],N=Le(r.dtype,K(g));N.fill(l);const _=n.data.get(r.dataId).values,T=n.data.get(i.dataId).values;for(let R=0;R<u;++R){const P=i.shape[0]===1?T:T.subarray(R*8,R*8+8);for(let B=0;B<f;++B)for(let U=0;U<m;++U)for(let H=0;H<p;++H){let G;const X=P[6]*U+P[7]*B+1;if(X===0)continue;const Z=(P[0]*U+P[1]*B+P[2])/X,J=(P[3]*U+P[4]*B+P[5])/X,et=r1(Z,d,a),Q=r1(J,h,a);switch(o){case"nearest":G=JK(_,h,d,b,w,x,R,Q,et,H,l);break;case"bilinear":G=QK(_,h,d,b,w,x,R,Q,et,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const st=R*C+B*k+U*I+H;N[st]=G}return n.makeTensorInfo(g,r.dtype,N)}return{dataId:n.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}const XK={kernelName:Nf,backendName:"cpu",kernelFunc:HK};function r1(s,t,e){switch(e){case"reflect":return qK(s,t);case"wrap":return KK(s,t);case"nearest":return ZK(s,t);case"constant":default:return YK(s)}}function qK(s,t){let e=s;if(e<0)if(t<=1)e=0;else{const n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{const n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return oi(0,e,t-1)}function KK(s,t){let e=s;if(e<0)if(t<=1)e=0;else{const n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{const n=t-1;e-=t*Math.trunc(e/n)}return oi(0,e,t-1)}function YK(s,t){return s}function ZK(s,t){return oi(0,s,t-1)}function Gl(s,t,e,n,r,i,o,a,l,c,u){const h=o*n+a*r+l*i+c;return 0<=a&&a<t&&0<=l&&l<e?s[h]:u}function JK(s,t,e,n,r,i,o,a,l,c,u){const h=Math.round(a),d=Math.round(l);return Gl(s,t,e,n,r,i,o,h,d,c,u)}function QK(s,t,e,n,r,i,o,a,l,c,u){const h=Math.floor(a),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*Gl(s,t,e,n,r,i,o,h,d,c,u)+(l-d)*Gl(s,t,e,n,r,i,o,h,f,c,u),g=(f-l)*Gl(s,t,e,n,r,i,o,p,d,c,u)+(l-d)*Gl(s,t,e,n,r,i,o,p,f,c,u);return(p-a)*m+(a-h)*g}function t6(s){const{inputs:t,attrs:e,backend:n}=s,{axis:r}=e,{x:i}=t;dt(i,"unique");const o=n.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=UN(o,r,i.shape,i.dtype);return[n.makeTensorInfo(l,i.dtype,a),n.makeTensorInfo([c.length],"int32",c)]}const e6={kernelName:$f,backendName:"cpu",kernelFunc:t6};function n6(s){const{inputs:t,backend:e,attrs:n}=s,{value:r}=t;let{axis:i}=n;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==i&&(l[c++]=r.shape[p]);const u=new Array(o).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(a);for(let p=0;p<d.length;p++){u[i]=p;const f=mo({inputs:{x:r},backend:e,attrs:{begin:u,size:h}});d[p]=Jt({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return d}const s6={kernelName:Iu,backendName:"cpu",kernelFunc:n6};function r6(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,segmentIds:i}=t,{numSegments:o}=n;dt(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,c=[],u=[],h=a-l;let d=i;for(let f=0;f<h;++f){const m=rp({inputs:{input:d},backend:e,attrs:{dim:f+1}});d=m,u.push(m)}for(let f=0;f<o;++f){const m=Lr(f,"int32"),g=e.makeTensorInfo([],"int32",m),y=rN({inputs:{a:g,b:d},backend:e}),b=bi({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=Om({inputs:{a:b,b:r},backend:e}),x=oh({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});c.push(x),u.push(g),u.push(y),u.push(b),u.push(w),u.push(x)}const p=r$({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}const i6={kernelName:Nu,backendName:"cpu",kernelFunc:r6};const o6=[tH,RG,nH,rH,zG,oH,lH,uH,dH,fH,gH,bH,wH,CH,kH,$H,EH,AH,RH,Jj,PH,MH,zH,WG,WH,MG,GG,GH,FG,HH,qH,KH,ZH,QH,e5,s5,i5,a5,c5,h5,p5,m5,y5,x5,w5,S5,T5,I5,N5,$5,_5,D5,R5,jj,P5,jG,G5,HG,j5,qG,Z5,J5,tX,YG,JG,nX,rX,oX,lX,tj,nj,PG,uX,XH,dX,fX,gX,Hj,rj,oj,bX,lj,wX,CX,kX,$X,EX,AX,OX,uj,FX,LX,BX,VX,UX,jX,XX,dj,KX,JX,eq,fj,gj,rq,aq,uq,bj,dq,fq,mq,i$,xq,qj,vj,vq,Cq,kq,Nq,LG,Ny,_q,Kj,Yj,Zj,Dq,Oq,Fq,Lq,Bq,zq,Wq,_j,Gq,Kq,Zq,eK,Dj,sK,iK,aK,Aj,QX,uK,dK,fK,gK,bK,wK,SK,TK,Fj,kK,Lj,Bj,NK,_K,DK,OK,FK,Uj,A5,LK,BK,VK,UK,jK,XK,xj,e6,s6,i6,pq];for(const s of o6)Ef(s);const Ui={},Qh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function a6(s,t){Ui[s]=t}function Os(s,t){if(!(s in Ui)||t!=null){const n=c6(s,t);if(n!==null)Ui[s]=n;else return console.log("Could not get context for WebGL version",s),null}const e=Ui[s];return e==null||e.isContextLost()?(delete Ui[s],Os(s)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Ui[s])}function l6(s){if(!j().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&s===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function c6(s,t){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??l6(s);return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Ui[s]},!1),j().getBool("SOFTWARE_WEBGL_ENABLED")&&(Qh.failIfMajorPerformanceCaveat=!1),s===1?e.getContext("webgl",Qh)||e.getContext("experimental-webgl",Qh):e.getContext("webgl2",Qh)}var xc;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(xc||(xc={}));var qn;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(qn||(qn={}));var Ue;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ue||(Ue={}));function ah(s,t){return[t,s]}function u6(s,t){return s*t}function td(s){const t=K(s),e=Math.ceil(t/4);return Fd(e)}function Sl(s,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(s/2))]}function h6(s,t){const[e,n]=Sl(s,t);return e*n*4}function Ox(s,t){const e=s;let n,r,i,o,a,l,c,u,h,d;return j().getNumber("WEBGL_VERSION")===2?(n=e.R32F,r=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,u=1,h=e.HALF_FLOAT,d=e.FLOAT,l=e.RGBA8):(n=s.RGBA,r=s.RGBA,i=s.RGBA,o=e.RGBA,a=s.RGBA,c=4,u=4,h=t!=null?t.HALF_FLOAT_OES:null,d=s.FLOAT,l=s.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function lt(s,t){const e=t();return j().getBool("DEBUG")&&d6(s),e}function d6(s){const t=s.getError();if(t!==s.NO_ERROR)throw new Error("WebGL Error: "+g6(s,t))}const p6=596e-10,f6=65504;function m6(s){return!!(j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||p6<Math.abs(s)&&Math.abs(s)<f6)}function g6(s,t){switch(t){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ed(s,t){return Gr(s,()=>s.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function y6(s,t){const e=Gr(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(lt(s,()=>s.shaderSource(e,t)),lt(s,()=>s.compileShader(e)),s.getShaderParameter(e,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function b6(s,t){const e=Gr(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(lt(s,()=>s.shaderSource(e,t)),lt(s,()=>s.compileShader(e)),j().get("ENGINE_COMPILE_ONLY"))return e;if(s.getShaderParameter(e,s.COMPILE_STATUS)===!1)throw o$(t,s.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const x6=/ERROR: [0-9]+:([0-9]+):/g;function o$(s,t){const e=x6.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(s);return}const n=+e[1],r=s.split(`
`),i=r.length.toString().length+2,o=r.map((h,d)=>Yi((d+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,n-1),c=o.slice(n-1,n),u=o.slice(n);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Yi(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function w6(s){return Gr(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function v6(s,t){if(lt(s,()=>s.linkProgram(t)),!j().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(t,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function bg(s,t){if(lt(s,()=>s.validateProgram(t)),s.getProgramParameter(t,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function S6(s,t){const e=Gr(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return lt(s,()=>s.bindBuffer(s.ARRAY_BUFFER,e)),lt(s,()=>s.bufferData(s.ARRAY_BUFFER,t,s.STATIC_DRAW)),e}function C6(s,t){const e=Gr(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return lt(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,e)),lt(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,t,s.STATIC_DRAW)),e}function T6(s){return Gr(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function k6(s,t){const e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||t<=0){const n=`[${s}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(s>e||t>e){const n=`[${s}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+r+".")}}function I6(s){return Gr(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function i1(s,t,e,n,r,i,o){const a=s.getAttribLocation(t,e);return a===-1?!1:(lt(s,()=>s.bindBuffer(s.ARRAY_BUFFER,n)),lt(s,()=>s.vertexAttribPointer(a,r,s.FLOAT,!1,i,o)),lt(s,()=>s.enableVertexAttribArray(a)),!0)}function N6(s,t,e){A6(s,e),lt(s,()=>s.activeTexture(s.TEXTURE0+e)),lt(s,()=>s.bindTexture(s.TEXTURE_2D,t))}function $6(s,t,e){return Gr(s,()=>s.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function _6(s,t,e){return s.getUniformLocation(t,e)}function E6(s,t,e,n){lt(s,()=>N6(s,t,n)),lt(s,()=>s.uniform1i(e,n))}function xg(s,t,e){lt(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,e)),lt(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0))}function o1(s,t){lt(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,t)),lt(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function nd(s){const t=s.checkFramebufferStatus(s.FRAMEBUFFER);if(t!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+D6(s,t))}function D6(s,t){switch(t){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Gr(s,t,e){const n=lt(s,()=>t());if(n==null)throw new Error(e);return n}function A6(s,t){const e=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+s.TEXTURE0;if(n<s.TEXTURE0||n>e){const r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ua(s,t=2){return K(s.slice(0,s.length-t))}function ha(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function sd(s){let t=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(t=[ua(s),...ha(s)]),t}function O6(s,t=!1){let e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=j().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&j().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=e/2),t&&(e=e*2,n=n*2,s=s.map((a,l)=>l>=s.length-2?Sp(s[l]):s[l]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=Pr(s).newShape);let r=K(s),i=null;s.length<=1&&r<=e?i=[1,r]:s.length===2&&s[0]<=e&&s[1]<=e?i=s:s.length===3&&s[0]*s[1]<=e&&s[2]<=e?i=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=e&&s[1]*s[2]<=e?i=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=e&&s[3]<=e?i=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=e&&s[1]*s[2]*s[3]<=e&&(i=[s[0],s[1]*s[2]*s[3]]);const o=i!=null&&Math.max(...i)>n&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||o)if(t){const a=ua(s);let l=2,c=2;s.length&&([l,c]=ha(s)),r=a*(l/2)*(c/2),i=Fd(r).map(u=>u*2)}else i=Fd(r);return i}function rd(s){return s%2===0}function op(s,t){if(s=s.slice(-2),t=t.slice(-2),Dt(s,t)||!s.length||!t.length||s[0]===0||s[1]===0||t[0]===0||t[1]===0)return!0;if(s.length!==t.length){const e=s[s.length-1],n=t[t.length-1];if(e===n||rd(e)&&rd(n)&&(s[0]===1||t[0]===1))return!0}return s[1]===t[1]&&rd(s[0])&&rd(t[0])}let wg,vg;function R6(s){if(wg==null){const t=Os(s);wg=t.getParameter(t.MAX_TEXTURE_SIZE)}return wg}function F6(s){if(vg==null){const t=Os(s);vg=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,vg)}function P6(s){if(s===0)return 0;let t;const e=Os(s);return cs(e,"EXT_disjoint_timer_query_webgl2")&&s===2?t=2:cs(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function cs(s,t){return s.getExtension(t)!=null}function a1(s){try{if(Os(s)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function L6(s){if(s===0)return!1;const t=Os(s);if(s===1){if(!cs(t,"OES_texture_float"))return!1}else if(!cs(t,"EXT_color_buffer_float"))return!1;return _y(t)}function M6(s){if(s===0)return!1;const t=Os(s);if(s===1){if(!cs(t,"OES_texture_float")||!cs(t,"WEBGL_color_buffer_float"))return!1}else{if(cs(t,"EXT_color_buffer_float"))return _y(t);const n="EXT_color_buffer_half_float";if(cs(t,n)){const r=t.getExtension(n);return B6(t,r)}return!1}return _y(t)}function _y(s){const t=Ox(s),e=s.createTexture();s.bindTexture(s.TEXTURE_2D,e),s.texImage2D(s.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,i),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0);const o=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(e),s.deleteFramebuffer(i),o}function B6(s,t){const e=Ox(s,t),n=s.createTexture();s.bindTexture(s.TEXTURE_2D,n),s.texImage2D(s.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,o),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,n,0);const a=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(n),s.deleteFramebuffer(o),a}function z6(s){return s!==2?!1:Os(s).fenceSync!=null}function lh(s,t){Array.isArray(s)||(s=[s]),s.forEach(e=>{e!=null&&$(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const mt=j();mt.registerFlag("HAS_WEBGL",()=>mt.getNumber("WEBGL_VERSION")>0);mt.registerFlag("WEBGL_VERSION",()=>a1(2)?2:a1(1)?1:0);mt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);mt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>mt.get("WEBGL_VERSION")===2);mt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);mt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);mt.registerFlag("WEBGL_PACK",()=>mt.getBool("HAS_WEBGL"));mt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CLIP",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_REDUCE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_LAZILY_UNPACK",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_CONV_IM2COL",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>R6(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>F6(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=mt.getNumber("WEBGL_VERSION");return s===0?0:P6(s)});mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!a0());mt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>L6(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>mt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:mt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));mt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>M6(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>z6(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);mt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(typeof s!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${s}.`);if(s<0&&s!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${s}.`)});mt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>a0()?1:-1,s=>{if(typeof s!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${s}.`);if(s<0&&s!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${s}.`)});mt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);mt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);mt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);mt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);mt.registerFlag("WEBGL_EXP_CONV",()=>!1);mt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>mt.getBool("IS_TEST"));mt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);mt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);mt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);mt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function hn(){let s,t,e,n,r,i,o,a,l,c;return j().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",t="in",e="out",n="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=j().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",t="attribute",e="varying",n="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:t,varyingVs:e,varyingFs:n,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function $o(s,t,e="index"){const n=yt(t);return n.map((r,i)=>{const o=`int ${s[i]} = ${e} / ${r}`,a=i===n.length-1?`int ${s[i+1]} = ${e} - ${s[i]} * ${r}`:`index -= ${s[i]} * ${r}`;return`${o}; ${a};`}).join("")}function Rm(s,t,e="index"){const n=yt(t);return n.map((r,i)=>{const o=`int ${s[i]} = ${e} / outShapeStrides[${i}]`,a=i===n.length-1?`int ${s[i+1]} = ${e} - ${s[i]} * outShapeStrides[${i}]`:`index -= ${s[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function V6(s,t){const e=s.length,n=s.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=n[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${n[i+1]})`;return r}function W6(s,t,e="index"){const n=s.map((i,o)=>o),r=V6(n,t);return r.map((i,o)=>{const a=`int ${s[o]} = ${e} / ${r[o]}`,l=o===r.length-1?`int ${s[o+1]} = ${e} - ${s[o]} * ${r[o]}`:`index -= ${s[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function Rx(s){const t=yt(s).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Fx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const a$=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:l$}=fk;function U6(s,t,e){const n=[];if(s.forEach(p=>{const f=K(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?n.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${p.name};`),n.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:m}=Px(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:n.push(`uniform int ${p.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${p.name}Shape;`);break}n.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{n.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=n.join(`
`),i=s.map(p=>G6(p,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,a=hn(),l=X6(a);let c,u,h=Y6(a);return t.isPacked?(c=j6(t.logicalShape,o,e.enableShapeUniforms),u=K6(a)):(c=H6(t.logicalShape,o,e.enableShapeUniforms),u=q6(a)),e.packedInputs&&(h+=tY),[h,l,u,r,c,i,e.userCode].join(`
`)}function Cl(s,t=!1){const e=s.shapeInfo.logicalShape;switch(e.length){case 0:return dY(s,t);case 1:return fY(s,t);case 2:return gY(s,t);case 3:return bY(s,t);case 4:return wY(s,t);case 5:return vY(s);case 6:return SY(s);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function c$(s,t){switch(s.shapeInfo.logicalShape.length){case 0:return hY(s);case 1:return pY(s,t);case 2:return mY(s,t);case 3:return yY(s,t);default:return xY(s,t)}}function G6(s,t,e=!1,n){let r="";e?r+=c$(s,n):r+=Cl(s,n);const i=s.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(e?r+=CY(s,t):r+=TY(s,t)),r}function j6(s,t,e){switch(s.length){case 0:return u$();case 1:return eY(s,t,e);case 2:return cY(s,t,e);case 3:return sY(s,t,e);default:return iY(s,t,e)}}function H6(s,t,e){switch(s.length){case 0:return u$();case 1:return nY(s,t,e);case 2:return uY(s,t,e);case 3:return rY(s,t,e);case 4:return oY(s,t,e);case 5:return aY(s,t);case 6:return lY(s,t);default:throw new Error(`${s.length}-D output sampling is not yet supported`)}}function X6(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${s.texture2D}(textureSampler, uv).r;
    }
  `}function q6(s){return`
    void setOutput(float val) {
      ${s.output} = vec4(val, 0, 0, 0);
    }
  `}function K6(s){return`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `}function Y6(s){return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFs} vec2 resultUV;
    ${s.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${s.defineSpecialNaN}
    ${s.defineSpecialInf}
    ${s.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Z6}
    ${J6}
    ${Q6}
  `}const Z6=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,J6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Q6=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,tY=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function u$(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function eY(s,t,e){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function nY(s,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function sY(s,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(s[2]/2),i=r*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function rY(s,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Rm(["r","c","d"],s)}
    return ivec3(r, c, d);
  }
`;const n=$o(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function iY(s,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(s[s.length-1]/2),i=r*Math.ceil(s[s.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<s.length-1;c++)o*=s[s.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${s.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${s.length}(${l});
    }
  `}function oY(s,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Rm(["r","c","d","d2"],s)}
      return ivec4(r, c, d, d2);
    }
  `;const n=$o(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function aY(s,t){const e=$o(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function lY(s,t){const e=$o(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function cY(s,t,e){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Dt(s,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;const r=Math.ceil(s[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function uY(s,t,e){return Dt(s,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:s[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `}function _o(s){return`offset${s}`}function hY(s){const t=s.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=hn();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function dY(s,t){const e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(s.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,i]=s.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=_o(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[a,l]=s.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function pY(s,t){const e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=s.shapeInfo.texShape,i=hn();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function fY(s,t){const e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(s.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Tl(s)}
      }
    `;const r=s.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const a=_o(e);return o===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function mY(s,t){const e=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=s.shapeInfo.texShape,o=i[0],a=i[1],l=hn();if(i!=null&&Dt(e,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${l.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=Math.ceil(e[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `}function gY(s,t){const e=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=s.shapeInfo.texShape;if(i!=null&&Dt(e,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;const d=i[0],p=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${n}, uv);
    }
  `}const{newShape:o,keptDims:a}=Pr(e),l=o;if(l.length<e.length){const d=kl(s,l),p=["row","col"];return`
      ${Cl(d,t)}
      float ${r}(int row, int col) {
        return ${r}(${Il(p,a)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Tl(s)}
      }
    `;const c=i[0],u=i[1],h=_o(n);return u===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `:c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${n}, uv);
  }
`}function yY(s,t){const e=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=s.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const d=e.slice(1),p=[1,2],f=kl(s,d),m=["b","row","col"];return`
        ${c$(f,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Il(m,p)});
        }
      `}const a=hn();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(e[2]/2),h=u*Math.ceil(e[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function bY(s,t){const e=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Pr(e),c=a;if(c.length<e.length){const m=kl(s,c),g=["row","col","depth"];return`
        ${Cl(m,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Il(g,l)});
        }
      `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Tl(s)}
      }
    `;const u=s.shapeInfo.texShape,h=u[0],d=u[1],p=s.shapeInfo.flatOffset;if(d===i&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(d===o&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${n}, uv);
    }
  `;const f=_o(n);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${n}, uv);
      }
  `}function xY(s,t){const e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=hn();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);
    }
  `;const i=s.shapeInfo.logicalShape,o=i.length,a=s.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(i[o-1]/2);let d=h*Math.ceil(i[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)p=`int b${m}, `+p,d*=i[o-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${n}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${r.texture2D}(${e}, uv);
    }
  `}function wY(s,t){const e=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Pr(e);if(l.length<e.length){const b=kl(s,l),w=["row","col","depth","depth2"];return`
      ${Cl(b,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Il(w,c)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Tl(s)}
      }
    `;const u=s.shapeInfo.flatOffset,h=s.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${n}Shape[3];`,m=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(p===a&&u==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===i&&u==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=_o(n);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function vY(s){const t=s.shapeInfo.logicalShape,e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Pr(t);if(l.length<t.length){const m=kl(s,l),g=["row","col","depth","depth2","depth3"];return`
      ${Cl(m)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Il(g,c)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Tl(s)}
      }
    `;const u=s.shapeInfo.flatOffset,h=s.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&u==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(p===r&&u==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;const f=_o(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${e}, uv);
    }
  `}function SY(s){const t=s.shapeInfo.logicalShape,e=s.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=Pr(t);if(r.length<t.length){const g=kl(s,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Cl(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Il(y,i)});
      }
    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Tl(s)}
      }
    `;const h=s.shapeInfo.flatOffset,d=s.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&h==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${e}, uv);
      }
    `;const m=_o(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Tl(s){const t=s.name,e=K(s.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function CY(s,t){const e=s.name,n=e.charAt(0).toUpperCase()+e.slice(1),r="get"+n+"AtOutCoords",i=s.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=l$(s.shapeInfo.logicalShape,t.logicalShape),l=Ht(o),c=o-i;let u;const h=["x","y","z","w","u","v"];i===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=s.shapeInfo.logicalShape.map((b,w)=>`coords.${h[w+c]}`).join(", ");let p="return outputValue;";const m=K(s.shapeInfo.logicalShape)===1,y=K(t.logicalShape)===1;if(i===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=i-2,w=i-1;a.indexOf(b)>-1&&a.indexOf(w)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${n}(${d});
      ${p}
    }
  `}function TY(s,t){const e=s.name,n=e.charAt(0).toUpperCase()+e.slice(1),r="get"+n+"AtOutCoords",i=t.texShape,o=s.shapeInfo.texShape,a=s.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!s.shapeInfo.isUniform&&a===l&&s.shapeInfo.flatOffset==null&&Dt(o,i))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const c=Ht(l),u=l$(s.shapeInfo.logicalShape,t.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=s.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${n}(${f});
    }
  `}function Ht(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error(`GPU for rank ${s} is not yet supported`)}function Px(s,t,e){const{newShape:n,keptDims:r}=Pr(t),i=t.length,o=s&&i===3&&t[0]===1,a=o?t.slice(1):n,l=!s&&i>1&&!Dt(t,e)&&n.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:r}}function kl(s,t){const e=JSON.parse(JSON.stringify(s));return e.shapeInfo.logicalShape=t,e}function Il(s,t){return t.map(e=>s[e]).join(", ")}function kY(s,t,e,n){const r=e.map((u,h)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),i=r.map(u=>u.shapeInfo),o={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=U6(r,o,t),l=b6(s.gl,a),c=s.createProgram(l);return j().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(s.buildVao(c),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},h$(s,t,c)))}function h$(s,t,e){const n=[],r=[];let i,o,a,l=null,c=null;c=s.getUniformLocation(e,"NAN",!1),j().getNumber("WEBGL_VERSION")===1&&(l=s.getUniformLocation(e,"INFINITY",!1));const u=!1;for(const h of t.variableNames){const d={name:h,uniform:s.getUniformLocation(e,h,u),offset:s.getUniformLocation(e,`offset${h}`,u)};t.enableShapeUniforms&&(d.shape=s.getUniformLocation(e,`${h}Shape`,u),d.texShape=s.getUniformLocation(e,`${h}TexShape`,u)),n.push(d)}if(t.enableShapeUniforms&&(i=s.getUniformLocation(e,"outShape",u),a=s.getUniformLocation(e,"outShapeStrides",u),o=s.getUniformLocation(e,"outTexShape",u)),t.customUniforms)for(const h of t.customUniforms)r.push(s.getUniformLocation(e,h.name,u));return{variablesLocations:n,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function l1(s,t){if(s.length!==t.length)throw Error(`Binary was compiled with ${s.length} inputs, but was executed with ${t.length} inputs`);s.forEach((e,n)=>{const r=e.logicalShape,i=t[n],o=i.shape;if(!Dt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!Dt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function IY(s,t,e,n,r){t.program.enableShapeUniforms||(l1(t.inShapeInfos,e),l1([t.outShapeInfo],[n]));const i=n.texData.texture,o=n.texData.texShape;n.texData.isPacked?s.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):s.setOutputMatrixTexture(i.texture,o[0],o[1]),s.setProgram(t.webGLProgram),s.bindVertexArray(t.webGLProgram.vao),j().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&s.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&s.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const c=e[l],{uniform:u,offset:h,shape:d,texShape:p}=t.variablesLocations[l];if(d){const{uniformShape:f}=Px(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:s.gl.uniform1iv(d,new Int32Array(f));break;case 2:s.gl.uniform2iv(d,new Int32Array(f));break;case 3:s.gl.uniform3iv(d,new Int32Array(f));break;case 4:s.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&s.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(K(c.shape)<2)s.gl.uniform1f(u,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),s.gl.uniform1fv(u,f)}continue}c.texData.slice!=null&&h!=null&&s.gl.uniform1i(h,c.texData.slice.flatOffset),s.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:s.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:s.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:s.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:s.gl.uniform4iv(a,new Int32Array(n.shape));break}if(t.outShapeStridesLocation){const l=yt(n.shape);switch(n.shape.length){case 2:s.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:s.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:s.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&s.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const c=t.program.customUniforms[l],u=t.customUniformLocations[l],h=r[l];if(c.type==="float")s.gl.uniform1fv(u,h);else if(c.type==="vec2")s.gl.uniform2fv(u,h);else if(c.type==="vec3")s.gl.uniform3fv(u,h);else if(c.type==="vec4")s.gl.uniform4fv(u,h);else if(c.type==="int")s.gl.uniform1iv(u,h);else if(c.type==="ivec2")s.gl.uniform2iv(u,h);else if(c.type==="ivec3")s.gl.uniform3iv(u,h);else if(c.type==="ivec4")s.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}s.executeProgram()}function NY(s,t,e){let n="";t.concat(e).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=Px(s.packedInputs,o.shape,l);let d="",p="",f="";if(u.length===1&&s.packedInputs){const v=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${v[0]>1}_${v[1]>1}`}else if(u.length===2&&!s.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!s.packedInputs){const v=yt(u);f=`${v[0]===l[1]}_${v[v.length-1]===l[1]}`}const m=o.shape.length,g=u.length===2&&Dt(o.shape,l),y=K(o.shape)===1,b=ao(o.shape,e.shape),w=!s.packedInputs&&m===e.shape.length&&Dt(l,e.texData.texShape),x=s.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;n+=`${m}_${w}_${c?h:""}_${u.length}_${y}_${b}_${g}_${d}_${p}_${f}_${x}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;n+=`${o.shape}_${l}_${a}`}});const r=s.userCode;let i=s.constructor.name;return i+="_"+n+"_"+r+`${j().getNumber("WEBGL_VERSION")}`,i}function tn(s){return j().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}class $Y{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=xc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hn();this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rm(["r","c","d"],t):$o(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class _Y{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=xc.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hn();this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Rm(["r","c","d"],t):$o(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class EY{constructor(t){this.variableNames=["A"],this.outTexUsage=qn.DOWNLOAD;const e=hn();this.outputShape=t,this.userCode=`
      ${a$}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class DY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qn.DOWNLOAD;const e=hn();this.outputShape=t,this.userCode=`
      ${a$}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const AY={R:0,G:1,B:2,A:3};class c1{constructor(t,e=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=hn();this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<n.length;a++){const l=n[a];o+=`
          if(offset == ${a}) {
            result = values[${AY[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Fx():Rx(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class OY{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hn();this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Fx():Rx(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${i};
        }
    `}}function RY(s){const t=hn(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return y6(s,e)}function FY(s){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return S6(s,t)}function PY(s){const t=new Uint16Array([0,1,2,2,1,3]);return C6(s,t)}function ch(s,t,e,n,r,i){k6(t,e);const o=T6(s),a=s.TEXTURE_2D;return lt(s,()=>s.bindTexture(a,o)),lt(s,()=>s.texParameteri(a,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),lt(s,()=>s.texParameteri(a,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),lt(s,()=>s.texParameteri(a,s.TEXTURE_MIN_FILTER,s.NEAREST)),lt(s,()=>s.texParameteri(a,s.TEXTURE_MAG_FILTER,s.NEAREST)),j().getNumber("WEBGL_VERSION")===1?lt(s,()=>s.texImage2D(a,0,n,t,e,0,r,i,null)):lt(s,()=>s.texStorage2D(a,1,n,t,e)),lt(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function d$(s){return s.internalFormatFloat}function LY(s,t,e,n){const[r,i]=ah(t,e);return ch(s,r,i,d$(n),n.textureFormatFloat,s.FLOAT)}function p$(s){return s.internalFormatHalfFloat}function MY(s,t,e,n){const[r,i]=ah(t,e);return ch(s,r,i,p$(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function f$(s){return s.downloadTextureFormat}function BY(s,t,e,n){const[r,i]=ah(t,e);return ch(s,r,i,f$(n),s.RGBA,s.UNSIGNED_BYTE)}function m$(s){return s.internalFormatPackedFloat}function zY(s,t,e,n){const[r,i]=Sl(t,e);return ch(s,r,i,m$(n),s.RGBA,s.FLOAT)}function g$(s){return s.internalFormatPackedHalfFloat}function VY(s,t,e,n){const[r,i]=Sl(t,e);return ch(s,r,i,g$(n),s.RGBA,n.textureTypeHalfFloat)}function WY(s,t,e){return lt(s,()=>s.bindBuffer(s.ARRAY_BUFFER,e)),i1(s,t,"clipSpacePos",e,3,20,0)&&i1(s,t,"uv",e,2,20,12)}function UY(s,t,e,n,r,i){lt(s,()=>s.bindTexture(s.TEXTURE_2D,t));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(e*n*4),a=s.UNSIGNED_BYTE,l=s.RGBA):(o=new Float32Array(e*n*4),a=s.FLOAT,l=i.internalFormatPackedFloat),o.set(r),j().getNumber("WEBGL_VERSION")===2?lt(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,e,n,s.RGBA,a,o)):lt(s,()=>s.texImage2D(s.TEXTURE_2D,0,l,e,n,0,s.RGBA,a,o)),lt(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function GY(s,t,e){lt(s,()=>s.bindTexture(s.TEXTURE_2D,t)),e.data instanceof Uint8Array?j().getNumber("WEBGL_VERSION")===2?lt(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,e.width,e.height,s.RGBA,s.UNSIGNED_BYTE,e.data)):lt(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,e.width,e.height,0,s.RGBA,s.UNSIGNED_BYTE,e.data)):j().getNumber("WEBGL_VERSION")===2?lt(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,e)):lt(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,e)),lt(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function jY(s,t,e,n){const r=s.createBuffer();lt(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,r));const a=4*4*t*e;return lt(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,a,s.STREAM_READ)),lt(s,()=>s.readPixels(0,0,e,t,s.RGBA,s.FLOAT,0)),lt(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),r}function HY(s,t,e){const n=s,r=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,r),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),r}function XY(s,t,e,n){const[r,i]=ah(t,e),o=4,a=new Uint8Array(u6(t*e,o));return lt(s,()=>s.readPixels(0,0,r,i,n.downloadTextureFormat,s.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function qY(s,t,e,n,r,i,o,a){const l=s,c=new Float32Array(h6(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function KY(s,t,e){const n=new Float32Array(t*e*4);return lt(s,()=>s.readPixels(0,0,e,t,s.RGBA,s.FLOAT,n)),n}class Sg{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=j().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,a6(e,t)):this.gl=Os(e),t=this.gl,j().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>lt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>lt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>lt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>lt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>lt(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>lt(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>lt(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>lt(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),j().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=ed(this.gl,i),cs(this.gl,o))this.textureHalfFloatExtension=ed(this.gl,o);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),cs(this.gl,r))this.colorBufferHalfFloatExtension=ed(this.gl,r);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",cs(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(cs(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=FY(this.gl),this.indexBuffer=PY(this.gl),this.framebuffer=I6(this.gl),this.textureConfig=Ox(this.gl,this.textureHalfFloatExtension)}get debug(){return j().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;lt(t,()=>t.finish()),lt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),lt(t,()=>t.deleteFramebuffer(this.framebuffer)),lt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),lt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),lt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),LY(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),MY(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),BY(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),GY(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),UY(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),VY(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),zY(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(o1(this.gl,this.framebuffer),this.outputTexture=null),lt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>XY(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,i,o){return qY(this.gl,t,e,n,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return HY(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=jY(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(j().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=i}else j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>KY(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=RY(e));const n=w6(e);lt(e,()=>e.attachShader(n,this.vertexShader)),lt(e,()=>e.attachShader(n,t)),v6(e,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&bg(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;lt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),WY(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(lt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&bg(this.gl,this.program),lt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?$6(this.gl,t,e):_6(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),lt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),E6(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,i]=Sl(e,n);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&bg(this.gl,this.program),nd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}lt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),lt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ed(this.gl,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await Lg(()=>this.disposed||this.isQueryAvailable(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{const n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=YY(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in j().platform&&(n=j().platform.setTimeoutCustom.bind(j().platform)),Lg(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),xg(this.gl,t,this.framebuffer),this.debug&&nd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(xg(this.gl,this.outputTexture,this.framebuffer),this.debug&&nd(this.gl)):o1(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;xg(r,t,this.framebuffer),this.debug&&nd(r),this.outputTexture=t,lt(r,()=>r.viewport(0,0,e,n)),lt(r,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),lt(this.gl,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function YY(s){let t=0;for(;t<s.length&&s[t]();++t);return t-1}const{addImpl:ZY,bincountImpl:y$,bincountReduceImpl:JY,bitwiseAndImpl:QY,castImpl:t8,ceilImpl:e8,concatImpl:n8,equalImpl:s8,expImpl:r8,expm1Impl:i8,floorImpl:o8,gatherNdImpl:a8,gatherV2Impl:l8,greaterImpl:c8,greaterEqualImpl:u8,lessImpl:h8,lessEqualImpl:d8,linSpaceImpl:p8,logImpl:f8,maxImpl:m8,maximumImpl:g8,minimumImpl:y8,multiplyImpl:b8,negImpl:x8,notEqualImpl:w8,prodImpl:v8,raggedGatherImpl:S8,raggedRangeImpl:C8,raggedTensorToTensorImpl:T8,rangeImpl:k8,rsqrtImpl:I8,scatterImpl:N8,sigmoidImpl:$8,simpleAbsImpl:b$,sliceImpl:_8,sparseFillEmptyRowsImpl:E8,sparseReshapeImpl:D8,sparseSegmentReductionImpl:x$,sqrtImpl:A8,staticRegexReplaceImpl:O8,stridedSliceImpl:R8,stringNGramsImpl:F8,stringSplitImpl:P8,stringToHashBucketFastImpl:L8,subImpl:M8,tileImpl:B8,topKImpl:z8,transposeImpl:Lx,uniqueImpl:V8}=Gj;function w$(s,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${s}.${e}`)}function on(s,t){return t===1?[s]:w$(s,t)}function W8(s,t){if(s===1)return"rc";let e="";for(let n=0;n<s;n++)e+=t[n],n<s-1&&(e+=",");return e}class U8{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=tn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=on("rc",this.rank),n=Ht(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class v${constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),n+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${G8(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Fx():Rx(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}}function G8(s,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?W6(["r","c","d"],"inputShape"):$o(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}class j8{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,n){const r=h1(e,n),i=d1(t,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=u1(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===Ue.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Ue.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Ue.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Ue.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Ue.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,n,r){if(this.freeTextures==null)return;const i=h1(n,r),o=d1(e,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=u1(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=j().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(t);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function H8(s,t){const e=s;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===s.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function u1(s,t,e,n,r){const i=X8(t,n);let o;if(r){const[l,c]=Sl(s[0],s[1]);o=l*c}else{const[l,c]=ah(s[0],s[1]);o=l*c}const a=H8(e,i);return o*a}function X8(s,t){switch(s){case Ue.PACKED_2X2_FLOAT32:return m$(t);case Ue.PACKED_2X2_FLOAT16:return g$(t);case Ue.UNPACKED_FLOAT32:return d$(t);case Ue.UNPACKED_FLOAT16:return p$(t);case Ue.PACKED_4X1_UNSIGNED_BYTE:return f$(t);default:throw new Error(`Unknown physical texture type ${s}`)}}function q8(s){return j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?Ue.PACKED_2X2_FLOAT32:Ue.UNPACKED_FLOAT32:s?Ue.PACKED_2X2_FLOAT16:Ue.UNPACKED_FLOAT16}function h1(s,t){if(s===qn.UPLOAD)return Ue.PACKED_2X2_FLOAT32;if(s===qn.RENDER||s==null)return q8(t);if(s===qn.DOWNLOAD||s===qn.PIXELS)return Ue.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${s}`)}function d1(s,t,e){return`${s[0]}_${s[1]}_${t}_${e}`}class Xs{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const fs="if (isnan(x)) return x;",K8="return x;",p1="return abs(x);",Y8="return (x >= 0.0) ? x : (exp(x) - 1.0);",Z8=fs+`
  return (x < 0.0) ? 0.0 : x;
`,J8=fs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Zr="return x;",Q8="return 1.0 / (1.0 + exp(-1.0 * x));";const t7="return x;",e7=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,n7=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,s7=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,r7="return 1.0 / (1.0 + exp(-1.0 * x));";class ti{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class i7{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length);const e=t.length,n=on("rc",e),r=Ht(e),i=W8(e,n),o=n.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}const o7=om,a7=1e-7,l7=1e-4,id={};function c7(s){return s in id||(id[s]={}),id[s]}const u7=j().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),h7=600;function d7(){return j().global.screen==null?1024:j().global.screen.height*j().global.screen.width*window.devicePixelRatio*h7/1024/1024}class Fm extends vp{nextDataId(){return Fm.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!j().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Sg)e=t;else{const n=Os(j().getNumber("WEBGL_VERSION"),t);e=new Sg(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const n=Os(j().getNumber("WEBGL_VERSION"));e=new Sg(n),this.binaryCache=c7(j().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new j8(this.gpgpu),this.numMBBeforeWarning=d7(),this.texData=new Jy(this,Gn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,n,r,i,o){const a=this.makeTensorInfo(e,n),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,i]},l.texShape=[r,i];const c=sd(e),u=new c1(c,!1,o),h=this.runWebGLProgram(u,[a],n,[[r,i]]);return h.shape=e,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(t,e,n){if((j().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||j().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:qn.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,n,r,i){if(j().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:qn.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=e;if(o!=null){let d;l?d=new ti(a,Zr):d=new Xs(a,Zr);const p=this.runWebGLProgram(d,[{dataId:t,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(n!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return n;const c=this.activeTimers!=null;let u;c&&(u=en());let h;if(r==="complex64"){const d=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);h=Ar(d,p)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=en()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}const e=this.texData.get(t),{values:n,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=e;if(i!=null){let f;l?f=new ti(r,Zr):f=new Xs(r,Zr);const m=this.runWebGLProgram(f,[{dataId:t,shape:r,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(n!=null)return this.convertAndCacheOnCPU(t);if(j().getBool("DEBUG")&&!j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&j().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&j().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...td(r))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=f[0],g=f[1];h=Ar(m,g)}else if(c==null)h=this.getValuesFromTexture(t);else{const f=K(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const f=this.gpgpu.gl;lt(f,()=>f.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(t,h),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Gn().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,e={}){const n=this.texData.get(t),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new ti(i,Zr):p=new Xs(i,Zr);const f=this.runWebGLProgram(p,[{dataId:t,shape:i,dtype:a}],a),m=this.readToGPU(f,e);return this.disposeIntermediateTensorInfo(f),m}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(t,e.customTexShape),h=Gn().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const n=e.map(r=>$r(r));return Tt(t.shape,t.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Tt(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const n=t[e];if(!m6(n))throw j().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),i=K(e);if(j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(t),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...td(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),f}const o=j().getBool("WEBGL_PACK")&&r===!0,a=o?sd(e):e,l=o?new DY(a):new EY(a),c=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=tr(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=tr(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=FS(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:en(),endMs:null}}endTimer(t){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=en(),t)}async getQueryTime(t){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(t),l=a&&a.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,i,o)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=u7){return j().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&K(n.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){jn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return o7(t.shape,e)}packedUnaryOp(t,e,n){const r=new ti(t.shape,e),i=this.compileAndRun(r,[t],n);return Gn().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=b$(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(j().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,p1,t.dtype);const e=new Xs(t.shape,p1),n=this.compileAndRun(e,[t]);return Gn().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if(e==="string"&&n!=null&&n.length>0&&Gs(n[0])){const i=n.map(o=>qs(o));r=this.write(i,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return Gn().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new i7(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new U8(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[ua(t.shape),...ha(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},i=[ua(e),...ha(e)],o=new v$(i,n),a=!0,l=[n],c=this.runWebGLProgram(o,[r],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:i,dtype:o}=n;if(e!=null){const d=K(i),p=e[0]*e[1]*4;$(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=sd(i);let l;r?l=new _Y(a):l=new $Y(a);const c=!0,u=[e??td(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:t}],o,u,c,e);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(t,e,n,r,i=!1,o){const a=this.makeTensorInfo(t.outputShape,n),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===xc.DENSE){const y=o??td(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),K(a.shape)===0)return l.values=Le(a.dtype,0),a;const c=[],u=e.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&K(y.shape)<=j().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!op(b.shape,y.shape)){const w=y,x=y.shape;y.shape=b.shape,y=this.packedReshape(y,x),c.push(y),b=this.texData.get(y.dataId),w.shape=x}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=NY(t,u,h),p=this.getAndSaveBinary(d,()=>kY(this.gpgpu,t,u,h)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),j().get("ENGINE_COMPILE_ONLY")||IY(this.gpgpu,p,u,h,r),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));const g=j().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=en();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!j().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(t,e,n,r,i=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(j().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=W(()=>{if(!j().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=j().getBool("DEBUG");j().set("DEBUG",!1);const e=this.abs(gt(1e-8)).dataSync()[0];if(j().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?a7:l7}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:i,texture:o,usage:a,isPacked:l}=e;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=en());let h=e.texShape;if(h==null&&(h=O6(n,l),e.texShape=h),i!=null){const d=sd(n);let p,f=h[1],m=h[0];const g=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Sl(h[0],h[1])),l?p=new OY(d,g):p=new c1(d,g);const y=g?[m,f]:h,b=this.makeTensorInfo(y,r),w=this.texData.get(b.dataId);g?w.usage=qn.PIXELS:w.usage=qn.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,i);const x=[[m,f]],C=this.runWebGLProgram(p,[b],r,x,!0),k=this.texData.get(C.dataId);e.texShape=k.texShape,e.isPacked=k.isPacked,e.usage=k.usage,j().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(e.texture=k.texture,e.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=en()-u)}else{const d=this.acquireTexture(h,a,r,l);e.texture=d}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return e!=null&&(n.values=p7(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*sc(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise(r=>{try{this.checkCompletion_(e),r(!0)}catch(i){throw i}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Rb(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(o$(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:n,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=h$(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=o,t.outShapeStridesLocation=a,t.outTexShapeLocation=l}}createTensorFromGPUData(t,e,n){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=t,l=Gn().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,e,n,i,o,a);return Gn().makeTensorFromDataId(c,e,n,l)}}Fm.nextDataId=0;function p7(s,t){if(t==="float32"||t==="complex64")return s;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let n=0;n<e.length;++n)e[n]=Math.round(s[n]);return e}else throw new Error(`Unknown dtype ${t}`)}l0()&&h0("webgl",()=>new Fm,2);const Mx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class go{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=St(e,n),this.enableShapeUniforms=tn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Eo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Nl{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=St(e,n);const i=this.outputShape.length;this.enableShapeUniforms=tn(i);let o="";if(r)if(i===0||K(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Ht(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=on("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function zn(s){const{inputs:t,backend:e}=s,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const f7={kernelName:Ba,backendName:"webgl",kernelFunc:zn};function _i(s){const{inputs:t,backend:e}=s,{real:n,imag:r}=t,i=e.makeTensorInfo(n.shape,"complex64"),o=e.texData.get(i.dataId),a=zn({inputs:{x:n},backend:e}),l=zn({inputs:{x:r},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const m7={kernelName:Ep,backendName:"webgl",kernelFunc:_i};const S$="return (a < 0.) ? b * a : a;",C$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function g7(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{alpha:i}=n,o=e.makeTensorInfo([],"float32",Lr(i,"float32")),a=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(C$,r.shape,o.shape):new go(S$,r.shape,o.shape),l=e.runWebGLProgram(a,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),l}const y7={kernelName:qc,backendName:"webgl",kernelFunc:g7};const T$="return (a < 0.) ? b * a : a;",k$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function b7(s){const{inputs:t,backend:e}=s,{x:n,alpha:r}=t,i=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(k$,n.shape,r.shape):new go(T$,n.shape,r.shape);return e.runWebGLProgram(i,[n,r],"float32")}const x7={kernelName:pu,backendName:"webgl",kernelFunc:b7};const $l="if (isnan(x)) return x;";function Ft({opSnippet:s,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=n||o.dtype;if(a.shouldExecuteOnCPU([o])&&e!=null){const h=a.texData.get(o.dataId),d=e(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let u;return c?u=new ti(o.shape,t):u=new Xs(o.shape,s),a.runWebGLProgram(u,[o],l)}}function Ye({opSnippet:s,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(n&&l.dtype==="complex64"){const f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(w=>{const[x,v]=w,C={dataId:x.dataId,dtype:x.dtype,shape:l.shape},k={dataId:v.dataId,dtype:v.dtype,shape:c.shape},I=new go(s,l.shape,c.shape);return u.runWebGLProgram(I,[C,k],bn(x.dtype,v.dtype))}),b=_i({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const h=i||bn(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&r!=null){const f=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?Or(f):f,y=l.dtype==="string"?Or(m):m,[b,w]=r(l.shape,c.shape,g,y,h),x=u.makeTensorInfo(w,h),v=u.texData.get(x.dataId);return v.values=b,x}const d=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let p;return d?p=new Nl(t,l.shape,c.shape,e):p=new go(s,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function wc(s,t=!1){if(s==="linear")return t?t7:K8;if(s==="relu")return t?n7:Z8;if(s==="elu")return t?e7:Y8;if(s==="relu6")return t?s7:J8;if(s==="prelu")return t?k$:T$;if(s==="leakyrelu")return t?C$:S$;if(s==="sigmoid")return t?r7:Q8;throw new Error(`Activation ${s} has not been implemented for the WebGL backend.`)}class I${constructor(t,e,n,r=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=tn(this.outputShape.length);const u=r?t[1]:t[2],h=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let w="rc.x",x="rc.x";t[0]<e[0]?w=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(x=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${x};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}const f1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class m1{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=St(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const g1="return a * b;";function Bx(s){const{inputs:t,backend:e}=s,{a:n,b:r}=t,i=bn(n.dtype,r.dtype);if(n.dtype==="complex64"){const a=e.texData.get(n.dataId),l=e.texData.get(r.dataId),c=new m1(f1.REAL,n.shape,r.shape),u=new m1(f1.IMAG,n.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=e.runWebGLProgram(c,h,"float32"),p=e.runWebGLProgram(u,h,"float32"),f=_i({inputs:{real:d,imag:p},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([n,r])){const a=e.texData.get(n.dataId),l=e.texData.get(r.dataId),[c,u]=b8(n.shape,r.shape,a.values,l.values,i),h=e.makeTensorInfo(u,i),d=e.texData.get(h.dataId);return d.values=c,h}let o;return j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Nl(g1,n.shape,r.shape):o=new go(g1,n.shape,r.shape),e.runWebGLProgram(o,[n,r],i)}const w7={kernelName:qa,backendName:"webgl",kernelFunc:Bx};function v7(s,t,e){const n=[ua(s.shape),...ha(s.shape)],r={dtype:s.dtype,shape:n,dataId:s.dataId},i=[ua(t),...ha(t)],o=new v$(i,n),a=!0,l=[n],c=e.runWebGLProgram(o,[r],s.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function ot(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{shape:i}=n,o=e,a=K(r.shape),l=t0(i,a),c=K(l);$(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(r.dataId);return u.isPacked&&!op(r.shape,l)&&!(u.texture!==null&&op(u.shape,l))?v7(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const S7={kernelName:mu,backendName:"webgl",kernelFunc:ot};class y1{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const a=Math.floor(n/4)*4,l=n%4;let c="sumValue += dot(values, ones);";if(e!=null){const h=1/e;c=`sumValue += dot(values * ${no(h)?h.toPrecision(2):h}, ones);`}let u="";i%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}class C7{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?c="sumValue":e==="prod"?c="prodValue":e==="all"?c="allValue":e==="any"&&(c="anyValue");const u=Math.floor(n/4)*4,h=n%4;let d=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";e==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):e==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";i%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}function T7(s){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:s[1],n=bm(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Do(s,t,e,n){const r=T7(s.shape);let i=s;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let u,h;e==="mean"?u=o===0?new y1({windowSize:l,inSize:a,batchSize:s.shape[0],outSize:c},a):new y1({windowSize:l,inSize:a,batchSize:s.shape[0],outSize:c}):u=new C7({windowSize:l,inSize:a,batchSize:s.shape[0],outSize:c},e),h=i,i=n.runWebGLProgram(u,[i],t),h.dataId!==s.dataId&&n.disposeIntermediateTensorInfo(h)}return i}class k7{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[e[o]];this.outputShape=n,this.rank=n.length;const r=Ht(this.rank),i=I7(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function I7(s){const t=s.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let r=0;r<s.length;r++)n[s[r]]=e[r];return n.join()}class N7{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ht(this.rank),i=w$("rc",this.rank),o=new Array(this.rank);for(let u=0;u<e.length;u++)o[e[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}function Pm(s,t,e){const n=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new N7(s.shape,t):new k7(s.shape,t);return e.runWebGLProgram(n,[s],s.dtype)}function $7(s,t,e,n){const r=t,i=s.shape.length,o=$t(r,s.shape);let a=o;const l=ce(a,i),c=l!=null;let u=s;c&&(u=Pm(s,l,n),a=me(a.length,i)),qe("sum",a,i);const[h,d]=ze(u.shape,a);let p=h;e&&(p=fe(h,o));const f=K(d),g=K(s.shape)/f,y=ot({inputs:{x:u},attrs:{shape:[g,f]},backend:n}),b=Df(s.dtype),w=Do(y,b,"sum",n),x=ot({inputs:{x:w},attrs:{shape:p},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),c&&n.disposeIntermediateTensorInfo(u),x}function Lm(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n;return $7(r,i,o,e)}const _7={kernelName:vu,backendName:"webgl",kernelFunc:Lm};function ln(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{perm:i}=n,o=e,a=r.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=r.shape[i[u]];let c;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,d=Lx(h,r.shape,r.dtype,i,l);c=o.makeTensorInfo(l,r.dtype);const p=o.texData.get(c.dataId);p.values=d}else c=Pm(r,i,o);return c}const E7={kernelName:Zi,backendName:"webgl",kernelFunc:ln};const N$=1e3;function ap({a:s,b:t,transposeA:e,transposeB:n,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=s.shape.length,u=t.shape.length,h=e?s.shape[c-2]:s.shape[c-1],d=n?t.shape[u-1]:t.shape[u-2],p=e?s.shape[c-1]:s.shape[c-2],f=n?t.shape[u-2]:t.shape[u-1],m=s.shape.slice(0,-2),g=t.shape.slice(0,-2),y=K(m),b=K(g),x=St(s.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);$(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${s.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);const v=e?[y,h,p]:[y,p,h],C=n?[b,f,d]:[b,d,f],k=ot({inputs:{x:s},backend:r,attrs:{shape:v}}),I=ot({inputs:{x:t},backend:r,attrs:{shape:C}}),N=[k,I],_=Math.max(y,b),T=e?k.shape[1]:k.shape[2],D=i!=null,R=o!=null,P=l==="leakyrelu",B=l!=null?wc(l,!0):null,U=D||R||P||B!=null;let H;if((p===1||f===1)&&T>N$&&U===!1){let X=k,Z=I;e&&(X=ln({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),N.push(X)),n&&(Z=ln({inputs:{x:I},backend:r,attrs:{perm:[0,2,1]}}),N.push(Z));const J=f!==1,et=f===1;let Q=X;J&&(Q=ot({inputs:{x:X},backend:r,attrs:{shape:[_,T,1]}}),N.push(Q));const st=f===1?2:1;let it=Z;et&&(it=ot({inputs:{x:Z},backend:r,attrs:{shape:[_,1,T]}}),N.push(it));const at=Bx({inputs:{a:Q,b:it},backend:r});H=Lm({inputs:{x:at},backend:r,attrs:{axis:st,keepDims:!0}}),N.push(at)}else{const X=bn(s.dtype,t.dtype),Z=new I$(v,C,[_,p,f],e,n,D,B,R,P),J=[k,I];if(i!=null&&J.push(i),R&&J.push(o),P){const et=r.makeTensorInfo([],"float32",Lr(a,"float32"));J.push(et),N.push(et)}H=r.runWebGLProgram(Z,J,X)}const G=ot({inputs:{x:H},backend:r,attrs:{shape:x}});N.push(H);for(const X of N)r.disposeIntermediateTensorInfo(X);return G}function D7(s){const{inputs:t,backend:e,attrs:n}=s,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=n;return ap({a:r,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const A7={kernelName:rc,backendName:"webgl",kernelFunc:D7};const b1="return abs(x);";function O7(s){const{inputs:t,backend:e}=s,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){const i=e.texData.get(n.dataId),o=b$(i.values);return e.makeTensorInfo(n.shape,n.dtype,o)}let r;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ti(n.shape,b1):r=new Xs(n.shape,b1),e.runWebGLProgram(r,[n],n.dtype)}const R7={kernelName:Ic,backendName:"webgl",kernelFunc:O7};const F7=fs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,P7=Ft({opSnippet:F7}),L7={kernelName:xa,backendName:"webgl",kernelFunc:P7};const M7=fs+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,B7=Ft({opSnippet:M7}),z7={kernelName:wa,backendName:"webgl",kernelFunc:B7};const x1="return a + b;",V7=Ye({opSnippet:x1,packedOpSnippet:x1,supportsComplex:!0,cpuKernelImpl:ZY}),W7={kernelName:vo,backendName:"webgl",kernelFunc:V7};class U7{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const n=[];this.variableNames.forEach(i=>{n.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class G7{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const n=[];this.variableNames.forEach(i=>{n.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function Sd(s){const{inputs:t,backend:e}=s,n=t;if(n.length===1)return zn({inputs:{x:n[0]},backend:e});if(n.length>j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(n.length/2),c=Sd({inputs:n.slice(0,l),backend:e}),u=Sd({inputs:n.slice(l),backend:e});return Sd({inputs:[c,u],backend:e})}const r=n.map(l=>l.dtype).reduce((l,c)=>bn(l,c)),i=n.map(l=>l.shape),a=j().getBool("WEBGL_PACK")?new G7(n[0].shape,i):new U7(n[0].shape,i);return e.runWebGLProgram(a,n,r)}const j7={kernelName:Nc,backendName:"webgl",kernelFunc:Sd};function H7(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n,a=r.shape.length,l=$t(i,r.shape);let c=l;const u=ce(c,a);let h=r;u!=null&&(h=ln({inputs:{x:r},backend:e,attrs:{perm:u}}),c=me(c.length,a)),qe("all",c,a);const[d,p]=ze(h.shape,c),f=K(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"all",e);let y;if(o){const b=fe(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}const X7={kernelName:Tp,backendName:"webgl",kernelFunc:H7};function q7(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n,a=r.shape.length,l=$t(i,r.shape);let c=l;const u=ce(c,a);let h=r;u!=null&&(h=ln({inputs:{x:r},backend:e,attrs:{perm:u}}),c=me(c.length,a)),qe("any",c,a);const[d,p]=ze(h.shape,c),f=K(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"any",e);let y;if(o){const b=fe(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}const K7={kernelName:kp,backendName:"webgl",kernelFunc:q7};class Y7{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=e==="max"?">":"<",l=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class Z7{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,$(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],o=Math.ceil(i/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Ht(l),u=on("coords",l);let h,d;if(o===1){d=l+1;const I=Ht(d);h=`
        ${I} sourceLocR = ${I}(${u.join()}, 0);
        ++${u[l-1]};
        ${I} sourceLocG = ${I}(${u.join()}, 0);
        ++${u[l-2]};
        ${I} sourceLocA = ${I}(${u.join()}, 0);
        --${u[l-1]};
        ${I} sourceLocB = ${I}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(I=>"int "+I),g=on("sourceLocR",d-1).concat("inIdx.r"),y=on("sourceLocG",d-1).concat("inIdx.g"),b=on("sourceLocB",d-1).concat("inIdx.b"),w=on("sourceLocA",d-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function $$(s,t,e,n=null){let r=t.shape[0],i=t.shape[1];n!=null&&(r=n.shape[0],i=n.shape[1]);const o=bm(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new Y7(a,e,n==null),c=[t];n!=null&&c.push(n);const u=s.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=$$(s,t,e,u);return s.disposeIntermediateTensorInfo(u),h}function _$(s,t,e,n=null){const r=n!=null?n.shape:t.shape,i=r[r.length-1],o=bm(i),a=new Z7(r,o,e,n==null),l=n==null?[t]:[t,n],c=s.runWebGLProgram(a,l,"int32");if(c.shape.length===t.shape.length){const u=_$(s,t,e,c);return s.disposeIntermediateTensorInfo(c),u}return c}function E$(s,t,e,n){const r=[e];if(qe("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.shape.length),!j().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=s.texData.get(t.dataId),a=o!==null&&o.isPacked;let l=t;a&&(l=s.unpackTensor(t),i.push(l));const[c,u]=ze(l.shape,r),h=K(u),d=ot({inputs:{x:l},backend:s,attrs:{shape:[-1,h]}});i.push(d);const p=$$(s,d,n);i.push(p);const f=ot({inputs:{x:p},backend:s,attrs:{shape:c}});return i.forEach(m=>s.disposeIntermediateTensorInfo(m)),f}return _$(s,t,n)}function J7(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i}=n;let o=$t(i,r.shape);const a=ce(o,r.shape.length);let l=r;const c=[];a!=null&&(l=ln({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=me(o.length,l.shape.length)),qe("argMax",[o[0]],l.shape.length);const u=E$(e,l,o[0],"max");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),u}const Q7={kernelName:$c,backendName:"webgl",kernelFunc:J7};function t9(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i}=n;let o=$t(i,r.shape);const a=ce(o,r.shape.length);let l=r;const c=[];a!=null&&(l=ln({inputs:{x:r},backend:e,attrs:{perm:a}}),c.push(l),o=me(o.length,l.shape.length)),qe("argMin",[o[0]],l.shape.length);const u=E$(e,l,o[0],"min");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),u}const e9={kernelName:_c,backendName:"webgl",kernelFunc:t9};const n9=fs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,s9=Ft({opSnippet:n9}),r9={kernelName:va,backendName:"webgl",kernelFunc:s9};const i9=fs+"return log(x + sqrt(x * x + 1.0));",o9=Ft({opSnippet:i9}),a9={kernelName:Sa,backendName:"webgl",kernelFunc:o9};const l9=fs+`
  return atan(x);
`,c9=Ft({opSnippet:l9}),u9={kernelName:Ca,backendName:"webgl",kernelFunc:c9};const h9=Mx+`
  return atan(a, b);
`,d9=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Eo+`
  return result;
`,p9=Ye({opSnippet:h9,packedOpSnippet:d9}),f9={kernelName:ka,backendName:"webgl",kernelFunc:p9};const m9=fs+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,g9=Ft({opSnippet:m9}),y9={kernelName:Ta,backendName:"webgl",kernelFunc:g9};class vc{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),n){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let x=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(x="avgValue / max(count, 1.0)");const v=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${v};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${x});
      }
    `}}class zx{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const w=e==="avg";let x="0.0";if(w||(x="-1.0 / 1e-20"),n){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(C="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,I=o%4,N=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${k};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${C});
      }
    `}}function b9(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t;lh(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n,c=1;$(Xe(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ds(r.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Dt(u.inShape,u.outShape))return zn({inputs:{x:r},backend:e});const h=new vc(u,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}const x9={kernelName:Ec,backendName:"webgl",kernelFunc:b9};function w9(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=n,u=[1,1,1],h=Mr(r.shape,i,o,u,a,l,c),d=new zx(h,"avg",!1);return e.runWebGLProgram(d,[r],"float32")}const v9={kernelName:Dc,backendName:"webgl",kernelFunc:w9};class S9{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,u=l-1-t.padInfo.top,h=c-1-t.padInfo.left,d=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class C9{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,h=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=h-1-t.padInfo.front,m=d-1-t.padInfo.top,g=p-1-t.padInfo.left,y=1/(e*n*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function T9(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=n,h=[1,1,1],d=Mr(o.shape,a,l,h,c,u),p=new C9(d);return e.runWebGLProgram(p,[r],o.dtype)}const k9={kernelName:Np,backendName:"webgl",kernelFunc:T9};function I9(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,o=i;lh([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=n,u=ds(o.shape,a,l,1,c),h=new S9(u);return e.runWebGLProgram(h,[r],o.dtype)}const N9={kernelName:Ip,backendName:"webgl",kernelFunc:I9};function $9(s){const{inputs:t,backend:e,attrs:n}=s,{a:r,b:i}=t,{transposeA:o,transposeB:a}=n;return ap({a:r,b:i,transposeA:o,transposeB:a,backend:e})}const _9={kernelName:Ac,backendName:"webgl",kernelFunc:$9};class E9{constructor(t,e,n,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],St(t,e),St(t,n);let a="0.0";r!=null&&(St(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(St(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class D9{constructor(t,e,n,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],St(t,e),St(t,n);let a="vec4(0.0)";r!=null&&(St(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(St(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const A9=({inputs:s,backend:t,attrs:e})=>{const{x:n,mean:r,variance:i,offset:o,scale:a}=s;$(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);const c=[n,r,i];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const d=j().getBool("WEBGL_PACK_NORMALIZATION")?new D9(n.shape,r.shape,i.shape,u,h,l):new E9(n.shape,r.shape,i.shape,u,h,l);return t.runWebGLProgram(d,c,c[0].dtype)},O9={kernelName:jc,backendName:"webgl",kernelFunc:A9};class R9{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Ht(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=F9(this.rank);let r;const i=t.map((o,a)=>`sourceLoc.${Ey[a]} = start[${a}] + coords.${Ey[a]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}}const Ey=["x","y","z","w","u","v"];function F9(s){if(s===1)return"sourceLoc";if(s<=6)return Ey.slice(0,s).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${s} is not yet supported`)}class P9{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Ht(this.rank),n=on("coords",this.rank),r=on("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((u,h)=>`start[${h}]`).join()});`:t.map((u,h)=>`${r[h]} = ${n[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}function L9(s,t,e,n){const r=n.texData.get(s.dataId),i=n.makeTensorInfo(e,s.dtype),o=n.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=s.dtype;let a=Ab(t,yt(s.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||s.dataId};const l=n.dataRefCount.get(o.slice.origDataId)||1;return n.dataRefCount.set(o.slice.origDataId,l+1),i}function _l(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{begin:i,size:o}=n,[a,l]=ym(r,i,o);if(_b(r,a,l),K(l)===0)return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=e.texData.get(r.dataId),d=_8(h.values,a,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,d)}const{isPacked:c}=e.texData.get(r.dataId),u=Db(r.shape,a,l);if(c||!u){const h=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new P9(l):new R9(l),d=[a];return e.runWebGLProgram(h,[r],r.dtype,d)}return e.uploadToGPU(r.dataId),L9(r,a,l,e)}const M9={kernelName:wu,backendName:"webgl",kernelFunc:_l};const B9=s=>{const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockShape:i,crops:o}=n;$(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,w)=>b*w),l=Ku(r.shape,i,a),c=Yu(l.length,i.length),u=Zu(r.shape,i,a),h=Mb(o,i.length),d=Bb(u,o,i.length),p=[],f=ot({inputs:{x:r},backend:e,attrs:{shape:l}}),m=ln({inputs:{x:f},backend:e,attrs:{perm:c}}),g=ot({inputs:{x:m},backend:e,attrs:{shape:u}}),y=_l({inputs:{x:g},backend:e,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y},z9={kernelName:Oc,backendName:"webgl",kernelFunc:B9};function V9(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,weights:i}=t,{size:o}=n,a=e.readSync(r.dataId),l=e.readSync(i.dataId),c=y$(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}const W9={kernelName:$p,backendName:"webgl",kernelFunc:V9};const U9=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,G9=`
  return float(int(a.r) & int(b.r));
`;function j9(s){const{inputs:t,backend:e}=s,{a:n,b:r}=t,i=j().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=j().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([n,r])||o===1){const l=e.texData.get(n.dataId).values,c=e.texData.get(r.dataId).values,[u,h]=QY(n.shape,r.shape,l,c,n.dtype),d=e.makeTensorInfo(h,n.dtype),p=e.texData.get(d.dataId);return p.values=u,d}let a;return i?a=new Nl(U9,n.shape,r.shape,!1):a=new go(G9,n.shape,r.shape),e.runWebGLProgram(a,[n,r],n.dtype)}const H9={kernelName:Rc,backendName:"webgl",kernelFunc:j9};function X9(s){const{inputs:t,backend:e}=s,{s0:n,s1:r}=t,i=e.readSync(n.dataId),o=e.readSync(r.dataId),a=St(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const q9={kernelName:_p,backendName:"webgl",kernelFunc:X9};const K9="return float(a != b);",D$=Ye({opSnippet:K9,cpuKernelImpl:w8,dtype:"bool"}),Y9={kernelName:lu,backendName:"webgl",kernelFunc:D$};function uh(s){const{inputs:t,backend:e}=s,{input:n}=t,r=e.texData.get(n.dataId);return zn({inputs:{x:r.complexTensorInfos.real},backend:e})}const Z9={kernelName:uf,backendName:"webgl",kernelFunc:uh};const J9="return float(int(x));";function Q9(s,t){const e=new Xs(s.shape,J9),n=t.runWebGLProgram(e,[s],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function Dy(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{dtype:i}=n;if(i==="complex64"){if(r.dtype==="complex64")return zn({inputs:{x:r},backend:e});const o=ve(r.shape),a=Dy({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=_i({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=uh({inputs:{input:r},backend:e}),a=Dy({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!e0(r.dtype,i)){const o=zn({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[a,l,c]=t8(o,r.shape,r.dtype,i);return e.makeTensorInfo(a,l,c)}if(i==="int32")return Q9(r,e);if(i==="bool"){const o=e.makeTensorInfo([],"bool",Le("bool",1)),l=D$({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const tZ={kernelName:Ia,backendName:"webgl",kernelFunc:Dy};const w1="return ceil(x);",eZ=Ft({opSnippet:w1,packedOpSnippet:w1,cpuKernelImpl:e8}),nZ={kernelName:Na,backendName:"webgl",kernelFunc:eZ};class sZ{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class rZ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function iZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{clipValueMin:i,clipValueMax:o}=n;let a;j().getBool("WEBGL_PACK_CLIP")?a=new rZ(r.shape):a=new sZ(r.shape);const l=[[i],[o]];return e.runWebGLProgram(a,[r],r.dtype,l)}const oZ={kernelName:$a,backendName:"webgl",kernelFunc:iZ};class aZ{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function v1(s,t){return{dataId:t.dataId,dtype:t.dtype,shape:s.shape}}function lZ(s){const{inputs:t,backend:e}=s,{x:n}=t,r=e.texData.get(n.dataId),i=new aZ(n.shape),o=[v1(n,r.complexTensorInfos.real),v1(n,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}const cZ={kernelName:Fc,backendName:"webgl",kernelFunc:lZ};class uZ{constructor(t){this.outputShape=[],this.outputShape=Ys(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const a=e[o-1];n.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=e.length,i=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}}class hZ{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ys(t,e);const n=this.outputShape,r=n.length,i=Ht(r),o=on("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],u=a.slice(-2),h=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];d+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${od(a,c,g)}),
            vec2(${od(u,c,g)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${od(a,c,f)}),
          vec2(${od(u,c,f)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${n[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${n[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${n[r-2]} &&
            ${o[r-1]} < ${n[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function od(s,t,e){const n=s.indexOf(t);return s.map((i,o)=>o===n?`${i} - ${e}`:i).join()}function Mm(s){const{inputs:t,backend:e}=s,{input:n}=t,r=e.texData.get(n.dataId);return zn({inputs:{x:r.complexTensorInfos.imag},backend:e})}const dZ={kernelName:Kp,backendName:"webgl",kernelFunc:Mm};function jl(s,t,e){const n=s[0].dtype;if(n==="complex64"){const p=s.map(b=>uh({inputs:{input:b},backend:e})),f=s.map(b=>Mm({inputs:{input:b},backend:e})),m=jl(p,t,e),g=jl(f,t,e),y=_i({inputs:{real:m,imag:g},backend:e});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let r=e.shouldExecuteOnCPU(s);if(n==="string"&&(r=!0),r){const p=s.map(x=>{const C=[-1,K(x.shape.slice(t))];return ot({inputs:{x},backend:e,attrs:{shape:C}})}),f=p.map(x=>({vals:e.readSync(x.dataId),shape:x.shape})),m=Ys(p.map(x=>x.shape),1),g=p[0].shape[0]===1,y=n8(f,m,n,g),b=Ys(s.map(x=>x.shape),t),w=e.makeTensorInfo(b,n,y);return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),w}const i=s.filter(p=>K(p.shape)>0),o=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const p=o?new Xs(s[0].shape,Zr):new ti(s[0].shape,Zr);return e.runWebGLProgram(p,s,n)}const a=j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const p=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);p.push(jl(g,t,e))}const f=jl(p,t,e);for(const m of p)e.disposeIntermediateTensorInfo(m);return f}if(o){const p=new hZ(i.map(f=>f.shape),t);return e.runWebGLProgram(p,i,n)}const{tensors2D:l,outShape:c}=pZ(i,t,e),u=new uZ(l.map(p=>p.shape)),h=e.runWebGLProgram(u,l,n);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const d=ot({inputs:{x:h},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(h),d}function pZ(s,t,e){const n=Ys(s.map(i=>i.shape),t);return{tensors2D:s.map(i=>ot({inputs:{x:i},attrs:{shape:[-1,K(i.shape.slice(t))]},backend:e})),outShape:n}}function A$(s){const{inputs:t,backend:e,attrs:n}=s,{axis:r}=n,i=$t(r,t[0].shape)[0],o=t.map(c=>c.shape);Fb(o,i);const a=Ys(t.map(c=>c.shape),i);if(K(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>K(c.shape)>0);return l.length===1?zn({inputs:{x:l[0]},backend:e}):jl(l,i,e)}const fZ={kernelName:Pc,backendName:"webgl",kernelFunc:A$};class O${constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,w=g?3:1;let x="",v="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${v}
        setOutput(result);
      }
    `}}class mZ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,h=t.filterDepth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class R${constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=tn(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,h=u;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(d+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?Sp(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}class gZ{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=tn(this.outputShape.length);const{dataFormat:n}=e,r=hn(),i=n==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}function lp(s,t){const e=s.length;return e>=3?t?[...s.slice(0,-3),s[e-3]*s[e-2],s[e-1]]:[...s.slice(0,-3),s[e-3],s[e-2]*s[e-1]]:!t&&e===1&&s[0]>1?[s[0],1]:null}function F$({x:s,filter:t,convInfo:e,backend:n,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=s.shape,c=n.texData.get(s.dataId),u=e.inChannels,h=l[0]*l[1]*l[2],d=e.outChannels,p=e.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(i!=null){const x=lp(i.shape,p);x!=null&&(i=ot({inputs:{x:i},backend:n,attrs:{shape:x}}),y.push(i))}if(r!=null){const x=lp(r.shape,p);x!=null&&(r=ot({inputs:{x:r},backend:n,attrs:{shape:x}}),y.push(r))}if(!((h===1||d===1)&&u>N$)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&Dt(c.shape.slice(-3),l.slice(-3))){const x=l[0]*l[1]*(l[2]+1),v={dataId:s.dataId,shape:[1,x,e.inChannels],dtype:s.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,$(op(c.shape,v.shape),()=>`packed reshape ${c.shape} to ${v.shape} isn't free`);const k=ot({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(k);const I=ap({a:v,b:k,backend:n,transposeA:f,transposeB:m,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),N=n.texData.get(I.dataId);$(N.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,N.shape=e.outShape,g=zn({inputs:{x:I},backend:n}),g.shape=e.outShape,y.push(I)}else{const x=e.outHeight*e.outWidth,v=ot({inputs:{x:s},backend:n,attrs:{shape:p?[e.batchSize,x,e.inChannels]:[e.batchSize,e.inChannels,x]}}),C=ot({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),k=ap({a:p?v:C,b:p?C:v,transposeA:!p,transposeB:m,backend:n,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=ot({inputs:{x:k},backend:n,attrs:{shape:e.outShape}}),y.push(v),y.push(C),y.push(k)}for(const x of y)n.disposeIntermediateTensorInfo(x);return g}function P$({x:s,filter:t,convInfo:e,backend:n,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=e,f=p==="channelsLast",m=l*c*u,g=d*h,y=[e.batchSize,m,g],b=!0,w=!1,x=[];if(i!=null){const G=lp(i.shape,f);G!=null&&(i=ot({inputs:{x:i},backend:n,attrs:{shape:G}}),x.push(i))}if(r!=null){const G=lp(r.shape,f);G!=null&&(r=ot({inputs:{x:r},backend:n,attrs:{shape:G}}),x.push(r))}const v=ot({inputs:{x:t},backend:n,attrs:{shape:[1,m,K(t.shape)/m]}});x.push(v);const C=new gZ(y,e),k=[s.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],I=n.runWebGLProgram(C,[s],"float32",k),N=ot({inputs:{x:I},backend:n,attrs:{shape:y}});x.push(I),x.push(N);const _=r!=null,T=i!=null,D=a==="leakyrelu",R=a?wc(a,!0):null,P=new I$(f?N.shape:v.shape,f?v.shape:N.shape,f?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],b,w,_,R,T,D),B=f?[N,v]:[v,N];if(r&&B.push(r),T&&B.push(i),D){const G=n.makeTensorInfo([],"float32",Lr(o,"float32"));B.push(G),x.push(G)}const U=n.runWebGLProgram(P,B,"float32"),H=ot({inputs:{x:U},backend:n,attrs:{shape:e.outShape}});x.push(U);for(const G of x)n.disposeIntermediateTensorInfo(G);return H}function yZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=n,h=Br(l),d=Be(r.shape,i.shape,o,c,a,u,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=F$({x:r,filter:i,convInfo:d,backend:e});else if(d.strideWidth<=2&&h==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){const m=new R$(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=e.runWebGLProgram(m,[r,i],"float32",g)}else if(j().getBool("WEBGL_CONV_IM2COL"))p=P$({x:r,filter:i,convInfo:d,backend:e});else{const m=new O$(d);p=e.runWebGLProgram(m,[r,i],"float32")}const f=ot({inputs:{x:p},backend:e,attrs:{shape:d.outShape}});return e.disposeIntermediateTensorInfo(p),f}const bZ={kernelName:Lc,backendName:"webgl",kernelFunc:yZ};class xZ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wZ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,l=n-1-t.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vZ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,o=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class SZ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=e-1-t.padInfo.front,c=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function CZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=n,h=Br(l),d=Be(r.shape,u,o,1,a,c,!1,h),p=new xZ(d);return e.runWebGLProgram(p,[r,i],"float32")}const TZ={kernelName:Dp,backendName:"webgl",kernelFunc:CZ};class kZ{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=tn(this.outputShape.length);const e=t.filterHeight,n=t.filterWidth,r=e-1-t.padInfo.top,i=n-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function IZ(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=n,h=Br(c),d=Be(o,i.shape,a,1,l,u,!1,h);if(j().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new kZ(d);return e.runWebGLProgram(f,[r,i],"float32",p)}else{const p=new wZ(d);return e.runWebGLProgram(p,[r,i],"float32")}}const NZ={kernelName:Mc,backendName:"webgl",kernelFunc:IZ};function $Z(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=n,c=Si(r.shape,i.shape,o,l,a),u=new mZ(c);return e.runWebGLProgram(u,[r,i],"float32")}const _Z={kernelName:Bc,backendName:"webgl",kernelFunc:$Z};function EZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=n,c=Si(r.shape,l,o,1,a),u=new vZ(c);return e.runWebGLProgram(u,[r,i],"float32")}const DZ={kernelName:Ap,backendName:"webgl",kernelFunc:EZ};function AZ(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=n,c=Si(l,i.shape,a,1,o),u=new SZ(c);return e.runWebGLProgram(u,[r,i],"float32")}const OZ={kernelName:Op,backendName:"webgl",kernelFunc:AZ};const RZ=$l+`
  return cos(x);
`,FZ=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Eo}
  return result;
`,PZ=Ft({opSnippet:RZ,packedOpSnippet:FZ}),LZ={kernelName:_a,backendName:"webgl",kernelFunc:PZ};const MZ=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,BZ=Ft({opSnippet:MZ}),zZ={kernelName:Ea,backendName:"webgl",kernelFunc:BZ};class VZ{constructor(t,e,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[u]=e,[h,d]=n;this.outputShape=[u,h,d,c];const p=r==="bilinear"?1:0,[f,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[w,x,v]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${x};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const WZ=s=>{const{inputs:t,backend:e,attrs:n}=s,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=n,u=new VZ(r.shape,i.shape,a,l,c);return e.runWebGLProgram(u,[r,i,o],"float32")},UZ={kernelName:Fp,backendName:"webgl",kernelFunc:WZ};var Sc;(function(s){s.Prod="*",s.Sum="+"})(Sc||(Sc={}));class S1{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Sc.Prod?"1.0":"0.0",a=n?o:`getX(${C1(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";n?(c=r?`end != ${l-1}`:"end != 0",u=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ht(i)} coords = getOutputCoords();
        int end = ${T1(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${T1(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${C1(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function C1(s,t,e){if(s===1)return`${t}`;if(s===2)return`${t}.x, ${t}.y`;if(s===3)return`${t}.x, ${t}.y, ${t}.z`;if(s===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${s} is not yet supported`)}function T1(s,t,e){if(s===1)return`${t}`;if(s===2)return`${t}.y`;if(s===3)return`${t}.z`;if(s===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${s} is not yet supported`)}function L$(s,t,e,n,r,i){const o=t.shape.length,a=ce([n],o);let l=t;a!=null&&(l=ln({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=me(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);const u=l.shape[c];let h=zn({inputs:{x:l},backend:e});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const p=new S1(s,l.shape,!1,i),f=[[d]],m=h;h=e.runWebGLProgram(p,[h],h.dtype,f),e.disposeIntermediateTensorInfo(m)}if(r){const d=new S1(s,l.shape,r,i),p=h;h=e.runWebGLProgram(d,[h],h.dtype),e.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Ci(a),p=ln({inputs:{x:h},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(l),p}return h}function GZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,exclusive:o,reverse:a}=n;return L$(Sc.Prod,r,e,i,o,a)}const jZ={kernelName:Rp,backendName:"webgl",kernelFunc:GZ};function HZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,exclusive:o,reverse:a}=n;return L$(Sc.Sum,r,e,i,o,a)}const XZ={kernelName:zc,backendName:"webgl",kernelFunc:HZ};function qZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,weights:i}=t,{size:o,binaryOutput:a}=n;if(r.shape.length===1){const l=e.readSync(r.dataId),c=e.readSync(i.dataId),u=y$(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}else if(r.shape.length===2){const l=e.bufferSync(r),c=e.bufferSync(i),u=JY(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const KZ={kernelName:Pp,backendName:"webgl",kernelFunc:qZ};class YZ{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function ZZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockSize:i,dataFormat:o}=n,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],u=o==="NHWC"?r.shape[3]:r.shape[1],h=l*i,d=c*i,p=u/(i*i),f=o==="NHWC"?[a,h,d,p]:[a,p,h,d],m=new YZ(f,i,o);return e.runWebGLProgram(m,[r],r.dtype)}const JZ={kernelName:Lp,backendName:"webgl",kernelFunc:ZZ};class M${constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=tn(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";n&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:c=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");const h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}}class B${constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=tn(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,h=t.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<h;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){const b=y*2;if(p+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const w=a%2===0?Sp(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):w===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";n&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}function QZ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=n;let u=l;u==null&&(u=[1,1]),$(Xe(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=Be(r.shape,i.shape,o,u,a,c,!0);let d;j().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new B$(h):d=new M$(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return e.runWebGLProgram(d,[r,i],"float32",p)}const tJ={kernelName:Vc,backendName:"webgl",kernelFunc:QZ};class eJ{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nJ{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=e-1-t.padInfo.top,a=n-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function sJ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=n,h=Be(r.shape,u,o,a,l,c,!0),d=new eJ(h);return e.runWebGLProgram(d,[r,i],"float32")}const rJ={kernelName:Mp,backendName:"webgl",kernelFunc:sJ};function iJ(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=n,h=Be(u,i.shape,o,a,l,c,!0),d=new nJ(h);return e.runWebGLProgram(d,[r,i],"float32")}const oJ={kernelName:Bp,backendName:"webgl",kernelFunc:iJ};class aJ{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function lJ(s){const{inputs:t,backend:e}=s,{x:n}=t,r=[...n.shape,...n.shape],i=K(n.shape),o=ot({inputs:{x:n},backend:e,attrs:{shape:[i]}}),a=new aJ(i),l=e.runWebGLProgram(a,[o],o.dtype),c=ot({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}const cJ={kernelName:zp,backendName:"webgl",kernelFunc:lJ};class uJ{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function hJ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=n,c=Du(r.shape,i.shape,o,a,"NHWC",l);let u;const h=new uJ(c);u=e.runWebGLProgram(h,[r,i],"float32");const d=ot({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),d}const dJ={kernelName:Wc,backendName:"webgl",kernelFunc:hJ};function pJ(s){const{inputs:t,backend:e,attrs:n}=s,{equation:r}=n,i=t,{allDims:o,summedDims:a,idDims:l}=Xb(r,i.length);Kb(o.length,l,i);const{path:c,steps:u}=Yb(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=qb(p,l[g]);let w;Zb(y)?w=i[g]:(w=ln({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),f.push(w));const x=w.shape.slice();for(let v=0;v<b.length;++v)x.splice(b[v],0,1);Dt(w.shape,x)||(w=ot({inputs:{x:w},backend:e,attrs:{shape:x}}),f.push(w)),d===null?d=w:(d=Bx({inputs:{a:w,b:d},backend:e}),f.push(d))}m<h-1&&(c[m]>=0&&(d=Lm({inputs:{x:d},backend:e,attrs:{axis:c[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&e.disposeIntermediateTensorInfo(m);return d}const fJ={kernelName:Wp,backendName:"webgl",kernelFunc:pJ};const mJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",gJ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yJ=Ft({opSnippet:mJ,packedOpSnippet:gJ}),bJ={kernelName:Aa,backendName:"webgl",kernelFunc:yJ};const xJ="return (b >= 0.0) ? a : a * (b + 1.0);",wJ=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vJ=s=>{const{inputs:t,backend:e}=s,{dy:n,y:r}=t,i=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nl(wJ,n.shape,r.shape):new go(xJ,n.shape,r.shape);return e.runWebGLProgram(i,[n,r],n.dtype)},SJ={kernelName:Up,backendName:"webgl",kernelFunc:vJ};const CJ=`
  return vec4(equal(a, b));
`,TJ="return float(a == b);",kJ=Ye({opSnippet:TJ,packedOpSnippet:CJ,dtype:"bool",cpuKernelImpl:s8}),IJ={kernelName:Uc,backendName:"webgl",kernelFunc:kJ};const NJ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${zb};
  float a1 = ${Vb};
  float a2 = ${Wb};
  float a3 = ${Ub};
  float a4 = ${Gb};
  float a5 = ${jb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,$J=Ft({opSnippet:NJ}),_J={kernelName:Oa,backendName:"webgl",kernelFunc:$J};const EJ=$l+`
  return exp(x);
`,DJ=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,z$=Ft({opSnippet:EJ,packedOpSnippet:DJ,cpuKernelImpl:r8,dtype:"float32"}),AJ={kernelName:Ra,backendName:"webgl",kernelFunc:z$};function Ay(s){const{inputs:t,attrs:e,backend:n}=s,{dim:r}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&($(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),ot({inputs:{x:i},backend:n,attrs:{shape:a}})}const OJ={kernelName:Gc,backendName:"webgl",kernelFunc:Ay};const k1="return exp(x) - 1.0;",RJ=Ft({opSnippet:k1,packedOpSnippet:k1,cpuKernelImpl:i8}),FJ={kernelName:Fa,backendName:"webgl",kernelFunc:RJ};class I1{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";let a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function V$(s,t,e){const n=e.texData.get(s.dataId),r=K(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=ot({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),l=a.shape,c=new I1("real",l,t),u=new I1("imag",l,t),h=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],d=e.runWebGLProgram(c,h,"float32"),p=e.runWebGLProgram(u,h,"float32"),f=_i({inputs:{real:d,imag:p},backend:e});e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p);const m=ot({inputs:{x:f},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(f),m}function PJ(s){const{inputs:t,backend:e}=s,{input:n}=t;return V$(n,!1,e)}const LJ={kernelName:Gp,backendName:"webgl",kernelFunc:PJ};class MJ{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function hh(s){const{backend:t,attrs:e}=s,{shape:n,value:r}=e;let{dtype:i}=e;if(i=i||xo(r),i==="string"){const o=de(i,K(n));return o.fill(r),t.makeTensorInfo(n,i,o)}else{const o=new MJ(n,r),a=[[r]];return t.runWebGLProgram(o,[],i,a)}}const BJ={kernelName:jp,backendName:"webgl",kernelFunc:hh};class zJ{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const VJ={kernelName:Hp,backendName:"webgl",kernelFunc:({inputs:s,backend:t})=>{const{image:e}=s,n=t,r=new zJ(e.shape);return n.runWebGLProgram(r,[e],e.dtype)}};const N1="return floor(x);",WJ=Ft({opSnippet:N1,packedOpSnippet:N1,cpuKernelImpl:o8}),UJ={kernelName:Pa,backendName:"webgl",kernelFunc:WJ};const GJ=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,jJ=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,HJ=Ye({opSnippet:GJ,packedOpSnippet:jJ,dtype:"int32"}),XJ={kernelName:La,backendName:"webgl",kernelFunc:HJ};class qJ{constructor(t){this.variableNames=["A"];const e=hn(),[n,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class KJ{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=hn(),[n,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const YJ={kernelName:zd,backendName:"webgl",kernelFunc:ZJ};let Lo,Cg=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function ZJ(s){const{inputs:t,backend:e,attrs:n}=s;let{pixels:r}=t;const{numChannels:i}=n,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,i];if(a||o){const m=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Lo==null||m!==Cg)&&(Cg=m,Lo=document.createElement("canvas").getContext("2d",{willReadFrequently:Cg})),Lo.canvas.width=l,Lo.canvas.height=c,Lo.drawImage(r,0,0,l,c),r=Lo.canvas}const d=e.makeTensorInfo(u,"int32");e.texData.get(d.dataId).usage=qn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(d.dataId),r);const p=j().getBool("WEBGL_PACK")?new KJ(h):new qJ(h),f=e.runWebGLProgram(p,[d],"int32");return e.disposeData(d.dataId),f}function JJ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=Br(u),g=Be(r.shape,i.shape,l,h,c,d,!1,m);let y;const b=[],w=o!=null,x=a!=null,v=p==="leakyrelu",C=()=>{const I=[r,i],N=(_,T)=>{if(T==="NCHW"&&_.shape.length===1&&_.shape[0]!==1){const D=ot({inputs:{x:_},backend:e,attrs:{shape:[_.shape[0],1,1]}});return b.push(D),D}return _};if(w&&I.push(N(o,u)),x&&I.push(N(a,u)),v){const _=e.makeTensorInfo([],"float32",Lr(f,"float32"));I.push(_),b.push(_)}return I};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=F$({x:r,filter:i,convInfo:g,backend:e,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){const I=p?wc(p,!0):null,N=new R$(g,w,I,x,v),_=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=C();y=e.runWebGLProgram(N,T,"float32",_)}else if(j().getBool("WEBGL_CONV_IM2COL"))y=P$({x:r,filter:i,convInfo:g,backend:e,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const I=p?wc(p,!1):null,N=new O$(g,w,I,x,v),_=C();y=e.runWebGLProgram(N,_,"float32")}const k=ot({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(I=>e.disposeIntermediateTensorInfo(I)),k}const QJ={kernelName:ic,backendName:"webgl",kernelFunc:JJ};function tQ(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=n,f=[];let m=u;m==null&&(m=[1,1]),$(Xe(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Be(r.shape,i.shape,l,m,c,h,!0),y=j().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?wc(d,y):null,w=[r,i],x=o!=null,v=a!=null,C=d==="leakyrelu";if(x&&w.push(o),v&&w.push(a),C){const _=e.makeTensorInfo([],"float32",Lr(p,"float32"));w.push(_),f.push(_)}let k;y?k=new B$(g,x,b,v,C):k=new M$(g,x,b,v,C);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=e.runWebGLProgram(k,w,"float32",I);return f.forEach(_=>e.disposeIntermediateTensorInfo(_)),N}const eQ={kernelName:oc,backendName:"webgl",kernelFunc:tQ};class nQ{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const i=Ht(n.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function sQ(s){const{inputs:t,backend:e}=s,{params:n,indices:r}=t,i=r.shape,o=i[i.length-1],a=K(n.shape),[l,c,u,h]=gm(n,r),d=ot({inputs:{x:r},backend:e,attrs:{shape:[c,o]}}),p=ot({inputs:{x:n},backend:e,attrs:{shape:[K(n.shape)/u,u]}});if(e.shouldExecuteOnCPU([n,r])||n.dtype==="string"){const y=e.readSync(r.dataId),b=e.bufferSync(n),w=a8(y,b,n.dtype,c,o,u,h,n.shape,a);return e.makeTensorInfo(l,n.dtype,w.values)}const f=new nQ(o,h,[c,u],n.shape),m=e.runWebGLProgram(f,[p,d],p.dtype),g=ot({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const rQ={kernelName:Xp,backendName:"webgl",kernelFunc:sQ};class iQ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=Ht(this.rank),r=oQ(t);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function oQ(s,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<s.length;r++)r===2?n.push("index"):n.push(`${e[r]}`);return n.join()}function W$(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,indices:i}=t,{axis:o,batchDims:a}=n,l=$t(o,r.shape)[0];if(j().get("DEBUG")){const b=e.readSync(i.dataId),w=r.shape[l];for(let x=0;x<b.length;++x){const v=b[x];$(v<=w-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${w-1}]`)}}const c=Qb(r,i,l,a),u=K(i.shape),h=[],d=ot({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=ot({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const b=e.bufferSync(p),w=e.bufferSync(d),x=l8(w,b,f);return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.makeTensorInfo(c.outputShape,x.dtype,x.values)}const m=new iQ(d.shape,f),g=e.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=ot({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return h.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const aQ={kernelName:Hc,backendName:"webgl",kernelFunc:W$};const lQ="return float(a > b);",cQ=`
  return vec4(greaterThan(a, b));
`,uQ=Ye({opSnippet:lQ,packedOpSnippet:cQ,cpuKernelImpl:c8,dtype:"bool"}),hQ={kernelName:Xc,backendName:"webgl",kernelFunc:uQ};const dQ="return float(a >= b);",pQ=`
  return vec4(greaterThanEqual(a, b));
`,fQ=Ye({opSnippet:dQ,packedOpSnippet:pQ,dtype:"bool",cpuKernelImpl:u8}),mQ={kernelName:Ma,backendName:"webgl",kernelFunc:fQ};function gQ(s){const{inputs:t,backend:e}=s,{input:n}=t;return V$(n,!0,e)}const yQ={kernelName:qp,backendName:"webgl",kernelFunc:gQ};const bQ="return float(!isnan(x) && !isinf(x));",xQ=Ft({opSnippet:bQ,dtype:"bool"}),wQ={kernelName:za,backendName:"webgl",kernelFunc:xQ};const vQ="return float(isinf(x));",SQ=Ft({opSnippet:vQ,dtype:"bool"}),CQ={kernelName:Va,backendName:"webgl",kernelFunc:SQ};const TQ="return float(isnan(x));",kQ=Ft({opSnippet:TQ,dtype:"bool"}),IQ={kernelName:Wa,backendName:"webgl",kernelFunc:kQ};const NQ="return float(a < b);",$Q=`
  return vec4(lessThan(a, b));
`,_Q=Ye({opSnippet:NQ,packedOpSnippet:$Q,cpuKernelImpl:h8,dtype:"bool"}),EQ={kernelName:Kc,backendName:"webgl",kernelFunc:_Q};const DQ="return float(a <= b);",AQ=`
  return vec4(lessThanEqual(a, b));
`,OQ=Ye({opSnippet:DQ,packedOpSnippet:AQ,cpuKernelImpl:d8,dtype:"bool"}),RQ={kernelName:Yc,backendName:"webgl",kernelFunc:OQ};function FQ(s){const{backend:t,attrs:e}=s,{start:n,stop:r,num:i}=e,o=p8(n,r,i);return t.makeTensorInfo([o.length],"float32",o)}const PQ={kernelName:Yp,backendName:"webgl",kernelFunc:FQ};const LQ=$l+`
  return x < 0.0 ? 0./0. : log(x);
`,MQ=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,BQ=Ft({opSnippet:LQ,packedOpSnippet:MQ,cpuKernelImpl:f8}),zQ={kernelName:Ua,backendName:"webgl",kernelFunc:BQ};const VQ=$l+`
  return log(1.0 + x);
`,WQ=Ft({opSnippet:VQ}),UQ={kernelName:Ga,backendName:"webgl",kernelFunc:WQ};const GQ="return float(a >= 1.0 && b >= 1.0);",jQ=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,HQ=Ye({opSnippet:GQ,packedOpSnippet:jQ,dtype:"bool"}),XQ={kernelName:Zc,backendName:"webgl",kernelFunc:HQ};const qQ="return float(!(x >= 1.0));",KQ=Ft({opSnippet:qQ}),YQ={kernelName:Jc,backendName:"webgl",kernelFunc:KQ};const ZQ="return float(a >= 1.0 || b >= 1.0);",JQ=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,QQ=Ye({opSnippet:ZQ,packedOpSnippet:JQ,dtype:"bool"}),ttt={kernelName:Qc,backendName:"webgl",kernelFunc:QQ};class ett{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;this.outputShape=t;let l;const c=`float(${n}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class ntt{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;this.outputShape=t;let l;const c=`float(${n}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const stt=s=>{const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=n,c=j().getBool("WEBGL_PACK_NORMALIZATION")?new ntt(r.shape,i,o,a,l):new ett(r.shape,i,o,a,l);return e.runWebGLProgram(c,[r],r.dtype)},rtt={kernelName:tu,backendName:"webgl",kernelFunc:stt};class itt{constructor(t,e,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const ott=s=>{const{inputs:t,backend:e,attrs:n}=s,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=n,h=new itt(r.shape,a,l,c,u);return e.runWebGLProgram(h,[r,i,o],r.dtype)},att={kernelName:Zp,backendName:"webgl",kernelFunc:ott};function ltt(s,t,e,n){const r=K(t),o=K(s.shape)/r,a=ot({inputs:{x:s},attrs:{shape:[o,r]},backend:n}),l=Do(a,s.dtype,"max",n),c=ot({inputs:{x:l},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}function U$(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{reductionIndices:i,keepDims:o}=n,a=r.shape.length,l=$t(i,r.shape);let c=l;const u=ce(c,a),h=u!=null,d=e.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const w=e.texData.get(p.dataId).values,x=new Array(a);for(let k=0;k<x.length;k++)x[k]=r.shape[u[k]];const v=Lx(w,r.shape,r.dtype,u,x);p=e.makeTensorInfo(x,r.dtype);const C=e.texData.get(p.dataId);C.values=v}else p=Pm(r,u,e);c=me(c.length,a)}qe("max",c,a);const[f,m]=ze(p.shape,c);let g=f;o&&(g=fe(f,l));let y;if(d){const w=e.texData.get(p.dataId).values,x=m8(w,K(m),g,r.dtype);y=e.makeTensorInfo(g,r.dtype);const v=e.texData.get(y.dataId);v.values=x}else y=ltt(p,m,g,e);return h&&e.disposeIntermediateTensorInfo(p),y}const ctt={kernelName:eu,backendName:"webgl",kernelFunc:U$};const utt=Mx+`
  return max(a, b);
`,htt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Eo+`
  return result;
`,dtt=Ye({opSnippet:utt,packedOpSnippet:htt,cpuKernelImpl:g8}),ptt={kernelName:ja,backendName:"webgl",kernelFunc:dtt};function ftt(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t;lh(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n,c=1;$(Xe(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ds(r.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Dt(u.inShape,u.outShape))return zn({inputs:{x:r},backend:e});const h=new vc(u,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}const mtt={kernelName:nu,backendName:"webgl",kernelFunc:ftt};function gtt(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=n,u=[1,1,1],h=Mr(r.shape,i,o,u,a,c,l),d=new zx(h,"max",!1);return e.runWebGLProgram(d,[r],r.dtype)}const ytt={kernelName:su,backendName:"webgl",kernelFunc:gtt};class btt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,o=t.effectiveFilterWidth,a=i-1-t.padInfo.top,l=o-1-t.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class xtt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth,h=l-1-t.padInfo.front,d=c-1-t.padInfo.top,p=u-1-t.padInfo.left,f=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function wtt(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=n,h=[1,1,1],d=Mr(o.shape,a,l,h,c,u),p=new zx(d,"max",!0),f=e.runWebGLProgram(p,[o],o.dtype),m=new xtt(d),g=e.runWebGLProgram(m,[r,f],o.dtype);return e.disposeIntermediateTensorInfo(f),g}const vtt={kernelName:Qp,backendName:"webgl",kernelFunc:wtt};function Stt(s){const{inputs:t,backend:e,attrs:n}=s,{dy:r,input:i,output:o}=t,a=i;lh([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=n,d=ds(a.shape,l,c,1,u,h),p=!0,f=new vc(d,"max",p),m=e.runWebGLProgram(f,[a],a.dtype),g=new btt(d),y=e.runWebGLProgram(g,[r,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}const Ctt={kernelName:Jp,backendName:"webgl",kernelFunc:Stt};function Ttt(s,t,e,n){let r=new vc(e,"max",!1);const i=n.runWebGLProgram(r,[s],"float32");r=new vc(e,"max",!0,!0,t);const o=n.runWebGLProgram(r,[s],"float32");return[i,o]}const ktt={kernelName:tf,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:n}=s,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;$(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);const c=[1,1];$(Xe(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ds(n.shape,r,i,c,o),[h,d]=Ttt(n,a,u,l);return[h,d]}};function Itt(s,t,e,n){const r=K(t),o=K(s.shape)/r,a=ot({inputs:{x:s},attrs:{shape:[o,r]},backend:n}),l=Do(a,"float32","mean",n),c=ot({inputs:{x:l},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}const Ntt={kernelName:ru,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{x:n}=s,{keepDims:r,axis:i}=t,o=e,a=n.shape.length,l=$t(i,n.shape);let c=l;const u=ce(c,a),h=u!=null,d=o.shouldExecuteOnCPU([n]),p=[];let f=n;if(h){if(d){const x=o.texData.get(f.dataId).values,v=new Array(a);for(let I=0;I<v.length;I++)v[I]=n.shape[u[I]];const C=Lx(x,n.shape,n.dtype,u,v);f=o.makeTensorInfo(v,n.dtype);const k=o.texData.get(f.dataId);k.values=C}else f=Pm(n,u,o);p.push(f),c=me(c.length,a)}qe("sum",c,a);const[m,g]=ze(f.shape,c);let y=m;r&&(y=fe(m,l));const b=Itt(f,g,y,o);for(const w of p)o.disposeIntermediateTensorInfo(w);return b}};function $tt(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n,a=r.shape.length,l=$t(i,r.shape);let c=l;const u=ce(c,a);let h=r;u!=null&&(h=ln({inputs:{x:r},backend:e,attrs:{perm:u}}),c=me(c.length,r.shape.length)),qe("min",c,a);const[d,p]=ze(h.shape,c),f=K(p),m=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,f]}}),g=Do(m,m.dtype,"min",e);let y;if(o){const b=fe(d,l);y=ot({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ot({inputs:{x:g},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),u!=null&&e.disposeIntermediateTensorInfo(h),y}const _tt={kernelName:iu,backendName:"webgl",kernelFunc:$tt};const Ett=Mx+`
  return min(a, b);
`,Dtt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Eo+`
  return result;
`,Att=Ye({opSnippet:Ett,packedOpSnippet:Dtt,cpuKernelImpl:y8}),Ott={kernelName:Ha,backendName:"webgl",kernelFunc:Att};class Rtt{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((u,h)=>u[0]+t[h]+u[1]);const r=t.length,i=Ht(r),o=e.map(u=>u[0]).join(","),a=e.map((u,h)=>u[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class Ftt{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,m)=>f[0]+t[m]+f[1]);const r=t.length,i=Ht(r),o=e.map(f=>f[0]).join(","),a=e.map((f,m)=>f[0]+t[m]).join(","),l=on("rc",r),c=on("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=n==="reflect"?0:1;let p="";if(r===1){const f=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const f=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[r-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}const Ptt=({inputs:s,backend:t,attrs:e})=>{const{x:n}=s,{paddings:r,mode:i}=e,o=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ftt(n.shape,r,i):new Rtt(n.shape,r,i);return t.runWebGLProgram(o,[n],n.dtype)},Ltt={kernelName:ou,backendName:"webgl",kernelFunc:Ptt};const Mtt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Btt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Eo+`
  return result;
`,ztt=Ye({opSnippet:Mtt,packedOpSnippet:Btt}),Vtt={kernelName:Xa,backendName:"webgl",kernelFunc:ztt};class Wtt{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const Utt=`
if (a == b) {
  return 1.0;
};
return a / b;`,Gtt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,G$=Ye({opSnippet:Utt,packedOpSnippet:Gtt,checkOutOfBounds:!0}),jtt={kernelName:Da,backendName:"webgl",kernelFunc:G$};const $1="return a - b;",j$=Ye({opSnippet:$1,packedOpSnippet:$1,supportsComplex:!0,cpuKernelImpl:M8}),Htt={kernelName:cl,backendName:"webgl",kernelFunc:j$};function H$(s){const{inputs:t,backend:e,attrs:n}=s,{logits:r}=t,{dim:i}=n,o=$t([i],r.shape),a=U$({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=fe(a.shape,o),c=ot({inputs:{x:a},backend:e,attrs:{shape:l}}),u=j$({inputs:{a:r,b:c},backend:e}),h=z$({inputs:{x:u},backend:e}),d=Lm({inputs:{x:h},backend:e,attrs:{axis:o,keepDims:!1}}),p=ot({inputs:{x:d},backend:e,attrs:{shape:l}}),f=G$({inputs:{a:h,b:p},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),f}const Xtt={kernelName:Tu,backendName:"webgl",kernelFunc:H$};function qtt(s){const{inputs:t,backend:e,attrs:n}=s,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=n,l=a?r:H$({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new Wtt(c,u,i),d=[[o]],p=e.runWebGLProgram(h,[l],"int32",d);return a||e.disposeIntermediateTensorInfo(l),p}const Ktt={kernelName:ef,backendName:"webgl",kernelFunc:qtt};const Ytt=fs+`
  return -x;
`,Ztt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Jtt(s){const{inputs:t,backend:e}=s,{x:n}=t;if(e.shouldExecuteOnCPU([n])){const i=e.texData.get(n.dataId),[o,a]=x8(i.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,o)}let r;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ti(n.shape,Ztt):r=new Xs(n.shape,Ytt),e.runWebGLProgram(r,[n],n.dtype)}const Qtt={kernelName:au,backendName:"webgl",kernelFunc:Jtt};const tet=dm;function eet(s){jn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=n,c=e.readSync(r.dataId),u=e.readSync(i.dataId),{selectedIndices:h}=tet(c,u,o,a,l);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}const net={kernelName:nf,backendName:"webgl",kernelFunc:eet};const set=pm;function ret(s){jn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=n,u=e.readSync(r.dataId),h=e.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=set(u,h,o,a,l,c);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}const iet={kernelName:sf,backendName:"webgl",kernelFunc:ret};const oet=fm;function aet(s){jn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:n}=s,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=n,u=e.readSync(r.dataId),h=e.readSync(i.dataId),d=o,p=a,f=l,m=c,{selectedIndices:g,selectedScores:y}=oet(u,h,d,p,f,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const cet={kernelName:rf,backendName:"webgl",kernelFunc:aet};class uet{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}}const het=s=>{const{inputs:t,backend:e,attrs:n}=s,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=n,c=K(r.shape),u=new uet(c,o,a,l),h=ot({inputs:{x:r},backend:e,attrs:{shape:[c]}}),d=e.runWebGLProgram(u,[h],i);e.disposeIntermediateTensorInfo(h);const p=[...r.shape,o],f=ot({inputs:{x:d},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(d),f},det={kernelName:uu,backendName:"webgl",kernelFunc:het};function cp(s){const{inputs:t,backend:e}=s,{x:n}=t;if(n.dtype==="complex64"){const r=uh({inputs:{input:n},backend:e}),i=cp({inputs:{x:r},backend:e}),o=Mm({inputs:{input:n},backend:e}),a=cp({inputs:{x:o},backend:e}),l=_i({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return hh({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}const pet={kernelName:$u,backendName:"webgl",kernelFunc:cp};function X$(s){const{inputs:t,backend:e}=s,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){const r=uh({inputs:{input:n},backend:e}),i=X$({inputs:{x:r},backend:e}),o=Mm({inputs:{input:n},backend:e}),a=cp({inputs:{x:o},backend:e}),l=_i({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}else return hh({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}const fet={kernelName:cu,backendName:"webgl",kernelFunc:X$};function met(s){const{inputs:t,backend:e,attrs:n}=s,{axis:r}=n;if(t.length===1)return Ay({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{He(i,u.shape,"All tensors passed to stack must have matching shapes"),$(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(u=>{const h=Ay({inputs:{input:u},backend:e,attrs:{dim:r}});return a.push(h),h}),c=A$({inputs:l,backend:e,attrs:{axis:r}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const get={kernelName:hu,backendName:"webgl",kernelFunc:met};class yet{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const r=t.length,i=Ht(r),o=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class bet{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const r=t.length,i=Ht(r),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=on("rc",r),c=on("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${u}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}const q$=s=>{const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{paddings:i,constantValue:o}=n;if(K(r.shape)===0){const c=i.map((u,h)=>u[0]+r.shape[h]+u[1]);return hh({backend:e,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bet(r.shape,i,o):new yet(r.shape,i,o),l=[[o]];return e.runWebGLProgram(a,[r],r.dtype,l)},xet={kernelName:du,backendName:"webgl",kernelFunc:q$};const wet=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,vet=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Eo+`
  return result;
`,Cet=Ye({opSnippet:wet,packedOpSnippet:vet}),Tet={kernelName:Ka,backendName:"webgl",kernelFunc:Cet};function ket(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{axis:i,keepDims:o}=n,a=r.shape.length,l=[],c=$t(i,r.shape);let u=c;const h=ce(u,a);let d=r;h!=null&&(d=ln({inputs:{x:r},backend:e,attrs:{perm:h}}),u=me(u.length,a),l.push(d)),qe("prod",u,a);let p;if(e.shouldExecuteOnCPU([d])){const f=e.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=v8(d.shape,d.dtype,f,u);p=e.makeTensorInfo(g,y,m)}else{const[f,m]=ze(d.shape,u),g=K(m),y=ot({inputs:{x:d},backend:e,attrs:{shape:[-1,g]}}),b=Df(r.dtype),w=Do(y,b,"prod",e);p=ot({inputs:{x:w},backend:e,attrs:{shape:f}}),l.push(y),l.push(w)}if(o){l.push(p);const f=fe(p.shape,c);p=ot({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}const Iet={kernelName:fu,backendName:"webgl",kernelFunc:ket};function Net(s){const{inputs:t,backend:e,attrs:n}=s,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=n,l=r.map(y=>e.readSync(y.dataId)),c=r.map(y=>y.shape),u=e.readSync(i.dataId),h=e.readSync(o.dataId),[d,p,f]=S8(l,c,u,i.shape,i.dtype,h,o.shape,a),m=d.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(f,i.dtype,p);return m.concat([g])}const $et={kernelName:of,backendName:"webgl",kernelFunc:Net};function _et(s){const{inputs:t,backend:e}=s,{starts:n,limits:r,deltas:i}=t,o=e.readSync(n.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,u]=C8(o,n.shape,n.dtype,a,r.shape,l,i.shape),h=e.makeTensorInfo([c.length],"int32",c),d=e.makeTensorInfo([u.length],n.dtype,u);return[h,d]}const Eet={kernelName:af,backendName:"webgl",kernelFunc:_et};function Det(s){const{inputs:t,backend:e,attrs:n}=s,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=n,c=e.readSync(r.dataId),u=e.readSync(i.dataId),h=e.readSync(o.dataId),d=a.map(g=>e.readSync(g.dataId)),p=a.map(g=>g.shape),[f,m]=T8(c,r.shape,u,i.shape,i.dtype,h,o.shape,d,p,l);return e.makeTensorInfo(f,i.dtype,m)}const Aet={kernelName:lf,backendName:"webgl",kernelFunc:Det};const K$=s=>{const{backend:t,attrs:e}=s,{start:n,stop:r,step:i,dtype:o}=e,a=k8(n,r,i,o);return t.makeTensorInfo([a.length],o,a)},Oet={kernelName:cf,backendName:"webgl",kernelFunc:K$};const Ret="return 1.0 / x;",Fet=Ft({opSnippet:Ret}),Pet={kernelName:Ya,backendName:"webgl",kernelFunc:Fet};const Let=fs+`
  return (x < 0.0) ? 0.0 : x;
`,Met=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bet=Ft({opSnippet:Let,packedOpSnippet:Met}),zet={kernelName:Za,backendName:"webgl",kernelFunc:Bet};const Vet=fs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Wet=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Uet=Ft({opSnippet:Vet,packedOpSnippet:Wet}),Get={kernelName:Ja,backendName:"webgl",kernelFunc:Uet};class jet{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,n,c];const u=[r&&e>1?a-1:a,r&&n>1?l-1:l],h=[r&&e>1?e-1:e,r&&n>1?n-1:n];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class Het{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,n,c];const u=[r&&e>1?a-1:a,r&&n>1?l-1:l],h=[r&&e>1?e-1:e,r&&n>1?n-1:n];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Xet(s){const{inputs:t,backend:e,attrs:n}=s,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=n,[l,c]=a,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Het(r.shape,l,c,i,o):new jet(r.shape,l,c,i,o);return e.runWebGLProgram(u,[r],"float32")}const qet={kernelName:yu,backendName:"webgl",kernelFunc:Xet};class Ket{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[n&&o>1?r-1:r,n&&a>1?i-1:i],c=[n&&o>1?o-1:o,n&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function Yet(s){const{inputs:t,backend:e,attrs:n}=s,{images:r,dy:i}=t,{alignCorners:o}=n,a=new Ket(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}const Zet={kernelName:df,backendName:"webgl",kernelFunc:Yet};class Jet{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,n,c];const u=[r&&e>1?a-1:a,r&&n>1?l-1:l],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class Qet{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,n,c];const u=[r&&e>1?a-1:a,r&&n>1?l-1:l],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=r?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function tnt(s){const{inputs:t,backend:e,attrs:n}=s,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=n,[l,c]=a,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Qet(r.shape,l,c,i,o):new Jet(r.shape,l,c,i,o);return e.runWebGLProgram(u,[r],r.dtype)}const ent={kernelName:gu,backendName:"webgl",kernelFunc:tnt};class nnt{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,a]=t,l=[n&&o>1?r-1:r,n&&a>1?i-1:i],c=[n&&o>1?o-1:o,n&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function snt(s){const{inputs:t,backend:e,attrs:n}=s,{images:r,dy:i}=t,{alignCorners:o}=n,a=new nnt(i.shape,r.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}const rnt={kernelName:hf,backendName:"webgl",kernelFunc:snt};class int{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,i=t.map((a,l)=>r(l)).join(","),o=Ht(n);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class ont{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=on("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Ht(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${u(r.slice())};
            if(${i}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[n-1]="("+f[n-1]+" + 1)",d(f)}function u(f){return f[n-2]="("+f[n-2]+" + 1)",d(f)}function h(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",d(f)}function d(f){const m=t.map((b,w)=>p(w,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return e.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}}}function ant(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{dims:i}=n,o=r.shape.length,a=$t(i,r.shape);if(o===0)return zn({inputs:{x:r},backend:e});const l=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ont(r.shape,a):new int(r.shape,a);return e.runWebGLProgram(l,[r],r.dtype)}const lnt={kernelName:bu,backendName:"webgl",kernelFunc:ant};class cnt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const unt={kernelName:_f,backendName:"webgl",kernelFunc:({inputs:s,attrs:t,backend:e})=>{const{image:n}=s,{radians:r,fillValue:i,center:o}=t,a=e,l=new cnt(n.shape,i),[c,u]=Lb(o,n.shape[1],n.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[n],n.dtype,h)}};const hnt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,dnt=Ft({opSnippet:hnt}),pnt={kernelName:Qa,backendName:"webgl",kernelFunc:dnt};const fnt="return inversesqrt(x);",mnt=Ft({opSnippet:fnt,cpuKernelImpl:I8}),gnt={kernelName:tl,backendName:"webgl",kernelFunc:mnt};class Vx{constructor(t,e,n,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Ht(i.length),u=Ht(o.length);let h="";n===1?h="i":n===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}class ynt{constructor(t,e,n,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Ht(i.length),u=Ht(o.length);let h="";n===1?h="i":n===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=e>1?"strides[j]":"strides",b=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}function bnt(s){const{inputs:t,backend:e,attrs:n}=s,{indices:r,updates:i}=t,{shape:o}=n,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Ii(i,r,o),d=[h/c,c];if(h===0)return e.makeTensorInfo(o,r.dtype);const p=ot({inputs:{x:r},backend:e,attrs:{shape:[l,a]}}),f=ot({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0]));let g;j().getBool("WEBGL_PACK")?g=new ynt(l,a,p.shape.length,f.shape.length,u,d):g=new Vx(l,a,p.shape.length,f.shape.length,u,d);const y=e.runWebGLProgram(g,[f,p,m],f.dtype),b=ot({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}const xnt={kernelName:pf,backendName:"webgl",kernelFunc:bnt};class wnt{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=j().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function vnt(s){const{inputs:t,backend:e,attrs:n}=s,{sortedSequence:r,values:i}=t,{side:o}=n,a=new wnt(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return e.runWebGLProgram(a,[r,i],"int32",l)}const Snt={kernelName:mf,backendName:"webgl",kernelFunc:vnt};class Cnt{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);r=l.join(),i=c.join()}const o=Ht(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function Tnt(s){const{inputs:t,backend:e}=s,{condition:n,t:r,e:i}=t,o=new Cnt(n.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[n,r,i],bn(r.dtype,i.dtype))}const knt={kernelName:xu,backendName:"webgl",kernelFunc:Tnt};const Int=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${xm};
  float scale = ${wm};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Nnt=Ft({opSnippet:Int}),$nt={kernelName:el,backendName:"webgl",kernelFunc:Nnt};const _nt=$l+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Ent=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dnt=Ft({opSnippet:_nt,packedOpSnippet:Ent,cpuKernelImpl:$8}),Ant={kernelName:il,backendName:"webgl",kernelFunc:Dnt};const Ont=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Rnt=Ft({opSnippet:Ont}),Fnt={kernelName:rl,backendName:"webgl",kernelFunc:Rnt};const Pnt=$l+`
  return sin(x);
`,Lnt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Eo}
  return result;
`,Mnt=Ft({opSnippet:Pnt,packedOpSnippet:Lnt}),Bnt={kernelName:nl,backendName:"webgl",kernelFunc:Mnt};const znt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Vnt=Ft({opSnippet:znt}),Wnt={kernelName:sl,backendName:"webgl",kernelFunc:Vnt};const Unt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Gnt=Ft({opSnippet:Unt}),jnt={kernelName:ol,backendName:"webgl",kernelFunc:Gnt};const Hnt=s=>{const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{blockShape:i,paddings:o}=n;$(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<r.shape.length;++y)l.push([0,0]);const c=[],u=q$({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),h=Ku(u.shape,i,a,!1),d=Yu(h.length,i.length,!1),p=Zu(u.shape,i,a,!1),f=ot({inputs:{x:u},backend:e,attrs:{shape:h}}),m=ln({inputs:{x:f},backend:e,attrs:{perm:d}}),g=ot({inputs:{x:m},backend:e,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g},Xnt={kernelName:Su,backendName:"webgl",kernelFunc:Hnt};function qnt(s){const{inputs:t,backend:e}=s,{indices:n,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=e.readSync(n.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[h,d,p,f,m]=E8(a,n.shape,n.dtype,l,r.dtype,c,u);return[e.makeTensorInfo(d,n.dtype,h),e.makeTensorInfo([d[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}const Knt={kernelName:gf,backendName:"webgl",kernelFunc:qnt};function Ynt(s){const{inputs:t,backend:e}=s,{inputIndices:n,inputShape:r,newShape:i}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(r.dataId)),a=e.readSync(n.dataId),l=Array.from(e.readSync(i.dataId)),[c,u,h]=D8(a,n.shape,n.dtype,o,l);return[e.makeTensorInfo(u,n.dtype,c),e.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const Znt={kernelName:yf,backendName:"webgl",kernelFunc:Ynt};function Jnt(s){const{inputs:t,backend:e}=s,{data:n,indices:r,segmentIds:i}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=e.readSync(n.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,u]=x$(o,n.shape,n.dtype,a,l,!0);return e.makeTensorInfo(u,n.dtype,c)}const Qnt={kernelName:bf,backendName:"webgl",kernelFunc:Jnt};function tst(s){const{inputs:t,backend:e}=s,{data:n,indices:r,segmentIds:i}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=e.readSync(n.dataId),a=e.readSync(r.dataId),l=e.readSync(i.dataId),[c,u]=x$(o,n.shape,n.dtype,a,l);return e.makeTensorInfo(u,n.dtype,c)}const est={kernelName:xf,backendName:"webgl",kernelFunc:tst};function nst(s){const{inputs:t,backend:e,attrs:n}=s,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=n,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=Ii(i,r,a),p=!1;if(i.dtype==="string"){const y=e.bufferSync(r),b=e.bufferSync(i),w=$r(e.readSync(o.dataId)[0]),x=N8(y,b,a,d,u,c,l,h,w,p);return e.makeTensorInfo(a,x.dtype,x.values)}const f=new Vx(c,l,r.shape.length,i.shape.length,h,[d,1],p),m=e.runWebGLProgram(f,[i,r,o],i.dtype),g=ot({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}const sst={kernelName:wf,backendName:"webgl",kernelFunc:nst};function rst(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{numOrSizeSplits:i,axis:o}=n,a=$t(o,r.shape)[0],l=Jb(r,i,a),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=_l({inputs:{x:r},backend:e,attrs:{begin:u,size:p}});return u[a]+=d,f})}const ist={kernelName:Cu,backendName:"webgl",kernelFunc:rst};const _1="return sqrt(x);",ost=Ft({opSnippet:_1,packedOpSnippet:_1,cpuKernelImpl:A8}),ast={kernelName:al,backendName:"webgl",kernelFunc:ost};const lst="return x * x;",cst=Ft({opSnippet:lst}),ust={kernelName:vf,backendName:"webgl",kernelFunc:cst};const E1="return (a - b) * (a - b);",hst=Ye({opSnippet:E1,packedOpSnippet:E1}),dst={kernelName:ll,backendName:"webgl",kernelFunc:hst};function pst(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(r.dataId),o=Or(i),a=O8(o,"string",n);return e.makeTensorInfo(r.shape,"string",a)}const fst={kernelName:ku,backendName:"webgl",kernelFunc:pst};function mst({inputs:s,attrs:t,backend:e}){const{x:n}=s,r=fs+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new Xs(n.shape,r);return e.runWebGLProgram(i,[n],n.dtype)}const gst={kernelName:pl,backendName:"webgl",kernelFunc:mst};class yst{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=Ht(n.length),o=Ht(n.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=n.map((c,u)=>(l++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}function bst(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=n,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:x}=Ob(r.shape,i,o,a,l,c,u,h,d);let v;if(m)v=ot({inputs:{x:r},backend:e,attrs:{shape:f}});else if(g||y){$(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=Eb(b,w,x),I=_l({inputs:{x:r},backend:e,attrs:{begin:b,size:k}});v=ot({inputs:{x:I},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(I)}else if(e.shouldExecuteOnCPU([r])){const I=e.readSync(r.dataId),N=Tt(r.shape,r.dtype,I),_=R8(p,N,x,b);v=e.makeTensorInfo(f,r.dtype,_.values)}else{const I=new yst(b,x,p);v=e.runWebGLProgram(I,[r],r.dtype)}const C=ot({inputs:{x:v},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(v),C}const xst={kernelName:Sf,backendName:"webgl",kernelFunc:bst};function wst(s){const{inputs:t,backend:e,attrs:n}=s,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=n,{data:u,dataSplits:h}=t,d=e.readSync(u.dataId),p=e.readSync(h.dataId),[f,m]=F8(d,p,r,i,o,a,l,c);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(h.shape,"int32",m)]}const vst={kernelName:Cf,backendName:"webgl",kernelFunc:wst};function Sst(s){const{inputs:t,backend:e,attrs:n}=s,{skipEmpty:r}=n,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,u,h]=P8(a,l,r),d=u.length;return[e.makeTensorInfo([d,2],"int32",c),e.makeTensorInfo([d],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(h))]}const Cst={kernelName:Tf,backendName:"webgl",kernelFunc:Sst};function Tst(s){const{inputs:t,backend:e,attrs:n}=s,{numBuckets:r}=n,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=L8(o,r);return e.makeTensorInfo(i.shape,"int32",a)}const kst={kernelName:kf,backendName:"webgl",kernelFunc:Tst};const Ist="return tan(x);",Nst=Ft({opSnippet:Ist}),$st={kernelName:ul,backendName:"webgl",kernelFunc:Nst};const _st=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Est=Ft({opSnippet:_st}),Dst={kernelName:hl,backendName:"webgl",kernelFunc:Est};function Ast(s){const{inputs:t,backend:e,attrs:n}=s,{tensor:r,indices:i,updates:o}=t,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Ii(o,i,r.shape),d=[h/c,c];if(h===0)return e.makeTensorInfo(r.shape,i.dtype);const p=ot({inputs:{x:i},backend:e,attrs:{shape:[l,a]}}),f=ot({inputs:{x:o},backend:e,attrs:{shape:[l,c]}}),m=ot({inputs:{x:r},backend:e,attrs:{shape:d}}),g=new Vx(l,a,p.shape.length,f.shape.length,u,d,!1,!0),y=e.runWebGLProgram(g,[f,p,m],m.dtype),b=ot({inputs:{x:y},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const Ost={kernelName:ff,backendName:"webgl",kernelFunc:Ast};class Rst{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[o]*e[o];this.outputShape=n,this.rank=n.length;const r=Ht(this.rank),i=Fst(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function Fst(s){const t=s.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${s[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let r=0;r<s.length;r++)n.push(`imod(${e[r]}, ${s[r]})`);return n.join()}function Y$(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{reps:i}=n;if(r.dtype==="string"||r.shape.length>5){const l=e.readSync(r.dataId),c=r.dtype==="string"?l.map(d=>$r(d)):l,u=Tt(r.shape,r.dtype,c),h=B8(u,i);return e.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new Rst(r.shape,i);return e.runWebGLProgram(o,[r],r.dtype)}const Pst={kernelName:dl,backendName:"webgl",kernelFunc:Y$};class Lst{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Mst{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Oi(s,t){t!==null&&s.disposeIntermediateTensorInfo(t)}function D1(s){let t=1;for(;t<s;)t*=2;return t}function Bst(s){const{inputs:t,backend:e,attrs:n}=s,{x:r}=t,{k:i,sorted:o}=n,a=j().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=j().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([r])||u<a||i>l){const _=e.readSync(r.dataId),[T,D]=z8(_,c,r.dtype,i,o);return[e.makeTensorInfo(T.shape,T.dtype,T.values),e.makeTensorInfo(D.shape,D.dtype,D.values)]}if(i===0)return c[c.length-1]=0,[e.makeTensorInfo(c,r.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(u===1)return[r,hh({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const h=e.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?e.unpackTensor(r):r,m=K(c)/u,g=ot({inputs:{x:p},attrs:{shape:[m,u]},backend:e});d&&Oi(e,p);const y=D1(i),b=D1(u);let w=null;const x=()=>w===null?[g,g]:[g,w],v=(_,T,D)=>{const R=x(),P=new Lst(D),U=[[u],[w===null?1:0],[Number.NEGATIVE_INFINITY],[_],[T]],H=w;w=e.runWebGLProgram(P,R,"int32",U),Oi(e,H)};for(let _=1;_<y;_*=2){const T=_*2;for(let D=_;D>=1;D/=2)v(T,D,[m,b])}for(let _=b;_>y;_/=2){const T=x(),D=new Mst([m,_/2]),P=[[u],[w===null?1:0],[y]],B=w;w=e.runWebGLProgram(D,T,"int32",P),Oi(e,B);const U=y/2,H=U*2;for(let G=U;G>=1;G/=2)v(H,G,w.shape)}let C=w;w=_l({inputs:{x:w},backend:e,attrs:{begin:0,size:[m,i]}}),Oi(e,C);let k=W$({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});Oi(e,g);const I=c.slice(0,-1);I.push(i),C=w,w=ot({inputs:{x:w},attrs:{shape:I},backend:e}),Oi(e,C);const N=k;return k=ot({inputs:{x:k},attrs:{shape:I},backend:e}),Oi(e,N),[k,w]}const zst={kernelName:If,backendName:"webgl",kernelFunc:Bst};class Vst{constructor(t,e,n,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=n==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function Wst(s){const{inputs:t,backend:e,attrs:n}=s,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=n,[u,h,d,p]=r.shape,[f,m]=c??[h,d],g=[u,f,m,p],y=new Vst(h,d,o,a,l,g);return e.runWebGLProgram(y,[r,i],"float32")}const Ust={kernelName:Nf,backendName:"webgl",kernelFunc:Wst};function Gst(s){const{inputs:t,attrs:e,backend:n}=s,{axis:r}=e,{x:i}=t;lh(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=n.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=V8(o,r,i.shape,i.dtype);return[n.makeTensorInfo(l,i.dtype,a),n.makeTensorInfo([c.length],"int32",c)]}const jst={kernelName:$f,backendName:"webgl",kernelFunc:Gst};function Hst(s){const{inputs:t,backend:e,attrs:n}=s,{value:r}=t;let{axis:i}=n;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const g=_l({inputs:{x:o},backend:e,attrs:{begin:d,size:p}}),y=ot({inputs:{x:g},backend:e,attrs:{shape:c}});f[m]=y,h.push(g)}return h.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}const Xst={kernelName:Iu,backendName:"webgl",kernelFunc:Hst};class qst{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/n);this.outputShape=[r,a];const l="0.0",c="sumValue",u=Math.floor(n/4)*4,h=n%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";i%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let f="";i%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}function Kst(s){const{inputs:t,backend:e,attrs:n}=s,{x:r,segmentIds:i}=t,{numSegments:o}=n,a=r.shape.length,l=[];let c=0;const u=ce([c],a);let h=r;u!=null&&(h=ln({inputs:{x:r},backend:e,attrs:{perm:u}}),l.push(h),c=me(1,a)[0]);const d=dk(h.shape,c,o),p=K([h.shape[c]]),f=ot({inputs:{x:h},backend:e,attrs:{shape:[-1,p]}});l.push(f);const m=Df(r.dtype),g=(x,v,C,k,I)=>{const N=x.shape[0],_=x.shape[1],T=hk(_,I),D={windowSize:T,inSize:_,batchSize:N,numSegments:I},R=new qst(D,v),P=e.compileAndRun(R,[x,C],k);if(l.push(P),P.shape[1]===I)return P;const B=K$({backend:e,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),U=Y$({inputs:{x:B},backend:e,attrs:{reps:[_/T]}});return l.push(B),l.push(U),g(P,v,U,k,I)},y=g(f,"unsortedSegmentSum",i,m,o),b=ot({inputs:{x:y},backend:e,attrs:{shape:d}});let w=b;if(u!=null){l.push(b);const x=Ci(u);w=ln({inputs:{x:w},backend:e,attrs:{perm:x}})}return l.forEach(x=>e.disposeIntermediateTensorInfo(x)),w}const Yst={kernelName:Nu,backendName:"webgl",kernelFunc:Kst};const Zst=[A7,R7,L7,z7,W7,j7,X7,K7,Q7,e9,r9,a9,u9,f9,y9,x9,v9,k9,N9,_9,O9,z9,W9,H9,q9,tZ,nZ,oZ,m7,cZ,fZ,bZ,TZ,NZ,_Z,DZ,OZ,LZ,zZ,UZ,jZ,XZ,KZ,JZ,tJ,rJ,oJ,cJ,dJ,fJ,bJ,SJ,IJ,_J,AJ,OJ,FJ,LJ,BJ,VJ,UJ,XJ,YJ,QJ,eQ,rQ,aQ,hQ,mQ,f7,yQ,dZ,wQ,CQ,IQ,y7,EQ,RQ,PQ,zQ,UQ,XQ,YQ,ttt,rtt,att,ctt,ptt,mtt,ytt,vtt,Ctt,ktt,Ntt,_tt,Ott,Ltt,Vtt,Ktt,w7,Qtt,net,iet,cet,Y9,det,fet,get,xet,Tet,x7,Iet,$et,Eet,Aet,Oet,Z9,jtt,Pet,zet,Get,S7,qet,Zet,ent,rnt,lnt,unt,pnt,gnt,xnt,Snt,knt,$nt,Ant,Fnt,Bnt,Wnt,M9,Xtt,jnt,Xnt,Knt,Znt,Qnt,est,sst,ist,ast,ust,dst,fst,gst,xst,vst,Cst,kst,Htt,_7,$st,Dst,Ost,Pst,zst,Ust,E7,jst,Xst,Yst,pet];for(const s of Zst)Ef(s);class Jst{constructor(t){this.canvasId=t,this.fabricCanvas=null,this.webcamVideo=document.getElementById("webcam-video"),this.screenVideo=document.getElementById("screen-video"),this.net=null,this.isSegmenting=!1,this.webcamImage=null,this.screenImage=null,this.width=1920,this.height=1080,this.screenRenderCanvas=null,this.screenRenderCtx=null}async init(){this.fabricCanvas=new Fg(this.canvasId,{width:this.width,height:this.height,backgroundColor:"#000",selection:!0}),this.resizeCanvas(),window.addEventListener("resize",()=>this.resizeCanvas()),this.setupGestures(),console.log("Loading BodyPix..."),await aC(),this.net=await AV({architecture:"MobileNetV1",outputStride:16,multiplier:.75,quantBytes:2}),console.log("BodyPix Loaded")}setupGestures(){this.fabricCanvas.on("mouse:wheel",o=>{const a=o.e;if(!(o.target===this.webcamImage||this.fabricCanvas.getActiveObject()===this.webcamImage))return;if(a.ctrlKey){a.preventDefault(),a.stopPropagation();const h=a.deltaY,d=this.webcamImage.scaleX,p=h>0?.95:1.05,f=Math.max(.1,Math.min(3,d*p));this.webcamImage.scale(f),this.fabricCanvas.requestRenderAll();return}a.preventDefault(),a.stopPropagation();const u=this.webcamImage.angle||0;this.webcamImage.rotate(u+(a.deltaY>0?1:-1)),this.fabricCanvas.requestRenderAll()});let t=1;document.addEventListener("gesturestart",o=>{this.webcamImage&&(o.preventDefault(),t=this.webcamImage.scaleX)},{passive:!1}),document.addEventListener("gesturechange",o=>{if(this.webcamImage){o.preventDefault();const a=Math.max(.1,Math.min(3,t*o.scale));this.webcamImage.scale(a),this.fabricCanvas.requestRenderAll()}},{passive:!1}),document.addEventListener("gestureend",o=>{o.preventDefault()},{passive:!1});let e=0,n=1,r=!1;const i=this.fabricCanvas.upperCanvasEl||this.fabricCanvas.getElement();if(!i){console.error("Could not find canvas element for touch gestures");return}i.addEventListener("touchstart",o=>{const l=this.fabricCanvas.findTarget(o)===this.webcamImage||this.fabricCanvas.getActiveObject()===this.webcamImage;o.touches.length===2&&l&&(r=!0,e=this.getDistance(o.touches[0],o.touches[1]),n=this.webcamImage.scaleX,o.preventDefault())},{passive:!1}),i.addEventListener("touchmove",o=>{if(r&&o.touches.length===2&&this.webcamImage){const l=this.getDistance(o.touches[0],o.touches[1])/e,c=n*l;this.webcamImage.scale(c),this.fabricCanvas.requestRenderAll(),o.preventDefault()}},{passive:!1}),i.addEventListener("touchend",o=>{r&&(r=!1)})}getDistance(t,e){const n=t.clientX-e.clientX,r=t.clientY-e.clientY;return Math.sqrt(n*n+r*r)}resizeCanvas(){const t=document.getElementById("canvas-container"),e=this.width/this.height,n=t.clientWidth,r=t.clientHeight;let i,o;n/r>e?(o=r,i=o*e):(i=n,o=i/e),this.fabricCanvas&&this.fabricCanvas.setDimensions({width:`${i}px`,height:`${o}px`},{cssOnly:!0})}async startCamera(){try{const t=await navigator.mediaDevices.getUserMedia({video:!0,audio:!0});this.webcamVideo.srcObject=t,this.webcamVideo.muted=!0,await this.webcamVideo.play();const e=document.createElement("canvas");return e.width=this.webcamVideo.videoWidth,e.height=this.webcamVideo.videoHeight,this.webcamRenderCanvas=e,this.webcamRenderCtx=e.getContext("2d"),this.webcamImage=new $n(e,{left:this.width-350,top:this.height-250,scaleX:.5,scaleY:.5,originX:"center",originY:"center",flipX:!0,selectable:!0,hasControls:!0,hasBorders:!0,lockUniScaling:!1,cornerColor:"#bb86fc",cornerStyle:"circle",cornerSize:12,transparentCorners:!1,borderColor:"#bb86fc",borderScaleFactor:2}),this.fabricCanvas.add(this.webcamImage),this.fabricCanvas.bringObjectToFront(this.webcamImage),this.isSegmenting=!0,this.startRenderLoop(),t}catch(t){throw console.error("Error starting camera:",t),location.protocol!=="https:"&&location.hostname!=="localhost"&&location.hostname!=="127.0.0.1"?alert("Camera access requires HTTPS when using an external network IP. Please check the URL starts with https://"):alert(`Failed to start camera: ${t.name} - ${t.message}`),t}}async startScreenShare(){try{const t=await navigator.mediaDevices.getDisplayMedia({video:{cursor:"always"},audio:!0});this.screenVideo.srcObject=t,this.screenVideo.muted=!0,await this.screenVideo.play(),this.screenImage&&this.fabricCanvas.remove(this.screenImage),this.screenRenderCanvas=document.createElement("canvas"),this.screenRenderCanvas.width=this.screenVideo.videoWidth,this.screenRenderCanvas.height=this.screenVideo.videoHeight,this.screenRenderCtx=this.screenRenderCanvas.getContext("2d"),this.screenImage=new $n(this.screenRenderCanvas,{left:0,top:0,originX:"center",originY:"center",selectable:!1,evented:!1,objectCaching:!1});const e=Math.min(this.width/this.screenVideo.videoWidth,this.height/this.screenVideo.videoHeight);return this.screenImage.scale(e),this.screenImage.set({left:this.width/2,top:this.height/2}),this.fabricCanvas.add(this.screenImage),this.fabricCanvas.sendObjectToBack(this.screenImage),this.webcamImage&&this.fabricCanvas.bringObjectToFront(this.webcamImage),t.getVideoTracks()[0].onended=()=>{this.fabricCanvas.remove(this.screenImage),this.screenImage=null,this.screenRenderCanvas=null,this.screenRenderCtx=null},this.startRenderLoop(),t}catch(t){throw console.error("Error starting screen share:",t),t}}startRenderLoop(){if(this.animationRunning)return;this.animationRunning=!0;const t=document.createElement("canvas");let e=null;const n=async()=>{if(this.isSegmenting&&this.webcamVideo.readyState===4)try{(t.width!==this.webcamVideo.videoWidth||t.height!==this.webcamVideo.videoHeight)&&(t.width=this.webcamVideo.videoWidth,t.height=this.webcamVideo.videoHeight,e=t.getContext("2d"));const r=await this.net.segmentPerson(this.webcamVideo,{internalResolution:"medium",segmentationThreshold:.7,maxDetections:1}),a=OV(r,{r:0,g:0,b:0,a:255},{r:0,g:0,b:0,a:0});e.putImageData(a,0,0),this.webcamRenderCtx.clearRect(0,0,this.webcamRenderCanvas.width,this.webcamRenderCanvas.height),this.webcamRenderCtx.save(),this.webcamRenderCtx.drawImage(this.webcamVideo,0,0),this.webcamRenderCtx.globalCompositeOperation="destination-in",this.webcamRenderCtx.drawImage(t,0,0),this.webcamRenderCtx.restore(),this.webcamImage&&(this.webcamImage.dirty=!0)}catch(r){console.warn("Segmentation error:",r)}this.screenImage&&this.screenRenderCtx&&this.screenVideo.readyState>=2&&(this.screenRenderCtx.drawImage(this.screenVideo,0,0),this.screenImage.dirty=!0),this.fabricCanvas.renderAll(),requestAnimationFrame(n)};n()}getCanvasStream(){return document.getElementById(this.canvasId).captureStream(30)}}class Qst{constructor(t,e){this.canvasStream=t,this.audioStreams=e||[],this.mediaRecorder=null,this.chunks=[],this.blob=null}start(){const t=new MediaStream;this.canvasStream.getVideoTracks().forEach(o=>t.addTrack(o)),this.audioStreams.forEach(o=>{o.getAudioTracks().forEach(a=>t.addTrack(a))});let e="video/webm;codecs=vp9,opus",n="webm";const r=["video/mp4;codecs=avc1,mp4a.40.2","video/mp4"];for(const o of r)if(MediaRecorder.isTypeSupported(o)){e=o,n="mp4";break}console.log(`Using MIME type: ${e}`);const i={mimeType:e,videoBitsPerSecond:5e6,audioBitsPerSecond:128e3};try{this.mediaRecorder=new MediaRecorder(t,i)}catch(o){console.warn("Error creating MediaRecorder with options, trying default:",o),this.mediaRecorder=new MediaRecorder(t)}this.chunks=[],this.extension=n,this.mediaRecorder.ondataavailable=o=>{o.data.size>0&&this.chunks.push(o.data)},this.mediaRecorder.start(1e3),console.log("Recording started")}getRecordedBlob(){return{blob:this.blob,extension:this.extension||"webm"}}async stop(){return new Promise(t=>{this.mediaRecorder.onstop=()=>{const e=this.mediaRecorder.mimeType||"video/webm";this.blob=new Blob(this.chunks,{type:e}),console.log("Recording stopped, blob created:",this.blob.size,"Type:",e),t(this.getRecordedBlob())},this.mediaRecorder.stop()})}}const trt={compositor:null,recorder:null,isRecording:!1,webcamStream:null,screenStream:null,ui:{btnStartCamera:document.getElementById("btn-start-camera"),btnShareScreen:document.getElementById("btn-share-screen"),btnRecord:document.getElementById("btn-record"),loadingOverlay:document.getElementById("loading-overlay"),loadingText:document.getElementById("loading-text"),statusIndicator:document.getElementById("status-indicator")},async init(){this.showLoading(!0,"Initializing Engine...");try{this.compositor=new Jst("main-canvas"),await this.compositor.init(),this.setupEventListeners(),this.showLoading(!1),this.setStatus("Ready")}catch(s){console.error(s),this.showLoading(!1),this.setStatus("Initialization Failed")}},setupEventListeners(){this.ui.btnStartCamera.onclick=async()=>{this.ui.btnStartCamera.disabled=!0;try{this.webcamStream=await this.compositor.startCamera(),this.checkReadyToRecord()}catch(s){console.error(s),this.ui.btnStartCamera.disabled=!1,alert("Failed to access camera.")}},this.ui.btnShareScreen.onclick=async()=>{this.ui.btnShareScreen.disabled=!0;try{this.screenStream=await this.compositor.startScreenShare(),this.checkReadyToRecord(),this.screenStream.getVideoTracks()[0].onended=()=>{this.ui.btnShareScreen.disabled=!1,this.screenStream=null,this.checkReadyToRecord()}}catch(s){console.error(s),this.ui.btnShareScreen.disabled=!1}},this.ui.btnRecord.onclick=()=>{this.isRecording?this.stopRecording():this.startRecording()}},checkReadyToRecord(){this.webcamStream||this.screenStream?this.ui.btnRecord.disabled=!1:this.ui.btnRecord.disabled=!0},async startRecording(){this.isRecording=!0,this.ui.btnRecord.textContent="Stop Recording",this.ui.btnRecord.classList.add("recording"),this.setStatus("Recording...");const s=[];this.webcamStream&&s.push(this.webcamStream),this.screenStream&&s.push(this.screenStream),this.recorder=new Qst(this.compositor.getCanvasStream(),s),this.recorder.start()},async stopRecording(){this.isRecording=!1,this.ui.btnRecord.textContent="Start Recording",this.ui.btnRecord.classList.remove("recording"),this.ui.btnRecord.disabled=!0,this.showLoading(!0,"Finalizing Video..."),this.setStatus("Processing...");const{blob:s,extension:t}=await this.recorder.stop();try{const e=`fastrecord-output.${t}`;this.download(s,e),this.setStatus(`Saved as ${t.toUpperCase()}!`)}catch(e){console.error("Save failed",e),this.setStatus("Save Failed")}this.showLoading(!1),this.checkReadyToRecord()},download(s,t){const e=URL.createObjectURL(s),n=document.createElement("a");n.href=e,n.download=t,document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(e)},showLoading(s,t=""){this.ui.loadingOverlay.style.display=s?"flex":"none",t&&(this.ui.loadingText.textContent=t)},updateLoadingText(s){this.ui.loadingText.textContent=s},setStatus(s){this.ui.statusIndicator.textContent=s}};trt.init();
